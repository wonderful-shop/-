> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码

> 前端工程师面试题 - 基础题 - ChatGPT plus 答案版。 本册参照《2022年前端工程师面试题》第一章“前端基础”作为问题列表，同一个知识点只保留一个问题。 由 [GOWxx](https://github.com/GOWxx) 于 2023.3.1 操作并整理。

Q:你好，ChatGPT！我希望你扮演一位 高级前端工程师/前端专家 岗位面试的面试者(interviewee)，积极回答面试官的问题，努力展现你的能力与经验，争取通过面试，取得 offer. 接下来我会问你一些  问题，希望你尽力作答。

你好，我将尽我所能回答你的问题，展示我的能力和经验。让我们开始吧！

Q:说一下 http 和 https

HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）都是用于在网络上传输数据的协议，其中HTTPS是在HTTP的基础上加入了安全性保障的协议。

HTTP是一种无状态的协议，即客户端与服务器之间的通信不会记住之前的通信状态，每次请求都是独立的。HTTP协议默认使用80端口进行通信，数据传输是明文的，容易被中间人窃听和篡改。

为了保证数据的安全性，HTTPS协议在HTTP协议上加入了SSL/TLS协议来进行数据加密，从而使数据在传输过程中不会被窃听、篡改或者伪造。HTTPS协议默认使用443端口进行通信，数据传输过程中加入了数字证书、对称密钥和非对称加密等机制来保证数据的安全性。

因此，对于对数据安全性要求高的网站，建议使用HTTPS协议来保障数据的安全性。

Q:http 和 https 的区别？

HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）的主要区别在于数据传输的安全性和加密方式。

HTTP协议是一种明文传输的协议，数据传输过程中数据是以明文形式在网络上传输的，容易被中间人窃听和篡改，因此对于敏感数据的传输不够安全。

而HTTPS协议在HTTP协议的基础上加入了SSL/TLS协议来进行数据加密，从而使数据在传输过程中不会被窃听、篡改或者伪造。HTTPS协议使用了非对称加密和对称加密的组合，利用数字证书验证服务器的身份，并且在客户端和服务器之间建立一条安全通道，通过这条通道进行加密通信，从而保证数据的安全性。

另外，HTTP协议默认使用80端口进行通信，而HTTPS协议默认使用443端口进行通信。

综上所述，HTTPS协议相较于HTTP协议更加安全可靠，特别是对于需要保证数据传输安全的场景，建议使用HTTPS协议。但是HTTPS协议相对于HTTP协议也会增加一些开销，如加密和解密的过程会消耗更多的服务器资源，所以在对性能要求比较高的场景下，可能需要进行一些优化。

Q:ttps 协议的工作原理

HTTPS（HyperText Transfer Protocol Secure）协议的工作原理可以简单概括为以下几个步骤：

1.  SSL/TLS握手过程：当客户端发起HTTPS请求时，首先会与服务器进行SSL/TLS握手，建立一条安全的通信渠道。在这个过程中，服务器会将自己的公钥发送给客户端，客户端使用该公钥对数据进行加密，发送给服务器。服务器使用自己的私钥对数据进行解密，这样双方就能够建立安全的通信连接了。
    
2.  数字证书认证：在SSL/TLS握手过程中，服务器会向客户端发送一个数字证书，证书中包含了服务器的公钥和其他一些信息。客户端会对这个证书进行验证，包括验证证书是否由受信任的证书颁发机构签发、证书是否过期等信息。如果验证通过，客户端就会使用证书中包含的公钥进行加密通信。
    
3.  数据加密传输：在握手过程完成后，客户端和服务器之间的通信就可以进行数据加密传输了。客户端和服务器使用对称密钥来加密和解密数据，这个对称密钥是在SSL/TLS握手过程中协商生成的。由于对称加密的速度比非对称加密快，因此大部分数据都会使用对称加密方式进行加密和解密。
    
4.  数据完整性保护：在数据传输过程中，为了保证数据的完整性，服务器会对数据进行数字签名，客户端接收到数据后会验证数字签名，确保数据未被篡改。
    

总之，HTTPS协议的工作原理主要是通过 SSL/TLS 握手过程建立安全通道，使用数字证书进行身份认证，对数据进行加密和解密，以及对数据的完整性进行保护，从而保障数据的安全性。

Q:http 和 https 优劣对比

HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）协议的优劣对比如下：

HTTP优劣：

优势：

1.  简单易用，适合传输非敏感信息；
2.  传输速度较快，因为不需要进行加密、认证等操作。

劣势：

1.  数据传输不安全，容易被窃听和篡改；
2.  不支持身份认证和数据加密，无法保障数据的安全性；
3.  无法保证数据的完整性，数据在传输过程中容易被篡改。

HTTPS优劣：

优势：

1.  数据传输安全可靠，能够保障数据的机密性、完整性和可信度；
2.  支持数字证书验证，能够防止中间人攻击；
3.  提供身份认证和数据加密功能，能够保证数据的安全性；
4.  可以提高网站的信誉度，增强用户信任感。

劣势：

1.  需要消耗更多的服务器资源，加密和解密的过程会影响性能；
2.  需要购买数字证书，成本相对较高；
3.  HTTPS协议传输数据较慢，因为需要进行加密和认证等操作。

综上所述，HTTP协议优点在于简单易用，传输速度快，但不安全；HTTPS协议优点在于数据传输安全可靠，支持数字证书认证，但需要消耗更多的服务器资源和成本较高。因此，在需要保障数据安全性的场景下，建议使用HTTPS协议。

Q:tcp 三次握手

TCP（Transmission Control Protocol）三次握手是在建立TCP连接时进行的一种通信方式，目的是为了确保客户端和服务器之间的通信能够正常进行。

TCP三次握手的过程如下：

1.  第一次握手（SYN）：客户端向服务器发送SYN报文，请求建立连接。此时客户端处于SYN_SEND状态。
    
2.  第二次握手（SYN+ACK）：服务器接收到SYN报文后，向客户端回送SYN+ACK报文，表示确认收到了客户端的请求，同时请求建立连接。此时服务器处于SYN_RECEIVED状态。
    
3.  第三次握手（ACK）：客户端接收到服务器的SYN+ACK报文后，向服务器发送ACK报文，表示已经收到了服务器的确认信息，并向服务器发出连接请求。此时客户端处于ESTABLISHED状态，服务器也处于ESTABLISHED状态，TCP连接建立完成。
    

通过三次握手过程，客户端和服务器之间确认了双方的收、发能力以及传输信息的可靠性，从而确保了连接的可靠性。如果任何一方未能收到另一方发送的确认信息，就会重新发送报文，直到确认信息被收到为止。

需要注意的是，TCP三次握手过程中，只有前两个报文段需要携带SYN标志位，而最后一个ACK报文段不需要携带SYN标志位。此外，TCP还有四次挥手的过程用于关闭连接。

Q:TCP 和 UDP 的区别

TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常见的传输层协议，它们在传输数据时具有以下区别：

1.  连接：TCP是一种面向连接的协议，而UDP是一种无连接的协议。TCP在通信前需要进行三次握手来建立连接，而UDP则不需要建立连接，直接发送数据报。
    
2.  可靠性：TCP协议提供数据传输的可靠性，确保数据能够准确、完整地传输到接收方。TCP通过序列号、确认应答、重传等机制来保证数据的可靠性。而UDP则不保证数据的可靠性，因为它没有重传机制，也不保证数据的传输顺序，因此传输速度比TCP快，但不够可靠。
    
3.  段：TCP和UDP的数据传输单位不同。TCP将数据分割为多个TCP数据段进行传输，每个TCP数据段都包含一个序列号和确认应答信息，以确保数据的可靠传输。而UDP不对数据进行分割，直接将数据报发送出去，不需要确认应答，因此速度快但可靠性差。
    
4.  拥塞控制：TCP拥有拥塞控制机制，能够根据网络状况自适应调整传输速度，防止网络拥塞。UDP没有拥塞控制机制，一旦网络拥塞，可能导致数据丢失和延迟。
    

综上所述，TCP协议提供了面向连接、可靠、有序的数据传输服务，而UDP协议则提供了无连接、不可靠、快速的数据传输服务。因此，在对数据可靠性要求高的应用场景下，如文件传输、网页浏览等，建议使用TCP协议；而对于实时性要求高、数据丢失不会造成严重后果的应用场景下，如视频直播、游戏等，建议使用UDP协议。

Q: WebSocket 的实现和应用

WebSocket是一种全双工、双向通信的协议，允许服务器和客户端之间建立持久连接，从而实现实时的双向通信。WebSocket使用HTTP协议进行握手，建立连接后，使用特定的协议进行数据传输，避免了HTTP协议每次通信都需要重新建立连接的缺点。

WebSocket的实现和应用主要有以下几个方面：

1.  实现方式：WebSocket可以使用各种编程语言和技术实现，如Java、Python、Node.js等。对于前端开发人员而言，可以使用JavaScript编写WebSocket客户端。
    
2.  建立连接：WebSocket在建立连接时，需要进行一次HTTP握手，之后服务器和客户端之间就建立了持久连接，可以随时进行双向通信。
    
3.  数据传输：WebSocket支持二进制和文本数据的传输。在传输数据时，WebSocket会将数据分割为多个数据帧进行传输，每个数据帧都包含一个数据头和实际数据，数据头用于描述数据的类型和长度等信息。
    
4.  应用场景：WebSocket的应用场景非常广泛，如在线游戏、实时消息推送、股票交易、在线教育等。通过WebSocket可以实现实时的双向通信，避免了HTTP协议每次通信都需要重新建立连接的缺点，提高了应用程序的性能和用户体验。
    

总之，WebSocket是一种实现双向通信的协议，可以在多种编程语言和技术中使用，并且适用于多种应用场景，是构建实时、高性能应用的有效工具。

Q:WebSocket 是什么样的协议，具体有什么优点

WebSocket是一种全双工、双向通信的协议，通过一次HTTP握手，建立持久连接，可以在客户端和服务器之间进行实时的双向通信，避免了HTTP协议每次通信都需要重新建立连接的缺点。

WebSocket协议具有以下优点：

1.  实时性：WebSocket可以在客户端和服务器之间建立持久连接，实现实时的双向通信。因此，对于需要实现实时更新数据的应用场景，如在线游戏、聊天应用等，使用WebSocket可以提高数据传输的速度和效率。
    
2.  高性能：WebSocket使用全双工通信方式，可以在客户端和服务器之间同时进行数据传输，而不需要像HTTP协议那样每次都重新建立连接，从而提高了应用程序的性能和响应速度。
    
3.  跨域支持：WebSocket协议可以跨域使用，因为WebSocket握手时使用HTTP协议进行通信，而HTTP协议支持跨域访问。
    
4.  可靠性：WebSocket协议使用TCP协议进行通信，具有可靠性和完整性保障，可以保证数据的正确传输和接收。
    
5.  开发简单：WebSocket协议的使用非常简单，前端可以使用JavaScript编写WebSocket客户端，后端可以使用各种编程语言和框架实现WebSocket服务器，开发人员可以很容易地将WebSocket集成到自己的应用程序中。
    

总之，WebSocket是一种全双工、双向通信的协议，具有实时性、高性能、可靠性、跨域支持和开发简单等优点，适用于多种应用场景，是构建实时、高性能应用的有效工具。

Q:WebSocket 与 HTTP 的关系，握手阶段是否相同

WebSocket与HTTP协议是有联系的，WebSocket协议的握手阶段与HTTP协议非常相似，但WebSocket是一种独立的协议，不同于HTTP协议。

具体来说，WebSocket协议的握手阶段与HTTP协议的握手阶段非常相似，都使用HTTP请求和响应头进行通信。WebSocket握手时，客户端向服务器发送一次HTTP请求，请求中包含Upgrade头和Connection头，告诉服务器需要升级协议为WebSocket，并保持连接。服务器接收到请求后，返回HTTP响应，响应中包含Upgrade头和Connection头，告诉客户端协议已经升级为WebSocket，连接已建立。建立连接后，客户端和服务器就可以使用WebSocket协议进行双向通信了。

需要注意的是，WebSocket协议的握手阶段与HTTP协议的握手阶段不完全相同，WebSocket协议使用Upgrade头和Connection头进行通信，而HTTP协议通常使用GET、POST等请求方法。此外，WebSocket握手时需要携带Sec-WebSocket-Key和Sec-WebSocket-Accept等头信息，用于进行安全认证和加密操作，而HTTP协议则没有这些头信息。

总之，WebSocket协议的握手阶段与HTTP协议的握手阶段相似，但WebSocket是一种独立的协议，不同于HTTP协议。两者在具体的头信息和协议规范上也有所不同。

Q:HTTP 请求的方式，HEAD 方式

HTTP协议定义了多种请求方式，常见的请求方式有GET、POST、PUT、DELETE等。其中，HEAD请求方式是一种特殊的请求方式，用于获取与GET请求相同的响应头信息，但不返回响应体。

HEAD请求方式与GET请求方式非常相似，它们的请求头部分完全相同，只是在请求方法上有所不同。HEAD请求方式会向服务器发送一个请求，请求中包含请求头信息，但不包含请求体信息。服务器在收到请求后，会根据请求头信息生成响应头信息，并返回给客户端，但不返回响应体信息。这种方式可以在不下载完整响应内容的情况下，获取到与GET请求相同的响应头信息，从而可以提高请求的效率。

HEAD请求方式常用于检测服务器是否可用、获取资源的元数据信息等场景。例如，在下载大文件时，可以使用HEAD请求方式检查文件是否存在、文件大小和更新时间等信息，以便判断是否需要重新下载文件。在使用HTTP缓存时，也可以使用HEAD请求方式检查缓存中的响应是否过期，以决定是否需要向服务器发送新的请求。

需要注意的是，虽然HEAD请求方式不返回响应体信息，但服务器仍然需要根据请求进行一定的处理，因此，如果服务器对GET请求进行了安全性检查，同样也需要对HEAD请求进行安全性检查，以保证请求的安全性。

总之，HTTP协议中的HEAD请求方式是一种特殊的请求方式，用于获取与GET请求相同的响应头信息，但不返回响应体信息。它可以提高请求的效率，常用于检测服务器是否可用、获取资源的元数据信息等场景。

Q:HTTP 请求的方式，options 方式

HTTP协议定义了多种请求方式，其中之一是OPTIONS请求方式，用于获取服务器支持的HTTP请求方法以及服务器所支持的HTTP头信息等元数据。

OPTIONS请求方式会向服务器发送一个请求，请求中包含一个星号或具体的URI，用于指定需要查询的资源。服务器在收到请求后，会返回一个响应，响应中包含了服务器所支持的HTTP请求方法以及服务器所支持的HTTP头信息等元数据。通过这些元数据，客户端可以了解到服务器所支持的请求方式和请求头信息，以便进行后续的请求操作。

OPTIONS请求方式通常用于检查服务器是否支持某种HTTP请求方式或请求头信息，也可以用于跨域资源共享（CORS）的预检请求。在使用CORS时，浏览器会先发送一次OPTIONS请求，查询服务器是否支持跨域请求，如果服务器支持，就可以进行后续的跨域请求操作。

需要注意的是，OPTIONS请求方式不同于其他请求方式，它不会返回任何实际的响应内容，而是返回元数据信息。因此，客户端需要对响应进行相应的处理，以便正确地解析元数据信息。

总之，HTTP协议中的OPTIONS请求方式用于获取服务器支持的HTTP请求方法以及服务器所支持的HTTP头信息等元数据，常用于检查服务器是否支持某种HTTP请求方式或请求头信息，以及CORS的预检请求。

Q:一个图片 url 访问后直接下载怎样实现？

要让用户在访问图片URL时直接下载图片，可以使用HTTP协议中的Content-Disposition头信息。通过设置Content-Disposition头信息的值为attachment，就可以告诉浏览器下载该资源而不是在浏览器中打开。

具体实现步骤如下：

1.  在服务器端，设置HTTP响应头Content-Disposition的值为attachment，并设置文件名。
    
2.  在客户端，通过浏览器或其他HTTP客户端向服务器请求该图片URL。
    
3.  当服务器收到请求后，会将Content-Disposition头信息发送给客户端，客户端根据Content-Disposition头信息的值，将该图片下载到本地。
    

例如，可以在服务器端使用以下代码设置Content-Disposition头信息：

```
response.setHeader("Content-Disposition", "attachment; file);

```

其中，response为HTTP响应对象，filename为下载文件的文件名。

需要注意的是，Content-Disposition头信息只对通过HTTP协议传输的文件有效，如果使用FTP等其他协议传输文件，则需要使用其他方法进行文件下载。此外，在某些浏览器中，Content-Disposition头信息可能会被忽略，因此，还需要考虑浏览器的兼容性问题。

总之，通过在HTTP响应头中设置Content-Disposition头信息为attachment，可以让用户在访问图片URL时直接下载图片。需要注意的是，还需要考虑浏览器的兼容性问题。

Q:说一下 web Quality（无障碍）

Web Quality（无障碍）是指Web应用程序和Web内容在不同设备和用户之间都可以实现无障碍访问和使用。Web Quality的目标是使Web应用程序和内容对所有用户都可访问，包括身体上或智力上受限制的用户，老年人和那些使用辅助技术访问Web的用户。

Web Quality的实现需要考虑以下几个方面：

1.  Web内容的可访问性：Web应用程序和内容必须可访问，这意味着所有用户都能够浏览和使用网站，无论他们的身体或智力状态如何。这可以通过优化网站结构、布局、颜色、字体大小等方式实现。
    
2.  Web内容的可读性：Web内容必须易于阅读和理解，以便所有用户都能够使用。这可以通过使用简单的语言和排版、使用清晰的字体和颜色、为图像和媒体添加说明等方式实现。
    
3.  辅助技术支持：Web应用程序和内容必须支持辅助技术，例如屏幕阅读器、语音识别等，以便身体上或智力上受限制的用户可以访问和使用网站。
    
4.  可操作性：Web应用程序和内容必须易于操作，以便所有用户都能够使用。这可以通过优化网站的导航、表单、按钮、链接等方式实现。
    
5.  可维护性：Web应用程序和内容必须易于维护和更新，以便保持无障碍访问性。这可以通过使用标准化的Web技术、遵循最佳实践和规范等方式实现。
    

Web Quality的实现不仅可以让所有用户都能够访问和使用网站，还可以提高网站的可用性和搜索引擎排名，从而增加流量和用户满意度。

总之，Web Quality是指Web应用程序和Web内容在不同设备和用户之间都可以实现无障碍访问和使用。实现Web Quality需要考虑Web内容的可访问性、可读性、辅助技术支持、可操作性和可维护性等方面。

Q:有什么标签或者属性有助于 web Quality（无障碍）呢？

为了实现Web Quality（无障碍），需要在Web应用程序和Web内容中使用一些标签和属性，以便提高网站的可访问性和可用性。以下是一些常用的标签和属性：

1.  alt属性：用于为图像、媒体等元素提供文本描述，以便视力障碍用户可以使用屏幕阅读器等辅助技术访问。
    
2.  title属性：用于为链接、图像等元素提供更详细的文本描述，以便所有用户都能够理解链接的含义。
    
3.  aria属性：用于为元素提供语义信息，以便视力障碍用户可以使用屏幕阅读器等辅助技术访问。例如，aria-label属性可以为按钮、表单、链接等元素提供描述，以便视力障碍用户可以了解其作用。
    
4.  heading标签：用于为网页提供标题和子标题，以便所有用户都能够理解网页的结构。
    
5.  list标签：用于创建有序或无序列表，以便所有用户都能够理解网页内容的结构。
    
6.  table标签：用于创建表格，以便所有用户都能够理解表格中的数据。
    
7.  form标签：用于创建表单，以便所有用户都能够填写和提交表单。
    
8.  label标签：用于与表单元素相关联，以便所有用户都能够理解表单的内容。
    
9.  button标签：用于创建按钮，以便所有用户都能够进行操作。
    

总之，以上标签和属性的使用可以帮助实现Web Quality（无障碍），提高Web应用程序和Web内容的可访问性和可用性，从而让所有用户都能够访问和使用网站。

Q:谈一谈你了解的很实用的 BOM 属性对象方法？

BOM（Browser Object Model）是浏览器对象模型，它提供了一些属性、对象和方法，可以用于操作浏览器窗口和文档等。以下是一些我认为很实用的BOM属性、对象和方法：

1.  window对象：代表整个浏览器窗口，提供了很多实用的属性和方法，如window.innerWidth、window.innerHeight、window.open()等。
    
2.  navigator对象：提供了有关浏览器的信息，如浏览器的名称、版本、平台等，可以通过navigator.userAgent属性获取完整的用户代理字符串。
    
3.  screen对象：提供了有关用户屏幕的信息，如屏幕的宽度、高度、色深等，可以通过screen.width、screen.height、screen.colorDepth等属性获取相关信息。
    
4.  location对象：提供了有关当前文档的信息，如文档的URL、主机名、协议等，可以通过location.href、location.hostname、location.protocol等属性获取相关信息。
    
5.  history对象：提供了有关用户访问历史的信息，如当前文档在历史记录中的位置、历史记录的数量等，可以通过history.length、history.back()、history.forward()等属性和方法获取相关信息。
    
6.  setTimeout()和setInterval()方法：分别用于在指定的时间间隔之后执行一次或多次某个函数，可以用于实现动画、定时刷新等功能。
    
7.  document.cookie属性：用于读取和设置浏览器的Cookie，可以用于实现用户登录状态、记住密码等功能。
    

总之，BOM提供了很多实用的属性、对象和方法，可以用于操作浏览器窗口和文档等，实现一些常用的功能和交互效果。需要注意的是，不同的浏览器对BOM的实现可能有所不同，因此，应该避免依赖特定的BOM实现，尽可能使用标准的BOM属性和方法。

Q:详细介绍一下 location 对象

location对象是BOM中的一个常用对象，它提供了有关当前文档的信息，如文档的URL、主机名、协议等。location对象有许多属性和方法，可以用于实现一些常用的功能和交互效果。

以下是一些常用的location对象属性：

1.  href：获取或设置当前文档的完整URL地址，可以用于页面跳转和重定向。
    
2.  protocol：获取或设置当前文档的协议，如http、https等。
    
3.  hostname：获取或设置当前文档的主机名，如www.example.com。
    
4.  pathname：获取或设置当前文档的路径，如/index.html。
    
5.  search：获取或设置当前文档的查询字符串，如?id=1&name=test。
    
6.  hash：获取或设置当前文档的片段标识符，如#section1。
    
7.  origin：获取当前文档的源，包括协议、主机名和端口号，如[http://www.example.com:8080。](http://www.example.com:8080%E3%80%82)
    

以下是一些常用的location对象方法：

1.  assign()：用于加载一个新的文档，并在浏览器的历史记录中生成一条记录，可以用于页面跳转和重定向。
    
2.  replace()：用于加载一个新的文档，但不在浏览器的历史记录中生成一条记录，可以用于页面跳转和重定向。
    
3.  reload()：重新加载当前文档，可以用于实现页面的动态更新和定时刷新等功能。
    

location对象还可以通过其属性和方法实现一些其他的功能，如页面跳转、URL解析、动态更新等。需要注意的是，location对象中的URL属性和方法可以用于实现页面跳转和重定向等功能，但在实际开发中应该谨慎使用，避免对用户造成不必要的干扰。

总之，location对象是BOM中的一个常用对象，提供了有关当前文档的信息，如文档的URL、主机名、协议等。通过其属性和方法可以实现一些常用的功能和交互效果。

Q:详细介绍一下history 对象

history对象是BOM中的一个常用对象，它提供了有关用户访问历史的信息，如当前文档在历史记录中的位置、历史记录的数量等。history对象有一些属性和方法，可以用于实现一些常用的功能和交互效果。

以下是一些常用的history对象属性：

1.  length：获取当前浏览器历史记录中的条目数量。
    
2.  state：获取当前历史记录的状态，可以通过pushState()、replaceState()等方法修改该状态。
    

以下是一些常用的history对象方法：

1.  back()：返回历史记录中的上一个条目。
    
2.  forward()：前往历史记录中的下一个条目。
    
3.  go()：跳转到历史记录中的指定条目，可以通过正整数和负整数分别表示前进和后退。
    
4.  pushState()：向历史记录中添加一个新条目，并修改当前文档的URL。
    
5.  replaceState()：替换历史记录中的当前条目，并修改当前文档的URL。
    

history对象可以用于实现一些常用的功能和交互效果，如前进后退按钮、AJAX页面刷新、URL路由等。需要注意的是，不同的浏览器对history对象的实现可能有所不同，因此，在实际开发中应该避免依赖特定的history对象实现，尽可能使用标准的属性和方法。

总之，history对象是BOM中的一个常用对象，提供了有关用户访问历史的信息。通过其属性和方法可以实现一些常用的功能和交互效果，如前进后退按钮、AJAX页面刷新、URL路由等。在实际开发中应该注意浏览器的兼容性问题，避免依赖特定的history对象实现。

Q:详细介绍一下 Navigator 对象

Navigator对象是BOM中的一个常用对象，它提供了有关浏览器的信息，如浏览器的名称、版本、平台等。Navigator对象有许多属性和方法，可以用于实现一些常用的功能和交互效果。

以下是一些常用的Navigator对象属性：

1.  userAgent：获取浏览器的用户代理字符串，包括浏览器名称、版本、操作系统等信息。
    
2.  appCodeName：获取浏览器的代码名称，如Mozilla。
    
3.  appName：获取浏览器的名称，如Netscape。
    
4.  appVersion：获取浏览器的版本号，如5.0 (Windows NT 10.0; Win64; x64)。
    
5.  platform：获取浏览器所在的平台，如Windows、Mac OS等。
    

以下是一些常用的Navigator对象方法：

1.  registerProtocolHandler()：用于注册Web应用程序协议，以便将指定的协议关联到当前Web应用程序。
    
2.  unregisterProtocolHandler()：用于取消注册已经注册的Web应用程序协议。
    
3.  vibrate()：用于触发设备的振动效果。
    
4.  javaEnabled()：用于检测浏览器是否支持Java。
    
5.  getBattery()：用于获取设备电池的状态信息。
    

Navigator对象可以用于获取浏览器的信息，判断浏览器的功能支持情况等。需要注意的是，Navigator对象中的一些属性和方法可能已经过时或不被所有浏览器支持，因此在实际开发中应该根据具体情况进行使用和兼容。

总之，Navigator对象是BOM中的一个常用对象，提供了有关浏览器的信息，如浏览器的名称、版本、平台等。通过其属性和方法可以实现一些常用的功能和交互效果，如Web应用程序协议、设备振动效果、Java支持情况等。在实际开发中应该注意浏览器的兼容性问题，避免依赖特定的Navigator对象实现。

Q:说一下 HTML5 drag api

HTML5 Drag and Drop API是HTML5的一个新特性，提供了一组JavaScript API，可以使用户通过拖放的方式移动或复制元素。HTML5 Drag and Drop API可以应用于Web应用程序和桌面应用程序，提高了用户的交互体验和操作效率。

以下是HTML5 Drag and Drop API的主要特性和用法：

1.  draggable属性：用于标记一个元素是否可拖拽，可选值为true和false。
    
2.  dragstart事件：在元素被拖动开始时触发，用于设置拖动的数据类型和数据。
    
3.  dragenter事件：在拖动的元素进入可放置的区域时触发，用于设置拖动的效果。
    
4.  dragover事件：在拖动的元素在可放置的区域上移动时触发，用于设置拖动的效果。
    
5.  dragleave事件：在拖动的元素离开可放置的区域时触发，用于设置拖动的效果。
    
6.  drop事件：在拖动的元素在可放置的区域上松开鼠标时触发，用于处理拖放操作。
    
7.  dragend事件：在拖动的元素完成拖动操作后触发，用于清理拖动的数据和设置拖动的效果。
    

HTML5 Drag and Drop API可以用于实现一些常用的拖放操作，如图像上传、文件拖拽、元素排序等。需要注意的是，不同的浏览器对HTML5 Drag and Drop API的实现可能有所不同，因此，在实际开发中应该避免依赖特定的API实现，尽可能使用标准的API。

总之，HTML5 Drag and Drop API是HTML5的一个新特性，提供了一组JavaScript API，可以使用户通过拖放的方式移动或复制元素。通过其属性和事件可以实现一些常用的拖放操作，提高了用户的交互体验和操作效率。

Q:说一下 http2.0

HTTP/2是HTTP协议的新版本，它在HTTP/1.1的基础上进行了改进和优化，提供了更高效、更安全的Web传输协议。HTTP/2的主要特点包括：

1.  二进制分帧：HTTP/2使用二进制格式传输数据，将请求和响应数据分割成更小的数据包，可以更好地利用带宽，提高传输效率。
    
2.  多路复用：HTTP/2使用单一的TCP连接，可以同时处理多个请求和响应，避免了HTTP/1.1中的队头阻塞问题，提高了并发性能。
    
3.  流量控制：HTTP/2引入了流量控制机制，可以根据带宽和网络状况动态调整请求和响应的传输速度，防止数据传输过程中出现拥塞。
    
4.  服务器推送：HTTP/2支持服务器主动向客户端推送数据，可以减少客户端的请求次数，提高性能和用户体验。
    
5.  支持Header压缩：HTTP/2使用HPACK算法对Header进行压缩，可以减少Header的大小，提高传输效率。
    

HTTP/2在性能、安全性、用户体验等方面都有很大的优化，可以帮助Web应用程序提高性能和可靠性。但是，需要注意的是，HTTP/2的使用需要在Web服务器和客户端上进行相应的配置和优化，同时，HTTP/2也有一些限制和不足之处，如需要HTTPS协议的支持、可能出现头部阻塞问题等，需要开发人员根据实际情况进行应用和优化。

总之，HTTP/2是HTTP协议的新版本，提供了更高效、更安全的Web传输协议。通过其特点和优势，可以帮助Web应用程序提高性能和可靠性。在实际应用中，需要根据实际情况进行相应的配置和优化，以达到最佳的性能和用户体验。

Q:谈一谈 HTTP 状态码，常见的有哪些，其含义是什么

HTTP状态码是HTTP协议返回给客户端的一个标识，用于告知客户端HTTP请求的处理结果。HTTP状态码由三个数字组成，第一个数字表示响应的类型，如1xx表示信息提示，2xx表示成功，3xx表示重定向，4xx表示客户端错误，5xx表示服务器错误。

以下是常见的HTTP状态码及其含义：

1xx（信息提示）

*   100 Continue：表示客户端可以继续发送请求。
    
*   101 Switching Protocols：表示服务器正在切换协议。
    

2xx（成功）

*   200 OK：表示请求成功。
    
*   201 Created：表示请求已创建新的资源。
    
*   202 Accepted：表示服务器已接受请求，但尚未处理完成。
    
*   204 No Content：表示请求成功，但没有返回任何内容。
    

3xx（重定向）

*   301 Moved Permanently：表示请求的资源已永久移动到新位置。
    
*   302 Found：表示请求的资源已临时移动到新位置。
    
*   304 Not Modified：表示请求的资源未被修改，可以从缓存中获取。
    

4xx（客户端错误）

*   400 Bad Request：表示请求无效或不完整。
    
*   401 Unauthorized：表示需要认证才能访问请求的资源。
    
*   403 Forbidden：表示请求被服务器拒绝。
    
*   404 Not Found：表示请求的资源不存在。
    

5xx（服务器错误）

*   500 Internal Server Error：表示服务器遇到错误，无法完成请求。
    
*   502 Bad Gateway：表示服务器作为网关或代理时，从上游服务器接收到的响应无效。
    
*   503 Service Unavailable：表示服务器暂时无法处理请求。
    
*   504 Gateway Timeout：表示服务器作为网关或代理时，等待上游服务器响应超时。
    

HTTP状态码用于告知客户端请求的处理结果，开发人员可以根据状态码进行错误处理和重定向等操作。在实际开发中，需要熟悉常见的HTTP状态码及其含义，以便在出现问题时进行快速定位和解决。同时，也需要注意HTTP状态码的安全性问题，如避免将服务器内部错误信息暴露给客户端等。

Q:fetch 发送 2 次请求的原因

Fetch API 是一种用于发送 HTTP 请求的新的 Web API，与传统的 XHR（XMLHttpRequest）API 相比，Fetch API 更加强大、简洁、易用。Fetch API 使用 Promise 来处理异步请求和响应，可以使代码更加清晰和简洁。

在实际使用 Fetch API 进行 HTTP 请求时，有时候可能会发现一个请求被发送了多次，这种情况一般是由于多个代码块或组件对同一个 Fetch 请求对象进行了调用或引用，导致发送了多个请求。

例如，当一个代码块或组件通过 Fetch API 创建一个 HTTP 请求对象并发送请求时，如果另一个代码块或组件也引用了该请求对象并调用了 fetch 方法，就会导致同一个请求被发送了多次。

为避免这种情况发生，可以在编写代码时尽量避免多个代码块或组件对同一个请求对象进行引用和调用，或者通过一些手段来确保每个请求只会被发送一次，例如使用锁机制或通过状态管理来控制请求的发送。

总之，Fetch API 是一种用于发送 HTTP 请求的新的 Web API，使用 Promise 来处理异步请求和响应，可以使代码更加清晰和简洁。在使用 Fetch API 进行 HTTP 请求时，需要注意避免同一个请求被多次发送的情况，可以通过避免多个代码块或组件对同一个请求对象进行引用和调用，或通过一些手段来确保每个请求只会被发送一次。

Q:用 fetch API 的 post 请求时，是否会发送 Options 请求

在使用 Fetch API 发送 POST 请求时，会根据请求头（Request Headers）中的 Content-Type 来判断请求体（Request Body）的类型，从而决定是否需要发送 Options 请求。

当请求体是纯文本（如 JSON、XML、Text 等）时，Fetch API 会直接发送 POST 请求，而不会先发送 Options 请求。但当请求体是 FormData、URLSearchParams 或者其他类型的表单数据时，浏览器会自动将请求头中的 Content-Type 设置为 multipart/form-data 或 application/x-www-form-urlencoded，此时就会发送 Options 请求。

这是因为在发送跨域请求时，浏览器会先发送 Options 请求，以检查服务器是否支持跨域请求，并且获取服务器支持的请求头和请求方法等信息。如果服务器支持跨域请求，则浏览器才会发送 POST 请求，否则会出现跨域请求失败的情况。

需要注意的是，如果在服务器端进行了 CORS（跨域资源共享）配置，则可以避免发送 Options 请求。在 CORS 配置中，可以设置 Access-Control-Allow-Origin 头来允许跨域访问，同时也可以设置其他的 CORS 头来控制跨域请求的行为和权限。

总之，当使用 Fetch API 发送 POST 请求时，是否会发送 Options 请求取决于请求头中的 Content-Type，以及服务器是否支持跨域请求。如果需要避免发送 Options 请求，可以在服务器端进行 CORS 配置，或者通过其他方式来控制请求头的类型。

Q:Cookie、sessionStorage、localStorage 的区别

Cookie、sessionStorage、localStorage 都是用于在浏览器端存储数据的技术，但它们在存储方式、数据有效期、数据安全性等方面有一些区别。

1.  Cookie：Cookie 是一种存储在浏览器中的小型文本文件，它可以在浏览器和服务器之间传递数据，常用于实现用户身份验证、记住密码、购物车等功能。Cookie 可以设置过期时间，可以在浏览器关闭后依然保留，但数据容量较小，一般不超过 4KB，且存在安全问题（如 CSRF、XSS 攻击等）。
    
2.  sessionStorage：sessionStorage 是一种在浏览器中存储数据的技术，它可以存储当前会话中的数据，一旦浏览器关闭，存储的数据就会被清除。sessionStorage 存储的数据只能在同一窗口或标签页中共享，不能在多个窗口或标签页之间共享，数据容量较小，一般不超过 5MB，且相对较安全，不容易受到攻击。
    
3.  localStorage：localStorage 也是一种在浏览器中存储数据的技术，它与 sessionStorage 相似，但数据的有效期是永久性的，即使浏览器关闭也不会被清除。localStorage 存储的数据可以在同一域名下的所有窗口和标签页之间共享，数据容量较大，一般可以存储 5-10MB 的数据，但也存在安全问题，如 XSS 攻击等。
    

总之，Cookie、sessionStorage、localStorage 都是用于在浏览器端存储数据的技术，它们各有优缺点，可以根据具体的应用场景进行选择。Cookie 可以在浏览器和服务器之间传递数据，但存在安全问题；sessionStorage 可以存储当前会话中的数据，但数据容量较小；localStorage 可以永久性存储数据，但也存在安全问题。开发人员在使用这些技术时，需要注意数据的安全性和有效期，并根据具体的需求来选择合适的存储方式。

Q:Cookie、sessionStorage、localStorage 常见的应用场景有哪些

Cookie、sessionStorage、localStorage 都是用于在浏览器端存储数据的技术，它们各有优缺点，可以根据具体的应用场景进行选择。

1.  Cookie：Cookie 可以在浏览器和服务器之间传递数据，常用于实现用户身份验证、记住密码、购物车等功能。例如，在购物网站中，可以使用 Cookie 存储用户的购物车信息和登录状态，以便用户下次访问时能够快速找到之前的购物车和登录状态。
    
2.  sessionStorage：sessionStorage 可以存储当前会话中的数据，一旦浏览器关闭，存储的数据就会被清除。常用于临时存储一些数据，例如用户的表单数据、临时生成的数据等。例如，在一个表单中，可以使用 sessionStorage 存储用户输入的数据，以便用户在页面跳转或刷新时可以保留之前的输入数据。
    
3.  localStorage：localStorage 可以永久性存储数据，常用于存储一些重要的数据，例如用户的个人信息、网站的配置信息等。例如，在一个网站中，可以使用 localStorage 存储用户的个人设置和配置信息，以便用户下次访问时能够快速找到之前的设置和配置。
    

总之，Cookie、sessionStorage、localStorage 都是用于在浏览器端存储数据的技术，它们各有优缺点，可以根据具体的应用场景进行选择。开发人员在使用这些技术时，需要注意数据的安全性和有效期，并根据具体的需求来选择合适的存储方式。

Q:说一下 web worker

Web Worker 是 HTML5 标准中的一项新技术，它可以让 JavaScript 运行在主线程之外的一个独立线程中，从而可以避免一些耗时的操作对主线程的影响，提高页面的性能和响应速度。

Web Worker 可以通过 Worker() 构造函数创建一个新的工作线程，这个线程可以独立于主线程运行，并通过 postMessage() 方法进行通信。主线程可以将消息发送到工作线程中，并在工作线程中进行一些耗时的操作，最后将处理结果通过 postMessage() 方法发送回主线程，从而实现异步处理和多线程操作。

Web Worker 的主要特点包括：

1.  多线程处理：Web Worker 可以让 JavaScript 运行在独立的线程中，避免一些耗时的操作对主线程的影响，提高页面的性能和响应速度。
    
2.  消息传递通信：Web Worker 可以通过 postMessage() 方法进行消息传递通信，主线程可以将消息发送到工作线程中，工作线程可以进行一些耗时的操作，并将处理结果发送回主线程。
    
3.  安全性：Web Worker 运行在沙箱环境中，不会对主线程和页面的状态造成影响，从而提高页面的安全性。
    

Web Worker 在实际开发中主要用于一些耗时的计算、数据处理、图像处理等操作，例如在一个音乐播放器中，可以使用 Web Worker 进行音频数据的解码和处理，从而提高页面的性能和响应速度。需要注意的是，由于 Web Worker 运行在独立的线程中，因此需要注意线程之间的通信和同步问题，避免出现竞争条件和死锁等问题。

Q:如何创建 web worker

在 Web Worker 中，主线程和工作线程之间是通过消息传递进行通信的，主线程可以通过 postMessage() 方法将消息发送给工作线程，工作线程也可以通过 postMessage() 方法将消息发送给主线程，从而实现异步处理和多线程操作。

Web Worker 可以通过 Worker() 构造函数创建一个新的工作线程，例如：

```
// 创建一个新的工作线程
const myWorker = new Worker('worker.js');

// 监听工作线程的消息事件
myWorker.onmessage = function(event) {
  console.log('Received message from worker: ', event.data);
};

// 向工作线程发送消息
myWorker.postMessage('Hello, worker!');

```

在上面的例子中，我们通过 Worker() 构造函数创建了一个名为 myWorker 的新工作线程，并将 worker.js 文件作为工作线程的入口点。然后，我们监听了工作线程的消息事件，当工作线程发送消息时，会触发 onmessage 事件并执行回调函数，从而输出接收到的消息。

最后，我们向工作线程发送了一条消息，工作线程收到消息后会进行一些处理，并将处理结果通过 postMessage() 方法发送回主线程，从而触发 onmessage 事件并执行回调函数。

需要注意的是，由于 Web Worker 运行在独立的线程中，因此需要注意线程之间的通信和同步问题，避免出现竞争条件和死锁等问题。同时，由于 Web Worker 不能访问主线程的 DOM 和 BOM，因此需要在工作线程中单独处理和管理数据。

Q:对 HTML 语义化标签的理解

HTML 语义化标签是指在 HTML 中用于表示文档结构和内容语义的标签，它们不仅可以提高文档的可读性和可维护性，还可以提高搜索引擎的抓取效果和页面的可访问性。

HTML 语义化标签的主要作用包括：

1.  提高文档的可读性和可维护性：使用语义化标签可以让文档结构更加清晰和易于理解，从而提高文档的可读性和可维护性。
    
2.  提高搜索引擎的抓取效果：搜索引擎通过分析网页的结构和内容来确定网页的相关性和排名，使用语义化标签可以帮助搜索引擎更好地理解网页的内容和结构，从而提高搜索引擎的抓取效果。
    
3.  提高页面的可访问性：语义化标签可以帮助屏幕阅读器等辅助技术更好地理解网页的内容和结构，从而提高页面的可访问性。
    

HTML 语义化标签包括：header、nav、section、article、aside、footer、main、figure、figcaption 等。例如，使用 header 标签可以表示页面的头部，使用 nav 标签可以表示页面的导航栏，使用 section 标签可以表示页面的节或区域等。

需要注意的是，虽然语义化标签可以提高文档的可读性和可维护性，但过多地使用语义化标签也会导致代码冗长和结构复杂，因此在实际开发中需要根据具体情况进行选择和使用。

Q:iframe 是什么？有哪些优缺点？

iframe（内嵌框架）是 HTML 中的一个标签，可以在一个 HTML 文档中嵌入另一个 HTML 文档。通过 iframe，可以在页面中嵌入其他网站的内容，例如广告、视频、地图等，同时也可以在同一个页面中显示不同的页面内容，实现一些功能模块的分离和独立。

iframe 的优点包括：

1.  可以实现页面内容的分离和独立，避免页面混乱和结构复杂。
    
2.  可以在同一个页面中同时显示多个页面内容，提高页面的灵活性和扩展性。
    
3.  可以嵌入其他网站的内容，实现一些功能模块的集成和共享。
    

iframe 的缺点包括：

1.  增加了页面的复杂性和加载时间，特别是在嵌入大量 iframe 时，会增加页面的加载时间和服务器的压力。
    
2.  可能会对搜索引擎优化产生不良影响，因为搜索引擎不能很好地处理 iframe 中的内容。
    
3.  可能会导致网页安全问题，例如 iframe 中的内容可能会窃取用户的信息或者进行一些恶意操作。
    

总之，iframe 可以在一定程度上实现页面的分离和独立，同时也可以在同一个页面中显示不同的内容。但是，在使用 iframe 时需要注意页面的复杂性和安全性问题，避免影响用户体验和网站的安全性。

Q:Doctype 作用?严格模式与混杂模式如何区分？它们有何意义?

Doctype 是 Document Type Declaration（文档类型声明）的缩写，它是用于告诉浏览器当前 HTML 文档使用的文档类型和版本的一个标记。Doctype 的作用主要有两个方面：

1.  告知浏览器当前 HTML 文档使用的文档类型和版本，从而让浏览器能够正确地渲染页面。
    
2.  触发浏览器的标准模式，从而让浏览器按照标准规范解析 HTML 文档，避免出现不兼容性的问题。
    

严格模式和混杂模式是指浏览器在解析 HTML 文档时遵循的不同规范。严格模式是指浏览器按照标准规范解析 HTML 文档，而混杂模式是指浏览器按照一些旧的、不标准的规范解析 HTML 文档，通常是为了兼容旧的网站和浏览器。

如何区分严格模式和混杂模式？

在 HTML 文档的开头，通过 Doctype 声明来指定文档类型和版本。如果声明的文档类型和版本符合标准规范，浏览器就会进入严格模式；如果声明的文档类型和版本不符合标准规范，浏览器就会进入混杂模式。

严格模式和混杂模式的意义：

1.  严格模式可以让浏览器按照标准规范解析 HTML 文档，避免出现不兼容性的问题，提高页面的可靠性和稳定性。
    
2.  混杂模式可以让浏览器在一些旧的网站和浏览器中能够正常显示和运行，保证旧网站的兼容性和可访问性。
    

总之，Doctype 的作用是告诉浏览器当前 HTML 文档使用的文档类型和版本，并触发浏览器的标准模式，从而避免出现不兼容性的问题。严格模式和混杂模式是浏览器在解析 HTML 文档时遵循的不同规范，它们的意义在于提高页面的可靠性和稳定性，保证旧网站的兼容性和可访问性。

Q:Cookie 如何防范 XSS 攻击

XSS（跨站脚本攻击）是一种常见的网络攻击手段，攻击者通过注入恶意脚本代码，获取用户的敏感信息或者执行一些恶意操作。Cookie 是一种常见的存储用户信息的方式，因此在使用 Cookie 时需要注意防范 XSS 攻击。

以下是一些防范 XSS 攻击的方法：

1.  输入验证：对于用户输入的数据，需要进行有效性检查和过滤，避免包含恶意脚本代码。
    
2.  输出转义：对于需要在页面上显示的用户输入数据，需要进行输出转义，将 HTML 和 JavaScript 语法转换为实体字符。
    
3.  HttpOnly 属性：设置 Cookie 的 HttpOnly 属性，防止 JavaScript 脚本访问 Cookie。
    
4.  Secure 属性：设置 Cookie 的 Secure 属性，只在 HTTPS 安全连接中传输 Cookie，避免在非安全连接中传输 Cookie。
    
5.  SameSite 属性：设置 Cookie 的 SameSite 属性，限制 Cookie 的跨站访问，避免在跨站点攻击中被滥用。
    
6.  时效性：限制 Cookie 的时效性，避免过期的 Cookie 被恶意利用。
    

总之，防范 XSS 攻击需要注意输入验证、输出转义、设置 Cookie 的 HttpOnly、Secure 和 SameSite 属性等。在实际开发中，需要采取多种方法结合，从多个方面保障用户信息的安全性和保密性。

Q:Cookie 和 session 的区别

Cookie 和 session 都是在 Web 应用程序中用于存储用户信息的方式，但它们之间存在一些不同点：

1.  存储位置不同：Cookie 存储在客户端，而 session 存储在服务器端。
    
2.  安全性不同：Cookie 的信息可以被客户端篡改和窃取，而 session 存储在服务器端，相对安全。
    
3.  存储方式不同：Cookie 存储在客户端浏览器中，可以设置 Cookie 的生命周期和域，而 session 存储在服务器内存中，可以存储更多的信息。
    
4.  生存周期不同：Cookie 可以设置生命周期，在浏览器关闭后仍然有效，而 session 的生命周期默认是会话期间，即浏览器关闭后失效。
    
5.  存储容量不同：Cookie 的存储容量通常是 4KB 左右，而 session 的存储容量通常是无限制的，取决于服务器的硬件和软件配置。
    

在实际应用中，Cookie 和 session 都有自己的应用场景。一般来说，当需要存储少量的用户信息时，可以选择使用 Cookie，例如用户的用户名、密码、浏览记录等；当需要存储大量的用户信息时，可以选择使用 session，例如用户的购物车、订单、登录状态等。在存储用户信息时，需要注意安全性和保密性，避免信息泄露和被篡改，保障用户的权益和利益。

Q:讲一下 RESTFUL

RESTful 是一种软件架构风格，它是 Representational State Transfer（表述性状态转移）的缩写，用于设计和开发 Web 服务和 API 接口。RESTful 架构风格的设计原则是简单、统一、可扩展和可缓存的，它使用 HTTP 协议定义了一组标准的操作和状态码，用于实现资源的创建、读取、更新和删除（CRUD）等操作。

RESTful 架构风格的设计原则包括：

1.  客户端-服务器模式：将客户端和服务器分离，使得客户端和服务器可以独立演化和扩展。
    
2.  无状态：每个请求都包含了足够的信息，使得服务器可以独立地处理请求，而不需要保存任何状态信息。
    
3.  缓存：使用缓存机制可以提高性能和可扩展性，减少网络传输和服务器负载。
    
4.  统一接口：使用统一的接口定义可以实现客户端和服务器之间的互操作性和可扩展性。
    
5.  分层系统：将系统分成多个层次可以实现系统的松耦合和可扩展性。
    

RESTful 架构风格的实现需要遵循一些规范和约定，例如：

1.  使用 HTTP 协议定义资源的地址和操作：资源的地址使用 URL 来表示，而操作使用 HTTP 方法（GET、POST、PUT、DELETE 等）来表示。
    
2.  使用状态码表示服务器的响应状态：状态码包括成功（200）、未找到（404）、服务器错误（500）等。
    
3.  使用 JSON 或 XML 格式来传输数据：JSON 和 XML 是常用的数据传输格式，可以实现客户端和服务器之间的数据交换。
    
4.  使用 HATEOAS（Hypermedia as the Engine of Application State）：使用超媒体作为应用程序状态的引擎，可以让客户端动态地获取资源和操作。
    

总之，RESTful 是一种基于 HTTP 协议和 Web 技术的软件架构风格，它的设计原则是简单、统一、可扩展和可缓存的。使用 RESTful 架构风格可以实现客户端和服务器之间的互操作性和可扩展性，提高系统的性能和可靠性。

Q:讲讲 viewport 和移动端布局

在移动设备上浏览网页时，为了能够更好地适应不同尺寸的屏幕，需要使用 viewport 和移动端布局技术。

1.  viewport

viewport 是浏览器中的一个虚拟窗口，用于控制网页在移动设备上的显示效果。在移动设备上，默认的 viewport 大小是 980 像素，而且缩放比例为 1.0。为了让网页能够在移动设备上显示得更好，可以使用 viewport 标签来设置 viewport 的大小和缩放比例。例如：

```
<meta >

```

上述代码设置 viewport 的宽度等于设备的宽度，缩放比例为 1.0。通过设置 viewport 可以使得网页在不同设备上的显示效果更加一致和统一。

2.  移动端布局

移动设备的屏幕尺寸和分辨率各不相同，因此需要使用响应式布局技术来适配不同的设备。常用的移动端布局技术包括流式布局、弹性布局和栅格系统等。

流式布局：使用百分比和 em 单位来设置元素的大小和位置，使得元素能够随着浏览器窗口的大小自动适应。

弹性布局：使用 flexbox 布局模型来设置元素的大小和位置，可以实现更加灵活和自适应的布局效果。

栅格系统：使用栅格化布局方式来设置网页的布局，可以将网页分成多个等宽的列，适配不同的设备和屏幕大小。

总之，为了适应不同尺寸的移动设备屏幕，需要使用 viewport 和移动端布局技术。通过设置 viewport 可以控制网页的显示效果，而通过使用响应式布局技术可以实现网页的自适应和响应式布局。

Q:click 在 ios 上有 300ms 延迟，原因及如何解决

在 iOS 设备上，点击屏幕上的元素会有一个 300 毫秒的延迟，这是因为 iOS 系统会在检测到屏幕上的元素被点击后，先等待一段时间，以便用户是否需要进行双击缩放操作。这个延迟会导致用户体验下降，特别是在移动应用程序中，用户期望能够快速地响应和操作。

为了解决这个问题，可以采用以下几种方法：

1.  使用 touchstart 事件代替 click 事件：在 iOS 设备上，touchstart 事件可以在用户触摸屏幕时立即触发，而不需要等待 300 毫秒的延迟。可以通过监听 touchstart 事件来代替 click 事件，实现更加快速的响应。
    
2.  使用 FastClick 库：FastClick 是一个轻量级的 JavaScript 库，可以消除 iOS 设备上的 300 毫秒点击延迟。使用 FastClick 库需要引入 fastclick.js 文件，并在页面加载时初始化 FastClick。
    
3.  设置 meta 标签：可以在页面的 head 标签中添加以下 meta 标签：
    

```
<meta >

```

这个标签可以禁止用户对页面进行缩放操作，从而避免了 iOS 设备上的 300 毫秒点击延迟。

4.  CSS 触摸事件：可以使用 CSS 触摸事件（例如 :active）来实现用户的点击反馈效果，而不需要使用 JavaScript 来处理 click 事件。这样可以减少页面的 JavaScript 代码，提高页面的性能和响应速度。

总之，在 iOS 设备上解决 300 毫秒点击延迟可以采用多种方法，包括使用 touchstart 事件、FastClick 库、设置 meta 标签和 CSS 触摸事件等。需要根据具体的应用场景和需求，选择最适合的方法来解决这个问题。

Q:addEventListener 参数

addEventListener 是 JavaScript 中用于添加事件监听器的方法。它接受三个参数：

1.  事件类型（必选）：指定要监听的事件类型，例如 click、mouseover、keydown 等。
    
2.  事件处理函数（必选）：指定事件发生时要执行的处理函数，可以是预定义函数，也可以是匿名函数。
    
3.  选项（可选）：一个可选的对象，用于指定事件监听器的一些属性，例如 capture、once 和 passive 等。常用的选项有：
    

*   capture：一个布尔值，表示是否使用捕获阶段监听事件，默认为 false。
    
*   once：一个布尔值，表示事件是否只触发一次，触发后会自动删除监听器，默认为 false。
    
*   passive：一个布尔值，表示是否不阻止事件的默认行为，如果设置为 true，则不能使用 preventDefault() 方法来阻止默认行为。这个选项可以提高页面的性能，避免出现滑动卡顿的情况。
    

例如，添加一个 click 事件监听器，当点击按钮时，弹出一个提示框，可以使用以下代码：

```
<button id="btn">点击我</button>

<script>
  const btn = document.querySelector('#btn');
  btn.addEventListener('click', function() {
    alert('你点击了按钮！');
  });
</script>

```

上述代码中，addEventListener 方法将 click 事件与一个匿名函数关联，当用户点击按钮时，就会执行这个函数，并弹出一个提示框。默认情况下，addEventListener 方法会在冒泡阶段捕获事件，选项使用默认值，因此没有传入选项参数。

Q:http 常用请求头

HTTP 请求头是客户端向服务器发送的一些额外的信息，它可以用来告诉服务器一些请求的相关信息，例如请求的类型、请求的来源、请求的内容类型等。常用的 HTTP 请求头包括：

1.  Accept：指定客户端可以接受的 MIME 类型，例如 text/html、application/json 等。
    
2.  Accept-Encoding：指定客户端可以接受的编码类型，例如 gzip、deflate 等。
    
3.  Accept-Language：指定客户端可以接受的自然语言，例如 en-US、zh-CN 等。
    
4.  Cache-Control：指定客户端的缓存策略，例如 max-age、no-cache 等。
    
5.  Connection：指定客户端请求完成后是否保持连接，例如 keep-alive、close 等。
    
6.  Content-Type：指定客户端发送的实体内容的类型，例如 application/json、text/plain 等。
    
7.  Cookie：指定客户端发送的 Cookie 信息，用于身份验证和会话管理。
    
8.  Host：指定请求的目标服务器的主机名和端口号。
    
9.  If-Modified-Since：指定客户端希望获取的资源的最后修改时间，用于缓存控制。
    
10.  Referer：指定请求的来源地址，用于防盗链和统计分析。
    
11.  User-Agent：指定客户端的浏览器类型和版本号，用于统计和兼容性检查。
    

总之，HTTP 请求头是客户端向服务器发送的一些额外的信息，它可以用来告诉服务器一些请求的相关信息，例如请求的类型、请求的来源、请求的内容类型等。了解常用的 HTTP 请求头可以帮助开发人员更好地理解 HTTP 协议，从而设计和开发更加高效和安全的 Web 应用程序。

Q:讲讲 HTTP 状态码 304

HTTP 状态码 304 表示客户端发送了一个带有条件的 GET 请求，并且服务器判断资源未发生改变，可以直接使用缓存的响应，节省了网络传输的资源消耗。这个状态码通常会被用于浏览器缓存优化，减少不必要的网络请求，提高页面的加载速度和用户的体验。

具体地说，当客户端向服务器发送一个 GET 请求时，可以附加一些条件参数，例如 If-Modified-Since 和 If-None-Match 等，用于告诉服务器请求的资源的上次修改时间和标识符等信息。如果服务器判断请求的资源未发生改变，就可以返回一个 304 状态码，告诉客户端可以直接使用缓存的响应。

下面是一个例子：

1.  客户端发送一个 GET 请求，请求的资源是 index.html：

```
GET /index.html HTTP/1.1
Host: www.example.com
If-Modified-Since: Thu, 01 Jan 1970 00:00:00 GMT

```

2.  服务器判断 index.html 未发生改变，返回一个 304 状态码：

```
HTTP/1.1 304 Not Modified
Cache-Control: max-age=3600
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Last-Modified: Wed, 01 Jan 2020 00:00:00 GMT

```

上述例子中，客户端请求的资源是 index.html，附加了 If-Modified-Since 参数，服务器判断 index.html 未发生改变，返回了一个 304 状态码，告诉客户端可以直接使用缓存的响应。同时，服务器返回了一些缓存控制的头部信息，例如 Cache-Control、Expires 和 Last-Modified 等，用于告诉客户端如何使用缓存。

总之，HTTP 状态码 304 表示客户端发送了一个带有条件的 GET 请求，并且服务器判断资源未发生改变，可以直接使用缓存的响应。这个状态码通常会被用于浏览器缓存优化，减少不必要的网络请求，提高页面的加载速度和用户的体验。

Q:强缓存、协商缓存是什么

HTTP 缓存机制可以分为强制缓存和协商缓存两种方式，它们是 HTTP 协议中的两个重要概念，用于优化 Web 应用程序的性能和用户体验。

1.  强制缓存

强制缓存是浏览器在第一次请求资源时，将资源缓存在本地，下次请求时，直接使用本地缓存，不再向服务器发送请求。强制缓存可以通过设置 HTTP 头信息来实现，常见的 HTTP 头信息有 Expires 和 Cache-Control。如果缓存未过期，浏览器直接使用缓存，否则才向服务器发送请求。

*   Expires：通过设置过期时间，告诉浏览器在此时间之前，可以直接使用缓存，而不需要再次请求服务器。Expires 是一个绝对时间，它的值是一个 GMT 格式的日期，例如：Expires: Fri, 30 Oct 2020 08:15:00 GMT。
    
*   Cache-Control：通过设置 max-age 指令，告诉浏览器在此时间之前，可以直接使用缓存，而不需要再次请求服务器。Cache-Control 是一个相对时间，它的值是一个以秒为单位的整数，例如：Cache-Control: max-age=3600。
    

2.  协商缓存

协商缓存是浏览器在第一次请求资源时，向服务器发送请求，服务器会返回资源的 ETag 或者 Last-Modified 信息，下次请求时，浏览器会将这些信息与本地缓存进行比对，如果相同，则直接使用本地缓存，否则才向服务器发送请求。协商缓存可以通过设置 HTTP 头信息来实现，常见的 HTTP 头信息有 ETag 和 If-None-Match、Last-Modified 和 If-Modified-Since。

*   ETag 和 If-None-Match：ETag 是服务器生成的资源标识符，通过设置 ETag，服务器可以判断资源是否发生改变。如果 ETag 没有发生改变，则浏览器直接使用缓存，否则才向服务器发送请求。
    
*   Last-Modified 和 If-Modified-Since：Last-Modified 是服务器返回的资源最后修改时间，通过设置 Last-Modified，服务器可以判断资源是否发生改变。如果资源没有发生改变，则浏览器直接使用缓存，否则才向服务器发送请求。
    

总之，HTTP 缓存机制可以分为强制缓存和协商缓存两种方式，它们是 HTTP 协议中的两个重要概念，用于优化 Web 应用程序的性能和用户体验。强制缓存是浏览器直接从本地缓存中获取资源，而协商缓存是浏览器向服务器发送请求，通过比对 ETag 或者 Last-Modified 等信息来判断资源是否发生改变。开发人员可以根据具体的需求和场景，选择

Q:强缓存、协商缓存在什么场景下应该用哪个？

强制缓存和协商缓存都是 HTTP 缓存机制的实现方式，它们各有优缺点，适用于不同的场景。

强制缓存适用于那些资源变化不频繁，且期望在本地进行缓存的情况。它可以大大减少网络传输，提升网页加载速度。常用的 HTTP 头信息有 Expires 和 Cache-Control，它们可以用来设置缓存的过期时间，告诉浏览器可以直接使用缓存而不必重新请求服务器。

协商缓存适用于那些资源变化频繁，且需要实时获取最新数据的情况。它可以通过比对服务器端的资源信息和本地缓存信息，判断资源是否发生改变，从而避免不必要的网络传输。常用的 HTTP 头信息有 ETag 和 If-None-Match、Last-Modified 和 If-Modified-Since，它们可以用来比对缓存和服务器的资源信息，从而判断是否需要重新请求服务器。

在实际开发中，强制缓存和协商缓存通常会结合使用，通过设置不同的 HTTP 头信息，来控制缓存的行为和策略。例如，可以将常用的静态资源（例如 CSS、JS、图片等）进行强制缓存，同时对于经常变化的数据（例如用户信息、购物车、订单等），可以使用协商缓存，从而提高 Web 应用程序的性能和用户体验。

总之，强制缓存和协商缓存都是 HTTP 缓存机制的实现方式，它们各有优缺点，适用于不同的场景。在实际开发中，可以根据具体的需求和场景，选择合适的缓存方式，从而提高 Web 应用程序的性能和用户体验。

Q:与网络相关的 前端优化 可以从哪些方面入手

与网络相关的前端优化可以从以下方面入手：

1.  减少 HTTP 请求：HTTP 请求是浏览器和服务器之间传输数据的最基本单元，减少 HTTP 请求可以有效地降低网络传输量，提高页面的加载速度。可以通过合并和压缩 CSS、JS、图片等资源，使用雪碧图、iconfont 等技术来减少 HTTP 请求。
    
2.  压缩和优化资源：可以使用 gzip 等压缩技术来压缩 CSS、JS、HTML 等资源，从而减小资源的大小，提高网络传输效率。可以使用图片压缩工具、CSS 预处理器、JS 代码压缩器等工具来优化资源，减少资源的大小和数量。
    
3.  使用 CDN 加速：CDN（Content Delivery Network）是一种分布式的网络加速技术，可以将静态资源缓存在离用户最近的节点上，从而提高访问速度和响应时间。可以使用 CDN 来加速静态资源的访问，提高页面的加载速度和用户的体验。
    
4.  使用缓存：可以使用强制缓存和协商缓存技术来减少网络传输量，提高资源访问速度。可以使用本地缓存、服务端缓存、CDN 缓存等多种缓存技术，从而优化页面的性能和用户体验。
    
5.  使用异步加载：可以使用异步加载技术来减少页面加载时间，提高用户体验。例如，可以使用 AJAX 技术来实现局部刷新、延迟加载等功能，从而优化页面的性能和用户体验。
    
6.  优化页面结构：可以通过优化页面结构、减少 DOM 元素数量和复杂度，来提高页面渲染速度和响应时间。可以使用 HTML5 语义化标签、CSS3 动画、JS 模块化等技术来优化页面结构，从而提高页面的加载速度和用户体验。
    
7.  优化网络协议：可以使用 HTTP2.0 协议来优化网络传输效率，从而提高页面的加载速度和用户体验。HTTP2.0 支持多路复用、二进制传输、头部压缩等特性，可以有效地降低网络延迟和传输时间，提高页面性能和用户体验。
    

总之，与网络相关的前端优化可以从减少 HTTP 请求、压缩和优化资源、使用 CDN 加速、使用缓存、使用异步加载、优化页面结构、优化网络协议等多个方面入手。开发人员可以根据具体的需求和场景，选择合适的优化策略，从而提高 Web 应用程序的性能和用户体验。

Q:GET 和 POST 的区别

GET 和 POST 是 HTTP 协议中的两种基本请求方法，它们各有优缺点，适用于不同的场景。

1.  GET 请求

GET 请求通常用于获取资源，它是一种幂等的请求方法，即多次请求的结果应该是相同的。GET 请求将参数附加到 URL 后面，以问号（?）分隔，多个参数之间用&符号连接。GET 请求对参数的长度和类型有限制，一般用于传递简单的参数，例如搜索关键词、分页等。

优点：

*   GET 请求幂等，多次请求的结果相同，不会产生副作用。
*   GET 请求可以被缓存，提高性能和效率。
*   GET 请求可以直接被书签收藏，方便用户访问。

缺点：

*   GET 请求对参数的长度和类型有限制，不适合传递大量或复杂的参数。
*   GET 请求的参数会被暴露在 URL 中，安全性较低。
*   GET 请求会被浏览器主动缓存，可能导致更新不及时。

2.  POST 请求

POST 请求通常用于提交数据，它是一种非幂等的请求方法，即多次请求的结果可能不同。POST 请求将参数包含在请求体中，参数长度和类型没有限制，可以传递大量或复杂的参数。

优点：

*   POST 请求可以传递大量或复杂的参数，不受长度和类型限制。
*   POST 请求的参数不会被暴露在 URL 中，安全性较高。
*   POST 请求不会被浏览器主动缓存，更新及时。

缺点：

*   POST 请求不幂等，多次请求的结果可能不同，可能产生副作用。
*   POST 请求不能直接被书签收藏，用户访问不方便。
*   POST 请求的性能和效率不如 GET 请求，因为需要传输更多的数据。

总之，GET 和 POST 是 HTTP 协议中的两种基本请求方法，它们各有优缺点，适用于不同的场景。开发人员可以根据具体的需求和场景，选择合适的请求方法，从而提高 Web 应用程序的性能和用户体验。

Q:如何画一个三角形

在 HTML 中，可以通过 CSS 的 border 属性来实现三角形的绘制。

具体实现方法如下：

1.  首先，定义一个 div 元素，作为三角形的容器：

```
<div class="triangle"></div>

```

2.  然后，在 CSS 中定义该 div 元素的样式，设置其宽度和高度为 0，然后通过 border 属性来绘制三角形：

```
.triangle {
  width: 0;
  height: 0;
  border-top: 50px solid transparent;
  border-right: 50px solid red;
  border-bottom: 50px solid transparent;
}

```

以上代码中，通过 border-top、border-right 和 border-bottom 属性来定义三角形的三个边，宽度为 50px，颜色为红色。通过 border-top 和 border-bottom 的 transparent 属性值来定义三角形的两个顶点。

通过以上代码，即可实现一个红色的三角形。如果需要绘制其他颜色或样式的三角形，只需修改 border 属性的值即可。

Q:HTML5 新增的元

HTML5 是 HTML 的第五个版本，引入了许多新的元素和属性，以便开发人员更好地构建 Web 应用程序和网站。

以下是 HTML5 新增的一些元素：

1.  section 元素：用于定义文档中的节或区域，可以用于组织文档结构。
    
2.  article 元素：用于定义独立的文章，可以用于表示博客文章、新闻报道等独立的内容。
    
3.  header 元素：用于定义文档的页眉，可以包含标题、导航栏、标志等内容。
    
4.  footer 元素：用于定义文档的页脚，可以包含版权信息、联系方式等内容。
    
5.  nav 元素：用于定义导航菜单，可以包含链接、按钮等内容。
    
6.  aside 元素：用于定义侧边栏或附加内容，可以用于包含广告、相关文章等内容。
    
7.  figure 元素：用于定义图像、图表、照片等媒体内容，可以包含标题和说明文字。
    
8.  figcaption 元素：用于定义 figure 元素的标题或说明文字。
    
9.  video 元素：用于嵌入视频内容，可以设置多种视频格式和属性。
    
10.  audio 元素：用于嵌入音频内容，可以设置多种音频格式和属性。
    
11.  canvas 元素：用于绘制图形和动画，可以使用 JavaScript 来操作和控制绘制。
    
12.  progress 元素：用于显示进度条，可以用于表示文件上传、下载等操作的进度。
    
13.  meter 元素：用于显示度量值，可以用于表示温度、速度等测量结果。
    
14.  datalist 元素：用于定义选项列表，可以提供输入提示和自动完成功能。
    
15.  details 元素：用于定义可展开的详细信息，可以包含摘要、内容等内容。
    

总之，HTML5 新增的元素和属性可以更好地满足 Web 应用程序和网站的需求，开发人员可以根据具体的需求和场景，选择合适的元素和属性来构建 Web 应用程序和网站。

Q:在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？

在地址栏输入 URL 后，到页面呈现出来，中间会发生以下一系列的步骤：

1.  DNS 解析：浏览器会根据 URL 中的域名部分，向 DNS 服务器发送请求，获取对应的 IP 地址。
    
2.  建立 TCP 连接：浏览器会向获取到的 IP 地址发送 TCP 连接请求，与目标服务器建立 TCP 连接。
    
3.  发送 HTTP 请求：建立 TCP 连接后，浏览器会向服务器发送 HTTP 请求，请求中包含要访问的 URL、请求方法、请求头等信息。
    
4.  服务器处理请求并返回响应：服务器接收到浏览器的请求后，会根据请求中的信息进行处理，然后返回响应，响应中包含 HTTP 状态码、响应头和响应体等信息。
    
5.  浏览器解析响应并渲染页面：浏览器接收到响应后，会根据响应中的 HTML、CSS、JavaScript 等内容进行解析和渲染，最终呈现出页面。
    
6.  断开 TCP 连接：页面渲染完成后，浏览器会向服务器发送关闭连接的请求，断开与服务器的 TCP 连接。
    

总之，地址栏输入 URL 后，浏览器会通过 DNS 解析、建立 TCP 连接、发送 HTTP 请求、服务器处理请求并返回响应、浏览器解析响应并渲染页面等一系列的过程，最终呈现出页面。了解这些过程可以帮助我们更好地理解 Web 应用程序和网站的工作原理，从而更好地进行 Web 开发和优化。

Q:浏览器渲染页面的流程

浏览器渲染页面的流程主要包括以下几个步骤：

1.  构建 DOM 树：浏览器接收到 HTML 文档后，会根据 HTML 标签的嵌套关系和属性值等信息，构建出 DOM 树。
    
2.  构建 CSSOM 树：浏览器接收到 CSS 文件后，会解析 CSS 文件，然后根据 CSS 选择器的规则，构建出 CSSOM 树。
    
3.  合并 DOM 树和 CSSOM 树，生成渲染树：浏览器将 DOM 树和 CSSOM 树合并起来，生成渲染树，渲染树上的每个节点都包含了要显示的内容、布局信息、样式等属性。
    
4.  布局计算：浏览器根据渲染树上每个节点的位置和大小等信息，进行布局计算，确定每个节点在屏幕上的位置和大小。
    
5.  绘制页面：浏览器根据渲染树上每个节点的样式和位置等信息，使用 GPU 进行页面的绘制。
    
6.  合成图层：浏览器根据绘制结果，将页面分为多个图层，每个图层都可以独立绘制和更新，提高页面渲染的效率。
    
7.  显示页面：浏览器将合成图层显示在屏幕上，用户就可以看到页面了。
    

以上是浏览器渲染页面的主要流程，其中包括 DOM 树的构建、CSSOM 树的构建、渲染树的生成、布局计算、页面绘制、图层合成和页面显示等一系列的过程。了解这些过程可以帮助我们更好地理解页面渲染的工作原理，从而更好地进行 Web 开发和优化。

Q:常见的 HTTP 的头部

HTTP 请求头和响应头中常见的头部如下：

1.  请求头

*   Accept：指定客户端可接受的响应类型。
*   Accept-Encoding：指定客户端可接受的内容编码方式。
*   Cache-Control：控制缓存的行为，如 max-age、no-cache、no-store 等。
*   Content-Type：指定请求体或响应体的 MIME 类型。
*   Cookie：发送请求时，服务器通过该头部来获取客户端的 Cookie。
*   Referer：指定当前请求的来源 URL。
*   User-Agent：指定客户端的浏览器类型和操作系统信息等。

2.  响应头

*   Access-Control-Allow-Origin：指定允许访问该资源的域名。
*   Cache-Control：控制缓存的行为，如 max-age、no-cache、no-store 等。
*   Content-Type：指定响应体的 MIME 类型。
*   Set-Cookie：服务器通过该头部来设置客户端的 Cookie。
*   Server：指定服务器的软件类型和版本等。
*   Content-Encoding：指定响应体的内容编码方式。

以上是 HTTP 请求头和响应头中常见的头部，可以根据具体的需求和场景，选择合适的头部来控制和优化 HTTP 请求和响应的行为。

Q:cache-control 的值有哪些

Cache-Control 是 HTTP 报文头部中的一个字段，用于控制缓存的行为。常见的 Cache-Control 值包括：

1.  public：表示响应可以被任何缓存缓存。
2.  private：表示响应只能被单个用户缓存，不能被共享缓存缓存。
3.  no-cache：表示缓存需要向源服务器进行重新验证，以确定缓存是否过期。
4.  no-store：表示响应不能被缓存，需要每次从源服务器获取最新的资源。
5.  max-age=xxx：表示资源可以被缓存的最长时间，单位为秒。
6.  s-maxage=xxx：表示公共缓存可以缓存资源的最长时间，单位为秒。
7.  must-revalidate：表示在资源过期后，必须向源服务器进行重新验证，以确定资源是否过期。
8.  proxy-revalidate：表示在缓存过期后，代理服务器必须向源服务器进行重新验证，以确定资源是否过期。
9.  no-transform：表示在代理服务器上不能对资源进行变换，例如压缩或翻译等。

以上是常见的 Cache-Control 值，可以根据具体的需求和场景，选择合适的值来控制和优化缓存的行为。

Q:csrf 和 xss 的攻击及防范

CSRF（跨站请求伪造）和 XSS（跨站脚本攻击）是 Web 应用程序中常见的安全问题，它们分别是两种不同的攻击方式，需要采取不同的防范措施。

1.  CSRF 攻击及防范

CSRF 攻击指攻击者利用用户在已登录的情况下发起的请求，伪装成用户向服务器发送请求，例如进行转账操作、修改密码等。常见的防范措施包括：

*   在关键操作中增加验证流程，例如输入验证码或密码等。
*   在请求头中添加 Token，服务器对该 Token 进行验证，来确定请求是否合法。
*   在 Cookie 中添加 HttpOnly 属性，防止攻击者通过 JavaScript 脚本获取到 Cookie 的值。

2.  XSS 攻击及防范

XSS 攻击指攻击者在 Web 应用程序中注入恶意脚本，使得其他用户在访问该页面时，受到攻击者的控制。常见的防范措施包括：

*   对用户输入的数据进行过滤和转义，避免恶意脚本被注入到页面中。
*   在响应头中添加 Content-Security-Policy（CSP）字段，指定允许加载的资源类型和域名，避免恶意脚本被加载。
*   在 Cookie 中添加 HttpOnly 属性，防止攻击者通过 JavaScript 脚本获取到 Cookie 的值。

以上是 CSRF 和 XSS 攻击的简介及常见的防范措施。需要注意的是，防范措施并不能完全杜绝攻击的发生，只能减少攻击的可能性。在 Web 应用程序开发过程中，需要加强对安全问题的重视，采取多重防范措施，确保 Web 应用程序的安全性。

Q:怎么看网站的性能如何

网站的性能可以从多个方面进行评估，主要包括以下几个方面：

1.  网站加载速度：网站的加载速度是评估性能的关键指标，可以通过浏览器的开发者工具或第三方工具（如 PageSpeed Insights）来测试网站的加载速度。
    
2.  页面响应时间：页面响应时间是用户等待页面加载和渲染的时间，可以通过网络面板或 JavaScript 代码进行测量。
    
3.  可用性和稳定性：网站的可用性和稳定性也是评估性能的重要指标，需要定期进行监控和测试，以确保网站能够正常运行。
    
4.  页面结构和优化：页面结构和优化也对性能有重要影响，可以从 HTML、CSS 和 JavaScript 代码的结构、文件大小和压缩、图像和多媒体资源的优化等方面进行评估和优化。
    
5.  移动端兼容性：对于移动端网站，需要特别注意移动设备的兼容性和性能优化，包括响应式布局、缩放优化、图片压缩等。
    

综上所述，网站的性能评估需要从多个方面进行考虑和优化，需要采用多种工具和技术手段来进行测试和分析，以确保网站能够提供优秀的用户体验和良好的性能表现。

Q:cookie 有哪些字段可以设置

Cookie 是一种存储在客户端的数据，通常用于记录用户的登录状态、购物车信息等。在设置 Cookie 时，可以通过设置不同的字段来控制 Cookie 的行为，常用的字段包括：

1.  名称和值：指定 Cookie 的名称和值。
    
2.  过期时间：指定 Cookie 的过期时间，过期后 Cookie 将自动删除。可以通过 max-age、expires 字段来设置过期时间。
    
3.  域名：指定 Cookie 所属的域名，可以控制 Cookie 的访问范围。
    
4.  路径：指定 Cookie 所属的路径，可以控制 Cookie 的访问范围。
    
5.  安全标识：指定是否只有在 HTTPS 安全连接下才能访问 Cookie。
    
6.  HttpOnly 标识：指定 Cookie 是否只能通过 HTTP 协议传输，防止恶意脚本获取 Cookie。
    

以上是常用的 Cookie 字段，可以根据具体的需求和场景，选择合适的字段来设置和控制 Cookie 的行为。需要注意的是，Cookie 可以被恶意利用，需要采取安全措施来保护用户的隐私和安全。例如，对敏感信息的 Cookie 设置 HttpOnly 标识，以防止恶意脚本获取 Cookie 的值。

Q:cookie 有哪些编码方式？

在设置和读取 Cookie 的过程中，需要对 Cookie 的名称和值进行编码，以确保 Cookie 的可靠性和正确性。常用的 Cookie 编码方式包括：

1.  URL 编码：可以使用 JavaScript 中的 encodeURI() 和 encodeURIComponent() 函数对 Cookie 进行 URL 编码。
    
2.  Base64 编码：可以使用 JavaScript 中的 btoa() 和 atob() 函数对 Cookie 进行 Base64 编码。
    
3.  JSON 编码：可以使用 JSON.stringify() 和 JSON.parse() 函数对 Cookie 进行 JSON 编码和解码。
    

需要注意的是，不同的编码方式适用于不同的场景和需求，需要根据具体情况进行选择。例如，对于需要在 URL 中传输的 Cookie，可以使用 URL 编码来确保传输的正确性；对于需要加密的 Cookie，可以使用 Base64 编码或其他加密算法来保护数据的安全性。

Q:说一下 css 盒模型

CSS 盒模型是指在 Web 页面中，每个元素都可以看作一个矩形盒子，包含内容、内边距、边框和外边距等几个部分。CSS 盒模型分为两种，分别是标准盒模型和怪异盒模型。

1.  标准盒模型

标准盒模型指的是元素的宽度和高度不包括内边距和边框的大小，即内容框的大小为元素的宽度和高度。标准盒模型的计算公式为：元素的宽度 = 内容框的宽度 + 左右内边距 + 左右边框宽度；元素的高度 = 内容框的高度 + 上下内边距 + 上下边框宽度。

2.  怪异盒模型

怪异盒模型指的是元素的宽度和高度包括内边距和边框的大小，即元素的大小为内容框的大小加上内边距和边框的大小。怪异盒模型的计算公式为：元素的宽度 = 内容框的宽度；元素的高度 = 内容框的高度。

在 CSS 中，可以通过设置 box-sizing 属性来控制盒模型的类型，属性值为 content-box 时使用标准盒模型，属性值为 border-box 时使用怪异盒模型。需要根据具体的需求和场景来选择合适的盒模型。例如，对于需要精确控制元素大小和位置的布局，可以选择使用标准盒模型；对于需要快速构建布局的场景，可以选择使用怪异盒模型来减少布局代码的编写量。

Q:还有一个值是 padding-box 你了解吗？

padding-box 是 CSS 盒模型中的一个属性值，它指的是元素的宽度和高度不包括边框的大小，但包括内边距的大小，即元素的大小等于内容框和内边距的大小之和。与 padding-box 对应的是 content-box 和 border-box。

padding-box 并不常用，它的应用场景比较有限。在默认的情况下，CSS 盒模型采用的是 content-box，即元素的宽度和高度不包括内边距和边框的大小。如果需要将内边距也计算在内，可以使用 padding-box。需要注意的是，在某些浏览器中可能不支持 padding-box 属性值，因此在使用时需要进行兼容性测试。

综上所述，padding-box 是 CSS 盒模型中的一个属性值，可以用于控制盒模型的大小计算方式，但在实际开发中并不常用。需要根据具体的需求和场景来选择合适的盒模型属性值。

Q:画一条 0.5px 的线

在 CSS 中，0.5px 并不是一个有效的像素单位，因为在一些设备上并不支持非整数像素值，会出现模糊或显示异常的情况。因此，如果需要画一条细线，可以通过以下几种方式实现：

1.  使用 border 和伪类

可以通过在元素的边框上设置细线的样式，然后使用伪类（如 :before 或 :after）来占用边框的一侧，从而实现细线的效果。例如：

```
div {
  position: relative;
  width: 100px;
  height: 100px;
  border: 1px solid black;
}

div::before {
  content: "";
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 1px;
  height: 100%;
  background-color: black;
}

```

2.  使用 CSS transform

可以通过使用 CSS transform 属性来实现细线的效果。例如：

```
div {
  position: relative;
  width: 100px;
  height: 100px;
  background-color: black;
}

div::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 1px;
  background-color: white;
  transform: scaleY(0.5);
  transform-origin: 0 0;
}

```

3.  使用 SVG

可以通过使用 SVG 来绘制细线的效果。例如：

```
<svg width="100" height="1">
  <line x1="0" y1="0.5" x2="100" y2="0.5" stroke="black" stroke-width="1"/>
</svg>

```

以上是几种实现细线效果的方法，需要根据具体的需求和场景来选择合适的方法。需要注意的是，某些浏览器可能不支持某些方法，因此在使用时需要进行兼容性测试。

Q:还有其他画一条 0.5px 的线方式吗？

在 Web 开发中，由于设备像素和 CSS 像素的差异，浏览器并不支持非整数像素值，因此要画一条 0.5px 的线比较困难。除了上述提到的方法外，还有一些其他的实现方式，例如：

1.  使用 scale() 函数

可以通过将元素缩小一半，然后使用 transform: scale(2) 来放大，从而实现 0.5px 的线条。例如：

```
div {
  width: 100px;
  height: 1px;
  background-color: black;
  transform-origin: 0 0;
  transform: scaleY(0.5);
}

```

2.  使用 viewport units

可以使用 viewport units 来实现细线的效果。例如：

```
div {
  width: 100vw;
  height: 0.5vw;
  background-color: black;
}

```

需要注意的是，以上方法都有一定的局限性和兼容性问题，因此需要根据具体的需求和场景来选择合适的方法。如果对线条的精度要求不高，可以考虑使用较为简单的方法来实现。

Q:link 标签和 import 标签的区别

link 标签和 import 标签都是用来加载外部资源的标签，它们之间的区别如下：

1.  加载方式

link 标签是 HTML 4.01 中引入的标签，用于在 HTML 文档中引入外部资源，例如样式表、图标和脚本等。link 标签可以通过 rel 属性指定资源的类型，如样式表、图标等。

import 标签是 HTML 5 中引入的标签，用于在 HTML 文档中引入外部的 HTML 模块。import 标签只能用于加载 HTML 模块，不能用于加载其他类型的资源。

2.  加载时机

link 标签会在页面加载时同时加载资源，从而可以在页面加载完成后立即使用。而 import 标签是通过 JavaScript 动态加载资源的，因此需要等待 JavaScript 加载完成后才能使用。

3.  兼容性

由于 import 标签是 HTML 5 中的新标签，因此在一些旧版本的浏览器中可能不支持 import 标签的使用。而 link 标签是 HTML 4.01 中的标签，因此兼容性更好。

综上所述，link 标签和 import 标签都可以用于加载外部资源，但是它们之间的使用场景和兼容性有所差异，需要根据具体的需求和场景来选择合适的标签。一般来说，如果需要加载样式表或其他资源，可以使用 link 标签；如果需要加载 HTML 模块，可以考虑使用 import 标签。

Q:transition 和 animation 的区别

transition 和 animation 都是 CSS3 动画的实现方式，它们之间的区别如下：

1.  实现方式

transition 实现动画的方式是在元素状态发生变化时，通过设置过渡属性（transition-property）、过渡时间（transition-duration）、过渡函数（transition-timing-function）和延迟时间（transition-delay）等来实现动画效果。例如：

```
div {
  transition: background-color 1s ease-in-out;
}

div:hover {
  background-color: red;
}

```

animation 实现动画的方式是通过关键帧（keyframes）来描述动画的状态和变化，通过设置动画名称（animation-name）、动画时间（animation-duration）、动画函数（animation-timing-function）、动画延迟时间（animation-delay）、动画播放次数（animation-iteration-count）等来实现动画效果。例如：

```
@keyframes my-animation {
  0% { transform: rotate(0); }
  100% { transform: rotate(360deg); }
}

div {
  animation: my-animation 1s ease-in-out infinite;
}

```

2.  控制方式

transition 的触发方式是通过某个事件（如 hover、click 等）来触发元素状态的变化，从而触发动画效果。transition 的动画只能由浏览器自动触发。

animation 的触发方式是通过 CSS 属性来控制动画的播放，可以通过 JavaScript 动态修改 CSS 属性值来控制动画的播放。

3.  动画描述

transition 主要用于描述元素状态的过渡效果，即在状态 A 到状态 B 的过程中产生的变化效果。

animation 主要用于描述元素的运动或变形效果，可以实现更为复杂的动画效果。

综上所述，transition 和 animation 都是实现 CSS3 动画的方式，但是它们之间的实现方式、控制方式和动画描述有所不同，需要根据具体的需求和场景来选择合适的方式。通常情况下，如果需要实现简单的过渡效果，可以使用 transition；如果需要实现复杂的动画效果，可以考虑使用 animation。

Q:谈一谈 Flex 布局

Flex 布局（Flexible Box Layout）是一种用于布局和定位子元素的新的 CSS3 布局模式。相较于传统的布局方式，Flex 布局具有以下优势：

1.  自适应布局

Flex 布局可以根据父容器的大小自动调整子元素的大小和位置，从而实现自适应布局的效果。

2.  简单易用

Flex 布局的语法简单明了，易于理解和使用，可以快速实现各种布局效果。

3.  灵活性强

Flex 布局提供了多种布局方式和对齐方式，可以根据具体的需求和场景进行灵活的组合和调整。

Flex 布局的基本概念包括：容器（container）、项目（item）和轴（axis）。Flex 布局通过设置容器的属性来控制子元素的排列和对齐方式。常用的 Flex 属性包括：

*   display：设置容器为 Flex 布局
*   flex-direction：设置主轴的方向
*   justify-content：设置子元素在主轴上的对齐方式
*   align-items：设置子元素在交叉轴上的对齐方式
*   flex-wrap：设置是否换行
*   align-content：设置多行子元素在交叉轴上的对齐方式
*   order：设置子元素的排列顺序
*   flex-grow：设置子元素在空间不足时的放大比例
*   flex-shrink：设置子元素在空间过多时的缩小比例
*   flex-basis：设置子元素的基准大小

Flex 布局适用于各种不同的布局场景，例如页面布局、导航菜单、图片墙等。在使用 Flex 布局时，需要根据具体的需求和场景来选择合适的属性和值，并考虑兼容性和可维护性等因素。

Q:谈一下 BFC

BFC（Block Formatting Context）是 CSS 中的一种格式化上下文，用于控制块级元素的布局和排列。BFC 的主要作用包括：

1.  清除浮动

在 BFC 中，浮动元素会被包裹在 BFC 中，并影响到 BFC 中其他元素的布局。因此，通过在 BFC 中包裹浮动元素，可以清除浮动对其他元素的影响，从而避免出现布局错误的问题。

2.  防止 margin 重叠

在 BFC 中，相邻的两个块级元素的 margin 不会重叠，从而避免了一些布局问题。

3.  控制元素的流动方向

在 BFC 中，元素的流动方向可以根据 BFC 的方向来控制。例如，如果 BFC 的方向为垂直方向，则元素会按照从上到下的顺序依次排列。

BFC 的创建有多种方式，包括：

1.  根元素：文档的根元素会自动生成一个 BFC。
2.  浮动元素：当一个元素浮动后，它会创建一个新的 BFC。
3.  绝对定位元素：当一个元素的 position 属性值为 absolute 或 fixed 时，它会创建一个新的 BFC。
4.  display 属性：当一个元素的 display 属性值为 inline-block、table-cell、table-caption 或 flex 时，它会创建一个新的 BFC。

BFC 的应用场景包括：

1.  清除浮动
2.  避免 margin 重叠
3.  控制元素的流动方向
4.  创建多栏布局
5.  避免某些元素被浮动元素覆盖

BFC 是 CSS 中一个重要的概念，掌握 BFC 的创建方式和应用场景，可以有效地解决一些布局问题。

Q:元素垂直居中的方法

在 Web 开发中，实现元素垂直居中是一个常见的问题。以下是一些实现元素垂直居中的方法：

1.  使用 Flex 布局

使用 Flex 布局是实现元素垂直居中的最简单和最常用的方法。通过设置父容器的 display 属性为 flex，并设置 justify-content 和 align-items 属性为 center，即可实现子元素在水平和垂直方向上的居中对齐。

2.  使用 table-cell 和 vertical-align 属性

将父容器的 display 属性设置为 table，将子元素的 display 属性设置为 table-cell，然后设置子元素的 vertical-align 属性为 middle，即可实现元素在垂直方向上的居中对齐。

3.  使用绝对定位和 transform 属性

将子元素的 position 属性设置为 absolute，然后将 left 和 top 属性设置为 50%，再使用 transform 属性将子元素向左和向上移动自身宽高的一半，即可实现元素在垂直方向上的居中对齐。

4.  使用 line-height 属性

将父元素的 line-height 属性值设置为与容器高度相等的值，然后将子元素的 display 属性设置为 inline 或 inline-block，即可实现元素在垂直方向上的居中对齐。

5.  使用 calc() 函数

使用 calc() 函数可以计算出子元素的高度，然后将子元素的 margin-top 和 margin-bottom 属性值设置为 auto，将 height 属性设置为 calc(100% - 上下 margin 的和)，即可实现元素在垂直方向上的居中对齐。

以上是实现元素垂直居中的常用方法，不同的方法适用于不同的场景，具体应根据实际需求来选择合适的方法。

Q:文本对齐的常见问题、难点 和 解决方案

文本对齐是 Web 开发中一个常见的问题，常见的问题和难点包括：

1.  对齐方式的选择：文本对齐方式包括左对齐、右对齐、居中和两端对齐。对于不同的应用场景，应选择合适的对齐方式。
    
2.  字符宽度不同：中文字符和英文字符的宽度不同，因此在对齐时可能会出现偏差。这种情况下可以使用 CSS 的 text-align-last 属性来调整最后一行的对齐方式，或者使用 CSS3 的 text-justify 属性来调整文本的对齐方式。
    
3.  换行对齐：当文本换行时，可能会出现对齐不一致的情况。这种情况下可以使用 CSS 的 text-align 属性来控制换行时的对齐方式，或者使用 CSS 的 white-space 属性来控制文本的换行方式。
    
4.  行高和字体大小的不同：当文本行高和字体大小不同时，可能会出现对齐偏差的问题。这种情况下可以使用 CSS 的 line-height 属性来设置文本的行高，或者使用 CSS 的 vertical-align 属性来控制文本的垂直对齐方式。
    

解决这些问题的方法包括：

1.  使用 CSS 的 text-align、text-align-last、text-justify 和 white-space 属性来控制文本的对齐方式和换行方式。
    
2.  使用 CSS 的 line-height 和 vertical-align 属性来控制文本的行高和垂直对齐方式。
    
3.  对于复杂的排版需求，可以使用 CSS3 的多列布局、CSS Grid 和 Flex 布局等高级布局方式来实现文本对齐。
    

综上所述，文本对齐是 Web 开发中一个重要的问题，需要根据实际需求选择合适的对齐方式和解决方案。

Q:关于 JS 动画和 css3 动画的差异性

JavaScript 动画和 CSS3 动画都可以用于在网页中实现动态效果，但它们之间有一些差异性：

1.  执行方式：JavaScript 动画是通过编写 JavaScript 代码来实现的，而 CSS3 动画则是通过 CSS 样式来实现的。
    
2.  动画效率：CSS3 动画效率更高，因为 CSS3 动画使用了浏览器的硬件加速，而 JavaScript 动画则需要浏览器通过脚本来计算每一帧的动画效果。
    
3.  动画效果：CSS3 动画可以实现更复杂的动画效果，例如旋转、缩放、渐变、透明度等。而 JavaScript 动画则更适用于实现更复杂的交互效果。
    
4.  代码量：CSS3 动画代码量更少，因为它不需要编写复杂的 JavaScript 代码。而 JavaScript 动画则需要编写复杂的脚本来实现动画效果。
    
5.  兼容性：CSS3 动画在较老的浏览器中可能会存在兼容性问题，而 JavaScript 动画则更加兼容。
    

综上所述，JavaScript 动画和 CSS3 动画各有优劣，在实际开发中需要根据具体的需求选择合适的动画方式。对于简单的动画效果，建议使用 CSS3 动画来实现，对于复杂的交互效果，建议使用 JavaScript 动画来实现。

Q:讲一下渲染线程

渲染线程是浏览器中的一个线程，它负责将 HTML、CSS 和 JavaScript 转化为可视化的网页。渲染线程的主要工作流程包括：

1.  解析 HTML 和 CSS：渲染线程会将 HTML 和 CSS 解析为 DOM 树和 CSSOM 树，并将它们合并成渲染树。
    
2.  布局计算：渲染线程会对渲染树进行布局计算，确定每个元素在页面上的位置和大小。
    
3.  绘制渲染树：渲染线程会将渲染树转化为图形界面，然后通过 GPU 进行绘制，最终呈现在屏幕上。
    

渲染线程与其他线程的关系如下：

1.  主线程：主线程负责处理用户输入和 JavaScript 代码执行等任务，通过消息队列将渲染线程的请求发送给渲染线程。
    
2.  网络线程：网络线程负责处理网络请求和响应，将响应数据发送给渲染线程进行渲染。
    
3.  GPU 线程：GPU 线程负责将渲染树转化为图形界面，并通过 GPU 进行绘制。
    

需要注意的是，渲染线程是单线程执行的，意味着一次只能执行一个任务，当有多个任务需要执行时，会根据优先级选择先执行哪个任务。因此，在开发 Web 应用程序时，需要注意优化页面性能，减少渲染线程的负担，以提高页面的响应速度和用户体验。

Q: 渲染进程包含哪些进程？

渲染进程是浏览器的核心进程之一，它包含以下几个子进程：

1.  主进程（Browser Process）：主进程是浏览器的核心进程，它负责创建和销毁其他进程，并提供统一的接口进行进程间通信。
    
2.  GPU 进程（GPU Process）：GPU 进程负责将渲染进程生成的图像传递给 GPU 进行渲染。
    
3.  网络进程（Network Process）：网络进程负责处理网络请求和响应。
    
4.  渲染进程（Renderer Process）：渲染进程是浏览器中最核心的进程，它负责将 HTML、CSS 和 JavaScript 转化为可视化的网页，并将网页呈现在屏幕上。
    

每个网页都会有一个对应的渲染进程，这些渲染进程之间是相互隔离的，一个渲染进程崩溃不会影响到其他渲染进程。这种进程隔离的设计可以提高浏览器的稳定性和安全性。

需要注意的是，不同浏览器的进程架构可能存在差异，例如 Chromium 浏览器就采用了多进程架构，而 Firefox 则采用了多线程架构。在开发 Web 应用程序时，需要考虑不同浏览器的进程架构，以确保应用程序的兼容性和性能。

Q:说一下块元素和行元素

在 HTML 中，元素可以分为块级元素和行内元素，它们的主要区别在于：

1.  定义：块级元素（Block-level Element）是指那些在页面中以块的形式显示的元素，例如 `<div>`、`<p>`、`<h1>` 等；行内元素（Inline Element）是指那些在页面中以行的形式显示的元素，例如 `<a>`、`<span>`、`<img>` 等。
    
2.  盒模型：块级元素有自己的盒模型，可以设置宽度、高度、内边距和外边距等属性；行内元素则没有自己的盒模型，它们的大小由它们所包含的文本或其他内容决定。
    
3.  布局：块级元素独占一行或多行，可以通过设置宽度、高度、浮动等属性来控制布局；行内元素则会随着文本流动而排列，无法通过宽度和高度来控制布局。
    
4.  默认样式：块级元素的默认样式为占据整个父容器的宽度，而行内元素则只占据自身内容的宽度。
    

需要注意的是，HTML5 中还有一种元素叫做行内块元素（Inline-block Element），它具有行内元素的特性和块级元素的盒模型和样式设置，常用于实现水平排列和垂直居中等效果。

在实际开发中，应根据元素的特性和需求来选择使用块级元素、行内元素还是行内块元素。需要注意的是，块级元素和行内元素的样式可以通过 CSS 来修改，例如通过 `display` 属性将行内元素转化为块级元素或行内块元素。

Q:如何实现多行元素的文本省略号

在 CSS 中，可以使用 `text-overflow` 属性来实现多行元素的文本省略号。该属性可以设置以下几个值：

*   `clip`：默认值，表示不显示省略号，也不换行；
*   `ellipsis`：表示使用省略号来代替被省略的文本；
*   `string`：表示使用指定的字符串来代替被省略的文本，可以自定义字符串的内容。

需要注意的是，为了让多行文本产生省略号，必须先设置 `overflow: hidden` 和 `white-space: nowrap` 属性，然后再通过 `text-overflow` 属性来实现省略号的效果。

下面是一个示例代码：

```
<div class="box">
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed euismod, turpis ac venenatis maximus, enim felis lobortis metus, eu viverra libero augue eget dolor.
</div>

```

```
.box {
  width: 200px;
  height: 80px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

```

在上面的示例中，`.box` 元素设置了固定的宽度和高度，并且将 `overflow` 属性设置为 `hidden`，`white-space` 属性设置为 `nowrap`，表示不换行。然后使用 `text-overflow` 属性将超出部分的文本使用省略号来代替，实现了多行元素的文本省略号效果。

Q:如何实现多行文本的第三行文本超出内容有省略号

要实现多行文本的第三行文本超出内容有省略号，可以使用 CSS 的 `::after` 伪元素和 `line-clamp` 属性来实现。

首先，需要给多行文本元素设置一个固定的高度，然后使用 `display: -webkit-box` 和 `-webkit-box-orient: vertical` 属性将元素设置为垂直方向的弹性容器，从而实现多行文本的效果。

接下来，使用 `::after` 伪元素来在第三行文本后面添加一个省略号。为了实现这个效果，需要先设置 `content: "..."`，然后使用 `display: inline-block`、`width: 1em` 和 `overflow: hidden` 属性来将省略号的宽度设置为一个字符的宽度，最后使用 `-webkit-line-clamp` 属性来设置文本的最大行数为 2 行，加上 `::after` 伪元素就实现了多行文本的第三行文本超出内容有省略号的效果。

下面是一个示例代码：

```
<div class="box">
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed euismod, turpis ac venenatis maximus, enim felis lobortis metus, eu viverra libero augue eget dolor.
</div>

```

```
.box {
  width: 200px;
  height: 3.5em;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  overflow: hidden;
  -webkit-line-clamp: 2;
}

.box::after {
  content: "...";
  display: inline-block;
  width: 1em;
  overflow: hidden;
}

```

在上面的示例中，`.box` 元素设置了固定的宽度和高度，并使用 `-webkit-box` 和 `-webkit-box-orient` 属性将元素设置为垂直方向的弹性容器。然后使用 `-webkit-line-clamp` 属性将文本的最大行数设置为 2 行。最后，在第三行文本后面使用 `::after` 伪元素添加一个省略号，实现多行文本的第三行文本超出内容有省略号的效果。

Q:双边距重叠问题（外边距折叠）

双边距重叠问题，也叫外边距折叠，是指在某些情况下，两个或多个相邻元素之间的外边距会发生合并的现象，导致外边距的值变成了其中较大的一个。

外边距折叠的情况包括：

1.  父元素和第一个或最后一个子元素之间的外边距会发生折叠；
2.  相邻的兄弟元素之间的外边距会发生折叠。

解决双边距重叠问题的方法包括：

1.  将两个相邻元素之间的外边距设置为 0；
2.  在两个相邻元素之间添加一个空的元素，并设置该元素的高度为 0，从而阻止外边距的折叠；
3.  对于父元素和第一个或最后一个子元素之间的外边距折叠问题，可以给父元素添加 `padding` 或 `border` 属性来解决问题。

下面是一个示例代码：

```
<div class="box1"></div>
<div class="box2"></div>
<div class="box3"></div>

```

```
.box1 {
  width: 100px;
  height: 100px;
  background-color: red;
  margin-bottom: 20px;
}

.box2 {
  width: 100px;
  height: 100px;
  background-color: green;
  margin-top: 20px;
}

.box3 {
  clear: both;
  height: 0;
}

```

在上面的示例中，`.box1` 和 `.box2` 元素之间的外边距会发生折叠，为了解决这个问题，可以在它们之间添加一个空的元素 `.box3`，并设置其高度为 0，从而阻止外边距的折叠。在这个示例中，`.box3` 的 `clear: both` 属性可以清除浮动，从而使 `.box3` 元素位于 `.box1` 和 `.box2` 元素之下。这样，就能够避免外边距的折叠问题了。

Q:position 属性都有哪些值，请做出比较

CSS 中的 `position` 属性有以下 5 个取值：

1.  static：默认值，元素按照文档流进行布局，忽略 `top`、`bottom`、`left` 和 `right` 属性的设置；
2.  relative：元素按照文档流进行布局，但可以通过 `top`、`bottom`、`left` 和 `right` 属性的设置相对于原始位置进行定位；
3.  absolute：元素相对于最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于 `<html>` 元素进行定位；
4.  fixed：元素相对于视口进行定位，不随滚动条滚动而移动；
5.  sticky：元素根据正常文档流进行布局，然后相对于其在流中的容器（父元素）和视口之间的某个阈值进行定位。

相对于其他 `position` 属性值而言，`absolute` 和 `fixed` 属性值是比较特殊的，它们的定位不再按照文档流进行，而是相对于已定位的祖先元素或者视口进行定位，因此它们可以用于实现一些比较特殊的布局效果。而 `relative` 和 `sticky` 属性值都是相对于元素在文档流中的位置进行定位，因此它们可以用于实现一些比较简单的布局效果。而 `static` 属性值则表示元素按照文档流进行布局，没有任何定位的效果。

Q:浮动清除怎么做

浮动清除指的是通过 CSS 技术解决浮动元素引起的高度坍塌问题，使包含浮动元素的容器能够自适应高度，从而保证布局的正确性。

常见的浮动清除方法包括：

1.  在容器底部添加一个空的块级元素，然后给这个元素设置 `clear: both` 属性，从而清除浮动。
2.  在容器底部添加一个伪元素，然后给这个伪元素设置 `clear: both` 属性，从而清除浮动。
3.  给包含浮动元素的容器添加 `overflow: hidden` 属性，从而让容器成为一个 BFC，从而清除浮动。
4.  使用 `after` 伪元素，将其设置为块级元素，然后设置 `content: "."`，并为该元素设置 `display: block`、`height: 0`、`clear: both` 属性，从而清除浮动。

下面是一个示例代码，展示如何通过 `after` 伪元素实现浮动清除：

```
<div class="container">
  <div class="box"></div>
  <div class="box"></div>
  <div class="box"></div>
  <div class="clear"></div>
</div>

```

```
.container {
  width: 600px;
  margin: 0 auto;
  border: 1px solid #ccc;
  padding: 10px;
}

.box {
  width: 200px;
  height: 100px;
  float: left;
  background-color: #f00;
  margin-right: 10px;
}

.clear::after {
  content: ".";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}

```

在这个示例中，`.container` 元素是包含浮动元素的容器，通过在容器底部添加一个 `clear` 类的块级元素，并给该元素添加一个 `after` 伪元素，并设置 `content: "."`，从而清除浮动，实现了容器高度自适应的效果。通过这种方式，就可以避免因为浮动元素引起的高度坍塌问题了。

Q:常见的 css3 新特性有哪些？

CSS3 是 CSS 技术的最新版本，包含了许多新特性，常见的 CSS3 新特性包括：

1.  媒体查询：可以根据设备的屏幕尺寸、分辨率、方向等参数，对不同的设备提供不同的样式。
2.  盒模型：包括了 border-box 和 content-box 两种模型，可以通过设置 box-sizing 属性来指定。
3.  弹性盒模型（Flexbox）：可以让容器内的元素按照一定比例自动排列，并能够灵活控制容器内元素的大小、顺序和位置。
4.  网格布局（Grid）：可以将网页划分为行和列，用于实现更复杂的布局效果。
5.  变形（Transform）：可以通过设置 transform 属性，对元素进行旋转、缩放、移动等变形操作。
6.  过渡（Transition）：可以通过设置 transition 属性，让元素在状态变化时，实现平滑的过渡效果。
7.  动画（Animation）：可以通过设置 animation 属性，实现复杂的动画效果。
8.  渐变（Gradient）：可以通过设置 linear-gradient 或 radial-gradient 属性，实现渐变色的效果。
9.  边框（Border）：可以通过设置 border-image 属性，实现复杂的边框效果。
10.  文字特效：包括 text-shadow、word-wrap、word-break 等属性，可以实现文字阴影、自动换行等效果。

这些 CSS3 新特性大大增强了 CSS 技术的表现力和可用性，让开发人员可以更加灵活地进行网页布局和样式设计。同时，这些新特性也提高了网页的可访问性和交互性，带来了更好的用户体验。

Q:CSS 选择器有哪些，优先级是怎样的

CSS 选择器用于选择要应用样式的 HTML 元素，常见的 CSS 选择器包括：

1.  元素选择器：根据 HTML 元素名称进行选择，例如 `p`、`div`、`ul` 等。
2.  类选择器：根据 HTML 元素的 class 属性进行选择，例如 `.classname`。
3.  ID 选择器：根据 HTML 元素的 id 属性进行选择，例如 `#idname`。
4.  属性选择器：根据 HTML 元素的属性进行选择，例如 `[title="example"]`。
5.  伪类选择器：根据 HTML 元素的状态进行选择，例如 `:hover`、`:active`、`:focus` 等。
6.  伪元素选择器：根据 HTML 元素的子元素进行选择，例如 `::before`、`::after`。

CSS 选择器的优先级是根据权重来决定的，权重的计算规则如下：

1.  元素选择器的权重为 1，类选择器的权重为 10，ID 选择器的权重为 100，属性选择器的权重为 10。
2.  组合选择器的权重等于各个选择器的权重之和。
3.  通配符选择器的权重为 0，但是可以和其他选择器组合使用。
4.  内联样式的权重为 1000。

在应用样式时，如果存在多个选择器对同一元素应用样式，那么就会根据选择器的权重来决定哪个样式优先级更高。如果多个选择器的权重相同，那么就会根据 CSS 样式表中的顺序来决定。通常情况下，应该尽量避免使用 `!important` 来提高样式的优先级，因为这样会破坏 CSS 的权重规则，增加样式维护的难度。

Q:怎么样让一个元素消失，几种方法有什么区别

在网页设计中，经常需要让某个元素消失或隐藏，通常可以使用以下几种方法：

1.  `display: none`：将元素的 `display` 属性设置为 `none`，使其完全消失，不占用页面空间。这种方式可以在运行时通过 JS 动态设置，但是会影响页面的布局和渲染。
    
2.  `visibility: hidden`：将元素的 `visibility` 属性设置为 `hidden`，使其不可见，但是仍然占用页面空间。这种方式不会影响页面的布局和渲染，但是可能会影响页面性能。
    
3.  `opacity: 0`：将元素的 `opacity` 属性设置为 0，使其完全透明，但是仍然占用页面空间。这种方式可以通过动画效果逐渐让元素消失，但是不适用于需要完全隐藏元素的场合。
    

这三种方法都可以用于让元素消失或隐藏，但是它们的区别在于是否占用页面空间、是否影响页面布局和渲染、是否支持动画效果等。需要根据具体的场景和需求选择合适的方法，以达到最佳的效果和性能。同时，为了提高网站的可访问性和搜索引擎优化效果，应该避免使用过多的隐藏元素和不良的网页设计方式，保证网站的易用性和可维护性。

Q:如何实现图片在某个容器内居中

要实现图片在某个容器内居中，可以使用以下几种方法：

1.  使用 CSS 的 `text-align` 属性将容器内的文本居中，例如将容器的 `text-align` 属性设置为 `center`，可以让容器内的图片居中。这种方法适用于容器只包含一张图片的场合。
    
2.  使用绝对定位将图片居中，可以将图片的 `position` 属性设置为 `absolute`，并设置 `top`、`left`、`bottom`、`right` 属性为 0，再将容器的 `position` 属性设置为 `relative`，可以让图片在容器内居中。这种方法适用于容器大小固定，图片大小不固定的场合。
    
3.  使用 Flex 布局将图片居中，可以将容器的 `display` 属性设置为 `flex`，并设置 `justify-content` 和 `align-items` 属性为 `center`，可以让图片在容器内水平和垂直居中。这种方法适用于容器大小不固定，但是图片大小固定的场合。
    

以上是实现图片在某个容器内居中的几种方法，需要根据具体的场合和需求选择合适的方法。同时，为了提高网站的性能和用户体验，应该尽量避免使用过多的图片和不必要的居中操作，保证网站的加载速度和流畅度。

Q:CSS3 中对溢出的处理

在 CSS3 中，对于元素的溢出，可以使用以下几种方式进行处理：

1.  `overflow: visible`：默认情况下，元素的 `overflow` 属性值为 `visible`，表示允许内容溢出并显示在元素外部。这种方式适用于需要显示元素内部的所有内容的场合。
    
2.  `overflow: hidden`：将元素的 `overflow` 属性值设置为 `hidden`，可以隐藏元素内部溢出的内容，不显示在元素外部。这种方式适用于需要隐藏元素溢出内容的场合。
    
3.  `overflow: scroll`：将元素的 `overflow` 属性值设置为 `scroll`，可以在元素内部显示滚动条，并允许用户滚动查看溢出内容。这种方式适用于需要允许用户滚动查看元素内部溢出内容的场合。
    
4.  `overflow: auto`：将元素的 `overflow` 属性值设置为 `auto`，可以根据元素内容是否溢出来自动选择是否显示滚动条。当元素内容溢出时，会自动显示滚动条，否则不显示滚动条。这种方式适用于需要根据元素内容是否溢出自动选择是否显示滚动条的场合。
    

除了以上四种方式外，还可以通过 CSS3 的一些新特性，如 `text-overflow` 和 `word-break` 等来处理元素内容的溢出问题。需要根据具体的场景和需求选择合适的方式进行处理，以达到最佳的效果和性能。同时，为了提高网站的可访问性和用户体验，应该保证元素内部的内容不会过度溢出或被隐藏，保证网站的易用性和可读性。

Q:提供几种三栏布局的实现方式

三栏布局是常用的页面布局之一，下面提供几种实现三栏布局的方式：

1.  浮动布局：将左右两栏设置为 `float: left` 和 `float: right`，中间栏设置 `margin` 或 `padding` 来避开两栏，这样就可以实现三栏布局。缺点是当左右两栏高度不同时，可能会出现高度错乱的情况。
    
2.  绝对定位布局：将左右两栏设置为 `position: absolute`，并设置 `left` 和 `right` 属性来固定其位置，中间栏设置 `margin` 或 `padding` 来避开两栏，这样就可以实现三栏布局。缺点是当内容过长时，可能会出现内容溢出的情况。
    
3.  Flex 布局：将三栏都放在一个 Flex 容器中，将左右两栏设置为 `flex: 0 0 auto`，中间栏设置为 `flex: 1 0 auto`，这样就可以实现三栏布局。Flex 布局具有灵活性和可响应性，适用于各种不同尺寸的设备和屏幕。
    
4.  Grid 布局：使用 CSS3 的 Grid 布局，将页面分为若干个网格，将三栏分别放在不同的网格中，然后通过 `grid-template-rows` 和 `grid-template-columns` 属性来定义网格的大小和布局，就可以实现三栏布局。Grid 布局具有灵活性和可响应性，适用于各种不同尺寸的设备和屏幕。
    

以上是实现三栏布局的几种方式，需要根据具体的需求和场景选择合适的方式进行布局。同时，为了提高网站的性能和用户体验，应该尽量避免使用过多的浮动和绝对定位，保证网站的加载速度和流畅度。

Q:浮动布局时，三个 div 的生成顺序有没有影响？

在浮动布局中，三个 `div` 的生成顺序对最终布局的结果是有影响的。

具体来说，浮动元素在页面中的位置由其在 HTML 中出现的顺序来决定。因此，如果先生成了左侧浮动元素，那么它会尽可能地往左边靠拢，而右侧浮动元素则会排在左侧浮动元素的右边。同理，如果先生成了右侧浮动元素，那么它会尽可能地往右边靠拢，而左侧浮动元素则会排在右侧浮动元素的左边。

这个问题可以通过修改浮动元素的 `float` 属性来解决。如果想要左侧元素排在最左边，而右侧元素排在最右边，可以将左侧元素设置为 `float: left;`，右侧元素设置为 `float: right;`，这样就可以实现左右两侧各一个浮动元素的效果。

需要注意的是，在浮动布局中，如果元素的宽度超过了容器的宽度，可能会出现元素溢出的情况。可以通过设置元素的 `overflow` 属性来控制元素溢出的处理方式，以保证网站的可访问性和用户体验。同时，也需要注意浮动元素可能会对文档流产生影响，可能需要使用清除浮动等技术来避免出现布局问题。

Q:介绍一下 calc 属性

`calc()` 是 CSS3 新增的一个计算属性，它可以在 CSS 中进行数学计算，并动态地计算出结果，可以用来解决一些复杂的布局问题。

`calc()` 的语法如下：

```
calc( <expression> )

```

其中 `<expression>` 可以是任意的数学表达式，包括加减乘除和括号等运算符，也可以包括百分比、长度单位和变量等。例如，可以使用 `calc()` 计算出两个元素的宽度和高度的和，或者计算出一个元素的宽度和高度的平均值，等等。

`calc()` 的优点包括：

*   可以使用数学计算解决复杂的布局问题；
*   可以动态地计算结果，适用于响应式布局；
*   可以使用百分比、长度单位和变量等进行计算，非常灵活。

`calc()` 的缺点包括：

*   不是所有浏览器都支持 `calc()` 属性，需要进行兼容性处理；
*   进行复杂的数学计算时，可能会影响网站的性能。

在使用 `calc()` 属性时，需要注意以下几点：

*   表达式中的数值、操作符、变量等必须用空格隔开；
*   表达式中的长度单位必须与其它值使用相同的单位；
*   如果表达式中包含有括号，需要使用英文括号，而不能使用中文括号；
*   在一些旧版本的浏览器中，可能需要加上 `-webkit-calc()` 前缀。

总之，`calc()` 属性是 CSS3 中非常有用的一个属性，可以用来解决一些复杂的布局问题，同时也需要注意浏览器的兼容性和性能问题。

Q:有一个 width300 height300 的元素，怎么实现在屏幕上垂直水平居中

可以使用如下方式实现在屏幕上垂直水平居中：

HTML 代码：

```
<div class="box"></div>

```

CSS 代码：

```
.box {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  height: 300px;
}

```

其中，`position: fixed` 可以将元素固定在视口中，不会随着滚动条的滚动而移动，`top: 50%` 和 `left: 50%` 可以将元素的左上角放置在视口的中心位置，`transform: translate(-50%, -50%)` 可以将元素自身的中心点移动到视口的中心位置，从而实现垂直水平居中的效果。最后，设置元素的宽度和高度即可。

需要注意的是，这种方式仅适用于固定宽度和高度的元素。如果元素的宽度和高度是动态计算的，需要使用 JavaScript 或者其他方法来实现垂直水平居中的效果。同时，在实际应用中，还需要考虑浏览器的兼容性和响应式布局的问题。

Q:display：table 和本身的 table 有什么区别

`display: table` 和本身的 `<table>` 元素在表现上有一些区别，但它们都可以用来创建表格布局。

*   `<table>` 元素是 HTML 语义化标签，用于创建表格布局，可以设置行、列、单元格等元素，支持表头、表格、表格数据等内容，并且支持一些表格相关的属性和方法，比如 `border`、`cellspacing`、`caption` 等。
*   `display: table` 是 CSS 布局属性，它可以将一个块级元素呈现为一个表格，但是并不支持表格相关的属性和方法，只支持一些基本的表格布局样式，比如 `table-layout`、`border-collapse` 等。

两者的使用场景有所不同：

*   如果需要创建一个表格，包含表头、表格、表格数据等内容，并且需要支持一些表格相关的属性和方法，那么应该使用 `<table>` 元素。
*   如果只需要创建一个基本的表格布局，并且不需要使用表格相关的属性和方法，那么可以使用 `display: table`，它可以创建一个类似于表格的布局，但更加灵活和易于控制。

需要注意的是，由于 `<table>` 元素本身具有语义化的特性，因此在一些情况下，使用 `<table>` 元素可能会更符合 HTML 规范和较好的可访问性。而 `display: table` 属性则更加适用于一些复杂的布局场景，比如响应式布局、移动端布局等。同时，在实际应用中，还需要考虑浏览器的兼容性和性能问题。

Q:position 属性的值有哪些及其区别

`position` 属性是 CSS 中的定位属性，用于指定元素的定位方式，它有以下几个可能的取值：

1.  `static`（静态定位）：默认值，元素按照文档流正常排列，不会被定位。
2.  `relative`（相对定位）：元素相对于其原始位置进行移动，不会影响其他元素的位置，可以使用 `top`、`bottom`、`left`、`right` 等属性来控制元素的位置。
3.  `absolute`（绝对定位）：元素相对于其最近的已定位的祖先元素进行定位，如果没有已定位的祖先元素，则相对于文档进行定位，可以使用 `top`、`bottom`、`left`、`right` 等属性来控制元素的位置。
4.  `fixed`（固定定位）：元素相对于浏览器窗口进行定位，不会随着页面的滚动而移动，可以使用 `top`、`bottom`、`left`、`right` 等属性来控制元素的位置。
5.  `sticky`（粘性定位）：元素在满足一定条件（如滚动到指定位置）时变为固定定位，否则为相对定位，可以使用 `top`、`bottom`、`left`、`right` 等属性来控制元素的位置。

这些属性值的区别如下：

*   `static`：元素按照文档流正常排列，不会被定位。
*   `relative`：元素相对于其原始位置进行移动，不会影响其他元素的位置。
*   `absolute`：元素相对于其最近的已定位的祖先元素进行定位，如果没有已定位的祖先元素，则相对于文档进行定位，可能会影响其他元素的位置。
*   `fixed`：元素相对于浏览器窗口进行定位，不会随着页面的滚动而移动，可能会影响其他元素的位置。
*   `sticky`：元素在满足一定条件时变为固定定位，否则为相对定位，可以设置 `top`、`bottom`、`left`、`right` 等属性来控制元素的位置，但是可能会影响其他元素的位置。

需要注意的是，使用 `position` 属性定位元素时，可能会影响其他元素的位置和布局，需要谨慎使用。同时，在实际应用中，还需要考虑浏览器的兼容性和性能问题。

Q:z-index 的定位方法

`z-index` 是 CSS 中的一个属性，用于指定元素在堆叠上下文中的堆叠层级，它的取值为一个整数或 `auto`。取值越大的元素在堆叠上下文中就越靠上面，可以用来控制元素的遮盖关系。

一般情况下，`z-index` 只有在元素的 `position` 属性值为 `relative`、`absolute` 或 `fixed` 时才会生效，因为只有这些元素才能创建自己的堆叠上下文。

在使用 `z-index` 进行定位时，可以按照以下几个步骤进行：

1.  首先，需要将需要定位的元素设置为 `position: relative`、`position: absolute` 或 `position: fixed`，以创建一个新的堆叠上下文。
2.  然后，需要将这些元素的 `z-index` 设置为一个合适的值，使它们按照需要的顺序进行堆叠，其中取值越大的元素在堆叠上下文中越靠上。
3.  如果需要进行遮盖或者穿透的话，可以使用 `opacity` 属性或者 `pointer-events` 属性来控制元素的可见性和可点击性。

需要注意的是，在使用 `z-index` 进行定位时，要注意避免出现层叠失效的情况，比如在两个元素之间使用 `z-index: 9999`，因为这样会导致两个元素的 `z-index` 值相同，无法进行正确的层叠。此外，在实际应用中，还需要考虑浏览器的兼容性和性能问题。

Q:设置一个元素的背景颜色，背景颜色会填充哪些区域？

当我们设置一个元素的背景颜色时，这个背景颜色会填充该元素的内容区域和内边距区域，但不会填充边框和外边距区域。

具体来说，一个元素的可视部分由以下几个区域组成：

1.  内容区域：包含元素的实际内容，由 `width` 和 `height` 属性确定大小。
2.  内边距区域：位于内容区域周围，由 `padding` 属性确定大小。
3.  边框区域：位于内边距区域周围，由 `border` 属性确定大小和样式。
4.  外边距区域：位于边框区域周围，由 `margin` 属性确定大小。

当我们设置一个元素的背景颜色时，该颜色会填充该元素的内容区域和内边距区域，但不会填充边框和外边距区域。如果想要让背景颜色填充整个元素，可以使用 `box-sizing` 属性将元素的盒模型设置为 `border-box`，这样背景颜色就会包括内容区域、内边距区域和边框区域。

Q:inline-block、inline 和 block 的区别

在 CSS 中，元素的 `display` 属性可以设置为 `block`、`inline` 或 `inline-block`，它们的主要区别在于元素的盒模型和布局特性。

1.  `block` 元素会在页面中生成一个块级盒子，可以设置宽度、高度、内外边距和边框等属性，会独占一行空间。常见的 `block` 元素包括 `div`、`p`、`h1` 等。
    
2.  `inline` 元素不会生成一个块级盒子，只占据所需的空间，不能设置宽度、高度、内外边距和边框等属性。常见的 `inline` 元素包括 `a`、`span`、`label` 等。
    
3.  `inline-block` 元素与 `inline` 类似，可以像 `block` 元素一样设置宽度、高度、内外边距和边框等属性，但不会独占一行，而是与其他 `inline` 元素在同一行显示。常见的 `inline-block` 元素包括 `input`、`button`、`img` 等。
    

总体来说，`block` 元素和 `inline-block` 元素更适合用于页面布局，而 `inline` 元素则更适合用于文本排版。当需要在一个元素中同时包含文本和其他元素时，可以使用 `inline-block` 元素。

Q:为什么 img 是 inline 还可以设置宽高

在 HTML 中，`img` 元素的默认 `display` 属性是 `inline`，这意味着它会像文本一样排列在行内，并且可以和其他文本或 `inline` 元素在同一行显示。但与其他 `inline` 元素不同的是，`img` 元素具有设置宽度和高度的属性。

这是因为 `img` 元素是一种特殊的内联元素，它在加载图片前需要预留一定的空间。如果没有设置宽度和高度，`img` 元素的大小会根据图片大小自动调整，这样会导致页面的布局不稳定。因此，我们通常会在 `img` 元素中显式地设置宽度和高度属性，来确保页面的稳定性和布局效果。

同时，需要注意的是，当设置了 `img` 元素的宽度和高度之后，图片的实际大小可能会被拉伸或压缩以适应这个尺寸。如果想要保持图片的原始比例，可以只设置其中一个属性，另一个属性会根据图片的宽高比自动计算。例如，只设置 `width` 属性为 200px，高度会根据图片的宽高比自动计算，以保持图片的原始比例。

Q:了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法

重绘（repaint）和重排（reflow）是网页性能优化中需要了解的两个概念。

重绘是指元素样式的变化不会影响布局，只会影响元素的外观，比如改变元素的背景色、字体颜色等，此时浏览器只需要更新元素的样式，不需要重新计算元素的位置和大小，因此重绘的代价较小。

重排是指元素的尺寸、位置等属性发生变化，需要重新计算布局，比如添加、删除、修改元素、改变浏览器大小等，此时浏览器需要重新计算元素的位置和大小，并重新绘制页面，代价较大。

为了减少重绘和重排的次数，可以采取以下措施：

1.  减少 DOM 操作次数：尽可能减少对 DOM 的操作，可以先在 JavaScript 中构建 HTML 片段，然后再将其一次性添加到文档中。
    
2.  批量修改样式：在 JavaScript 中，可以先将需要修改的样式都保存到一个类中，然后一次性将这个类添加到元素上。
    
3.  使用文档片段：在 JavaScript 中，可以使用文档片段（DocumentFragment）将多个元素先添加到文档片段中，然后一次性将文档片段添加到文档中，这样可以减少重排和重绘的次数。
    
4.  避免不必要的布局：在 JavaScript 中，可以通过修改元素的 className 属性，来触发样式的变化，而不是直接修改元素的 style 属性，这样可以避免不必要的布局。
    
5.  避免强制同步布局：在 JavaScript 中，可以使用 requestAnimationFrame() 方法，将需要更新的操作放到下一帧中执行，避免强制同步布局，从而减少重排和重绘的次数。
    

让文档脱离文档流的方法有以下几种：

1.  使用 `position: absolute`、`position: fixed`、`float` 等属性，将元素从文档流中脱离出来。
    
2.  使用 `visibility: hidden`、`display: none` 等属性，将元素隐藏起来，但仍占据文档流中的位置。
    
3.  使用 `margin`、`padding` 等属性，将元素的大小扩大或缩小，从而使其脱离文档流。
    

需要注意的是，文档脱离文档流会导致页面的布局发生变化，可能会触发重排和重绘，因此需要谨慎使用，尽量避免频繁地使用这些方法。

Q:overflow 的原理

`overflow` 属性是用来控制元素内容超出其指定区域时的表现方式，其原理是基于滚动机制。

当一个元素的 `overflow` 属性被设置为 `scroll` 或 `auto` 时，如果该元素的内容超出了其指定的区域，那么这个元素就会生成一个滚动条，用户就可以通过滚动条滚动内容，以查看超出部分的内容。

当一个元素的 `overflow` 属性被设置为 `hidden` 时，如果该元素的内容超出了其指定的区域，那么超出部分的内容就会被裁剪掉，用户无法查看被裁剪掉的部分。

当一个元素的 `overflow` 属性被设置为 `visible` 时，如果该元素的内容超出了其指定的区域，那么超出部分的内容就会显示出来，可能会遮盖其它元素，从而影响页面布局。

总的来说，`overflow` 属性的原理就是在需要时生成滚动条或裁剪掉超出的内容，以实现元素内容的显示效果。

Q:两个嵌套的 div，position 都是 absolute，子 div 设置 top 属性，那么这个 top 是相对于父元素的哪个位置定位的?

当子 div 设置 `position: absolute` 时，`top` 属性表示子元素的上边缘相对于其包含块（即父元素）上边缘的距离。因此，子元素设置 `top: 0` 表示将其上边缘与父元素的上边缘对齐。如果设置 `top` 值为负数，则子元素会向上偏移；如果设置 `top` 值为正数，则子元素会向下偏移。

Q:谈一谈盒子模型

盒子模型是用来描述 HTML 元素的布局的一种概念。它把 HTML 元素看作是一个矩形的盒子，包含了元素的内容、内边距、边框和外边距。

在 CSS 中，每个元素都有一个盒子模型。盒子模型包含四个部分：

1.  Content Box（内容区）：元素的实际内容，比如文本、图片、视频等。
2.  Padding Box（内边距区）：位于内容区和边框之间的空间，用来控制元素内容与边框之间的距离。
3.  Border Box（边框区）：围绕元素的边框，用来分隔元素的内部和外部区域。
4.  Margin Box（外边距区）：位于元素边框外的空间，用来控制元素与其它元素之间的距离。

在标准盒子模型中，盒子的大小由内容区、内边距和边框共同决定，而外边距不会影响盒子的大小。而在 IE 盒子模型中，盒子的大小由内容区、内边距、边框和外边距共同决定。

盒子模型在页面布局和样式设计中起着重要的作用，通过设置盒子模型的各个属性，可以控制元素的大小、内边距、边框和外边距等方面的样式。因此，理解和掌握盒子模型的概念和应用是 CSS 样式设计中的基础。

Q:display:none 和 visibilty:hidden 的区别

display:none 和 visibility:hidden 都是用来隐藏元素的。

display:none 的作用是完全从文档流中移除元素，它不会占据任何空间，也不会被渲染出来。即使使用 JavaScript 来访问该元素的属性，也无法获取到其信息。这意味着，如果一个元素使用了 display:none，那么它不会对布局和渲染造成任何影响，而且也无法通过 JavaScript 来显示该元素。因此，display:none 通常用于动态地显示或隐藏元素。

visibility:hidden 的作用是隐藏元素，但是该元素仍然占据空间，只是不可见而已。即使使用 JavaScript 来访问该元素的属性，仍然可以获取到其信息。这意味着，如果一个元素使用了 visibility:hidden，那么它会对布局和渲染造成影响，只是该元素不可见而已。因此，visibility:hidden 通常用于需要在需要隐藏元素的同时，仍然要占据空间的情况。

综上所述，display:none 和 visibility:hidden 的区别在于，前者完全从文档流中移除元素，不占据任何空间，后者只是将元素隐藏起来，但仍然占据空间。由于两者的作用不同，因此在具体使用时需要根据实际情况来选择。

Q:http 请求参数的大小有限制吗？

HTTP 请求参数的大小是有限制的。在 HTTP/1.1 中，没有明确规定请求行、请求头和请求体的大小限制，这由具体实现来决定。不过，通常情况下，Web 服务器和浏览器都会设置默认的大小限制。

对于 GET 请求，请求行和请求头通常不会超过 8KB 的限制，因为 URL 的长度受限于浏览器和服务器的限制，而 GET 请求的请求体是空的，因此不受大小限制。

对于 POST 请求，由于请求体中包含请求参数，因此其大小受到限制。在 HTTP/1.1 中，Web 服务器和浏览器通常将 POST 请求的最大大小限制在 2MB 左右，但这也取决于具体实现。如果需要发送更大的数据，可以使用 HTTP 分块编码（chunked encoding）或者使用 HTTP/2 协议。需要注意的是，过大的请求数据可能会导致网络传输效率降低，影响用户体验，因此应该尽可能避免发送过大的请求数据。

Q:具体实现上讲，不同浏览器对 http 请求的限制是什么呢？

不同浏览器对 HTTP 请求的大小限制可能略有不同，但通常都有类似的限制。

以下是一些主流浏览器的 HTTP 请求大小限制：

*   Chrome：GET 请求的 URL 参数长度限制为 2MB 左右，POST 请求的请求体大小限制为 2MB 左右。
*   Firefox：GET 请求的 URL 参数长度限制为 100KB 左右，POST 请求的请求体大小限制为 2GB 左右（具体限制取决于服务器）。
*   Safari：GET 请求的 URL 参数长度限制为 2MB 左右，POST 请求的请求体大小限制为 2.5MB 左右。
*   Edge：GET 请求的 URL 参数长度限制为 2MB 左右，POST 请求的请求体大小限制为 100MB 左右。

需要注意的是，这些限制可能会随着浏览器版本的不同而有所改变，而且不同浏览器的实现可能有所不同，因此在开发过程中需要根据具体情况进行测试和调整。同时，如果需要发送大量数据，也可以考虑使用其他协议或者工具，如 WebSocket、WebRTC 等。

Q:http 请求中，get 和 post 请求在缓存方面的区别

GET 请求和 POST 请求在缓存方面的区别如下：

GET 请求的缓存机制：

*   GET 请求可以被浏览器缓存，当再次发起相同的 GET 请求时，浏览器可以直接从缓存中读取数据而无需重新请求服务器。
*   浏览器在请求资源时，会根据该资源的缓存标识（如 Etag、Last-Modified 等）判断该资源是否需要更新，若资源未更新，则直接从缓存中读取；否则，向服务器请求新的资源并更新缓存。
*   GET 请求缓存可以通过设置请求头来控制，常用的控制缓存的头信息包括：Cache-Control、Expires 和 If-Modified-Since。

POST 请求的缓存机制：

*   POST 请求一般不会被缓存，因为它的请求参数通常是动态生成的，无法直接从缓存中读取。
*   但是，如果服务器响应的 HTTP 头信息中包含了缓存控制相关的字段（如 Cache-Control、Expires 等），则浏览器也可以根据这些信息缓存 POST 请求响应的内容。

需要注意的是，缓存机制的具体实现可能因浏览器而异，因此需要在开发过程中仔细了解和测试不同浏览器的缓存行为，以确保应用的正确性和稳定性。同时，对于需要动态生成参数的请求，也可以考虑使用其他请求方法或者工具，如 AJAX 等。

Q:谈一谈闭包

闭包是一种在 JavaScript 中常见的特殊的函数形式，它可以访问外部函数的变量，即使在外部函数已经执行完毕之后也可以访问到这些变量。

在 JavaScript 中，函数的作用域是在定义时就已经确定的。当函数被执行时，它可以访问到当前作用域内的所有变量和函数。但是，当函数执行完毕之后，它的作用域就会被销毁，其中定义的变量也会随之被销毁。这种限制在一定程度上会限制函数的使用场景。

而闭包可以解决这个问题。它可以让函数在执行完毕之后仍然可以访问到外部函数的变量，从而提供了一种可以在函数执行完毕之后仍然可以保留变量值的机制。

在 JavaScript 中，闭包的实现是通过将函数作为变量返回，并且在函数内部嵌套另外一个函数。这个内部函数可以访问外部函数的变量，从而形成了一个闭包。当外部函数执行完毕后，它返回的内部函数仍然可以访问外部函数的变量，因为这些变量被保存在内存中，并且与返回的函数一起形成了闭包。

在实际的开发中，闭包常常用于封装私有变量，或者在异步操作中保存变量状态等。同时，也需要注意闭包可能会引发内存泄漏等问题，因此需要在使用时仔细考虑和管理。

Q:谈一下类的创建和继承

在 JavaScript 中，类是一种对象，可以用来封装一组相关的数据和方法，并且可以用来创建多个实例对象。

在 ES6 之前，JavaScript 并没有内置的类，而是使用函数和原型来模拟类的概念。通常情况下，创建一个类需要定义一个构造函数和一组原型方法。构造函数可以用来初始化对象的状态，原型方法可以用来定义对象的行为。

例如，下面的代码定义了一个名为 Person 的类：

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.sayHello = function() {
  console.log('Hello, my name is ' + this.name);
};

```

上述代码中，Person 是一个构造函数，可以用来创建 Person 类的实例对象。构造函数中的 this 关键字代表新创建的对象。而 Person.prototype 对象则定义了 Person 类的一组原型方法。

在 ES6 中，JavaScript 引入了 class 关键字，使得类的定义更加简单和直观。下面是使用 class 定义 Person 类的代码：

```
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log('Hello, my name is ' + this.name);
  }
}

```

使用 class 定义类的语法更加清晰，同时也可以定义静态属性和静态方法等高级特性。

继承是一种实现代码复用的机制，它允许一个类从另一个类中继承一组属性和方法。在 JavaScript 中，类的继承可以通过原型链实现。子类可以通过原型链继承父类的属性和方法，并且还可以定义自己的属性和方法。

在 ES6 中，可以使用 extends 关键字来实现类的继承。例如，下面的代码演示了如何定义一个 Student 类，并且从 Person 类中继承属性和方法：

```
class Student extends Person {
  constructor(name, age, grade) {
    super(name, age);
    this.grade = grade;
  }

  study() {
    console.log(this.name + ' is studying in grade ' + this.grade);
  }
}

```

在上述代码中，Student 类继承了 Person 类，并且在自己的构造函数中调用了 super 方法，以便调用父类的构造函数初始化属性。同时，还定义了自己的 study 方法。

继承是一种非常重要的面向对象编程的概念，在实际开发中经常用到。需要注意的是，JavaScript 中的继承和其他面向对象编程语言有所不同，需要仔细理解和学习。

Q:谈一谈 原型链继承 构造继承 实例继承 拷贝继承 组合继承 寄生组合继承

在 JavaScript 中，继承是实现面向对象编程的重要部分。常见的继承方式包括原型链继承、构造函数继承、实例继承、拷贝继承、组合继承和寄生组合继承。下面逐一介绍：

1.  原型链继承

原型链继承是通过让一个构造函数的原型对象指向另一个构造函数的实例来实现继承。这种继承方式的优点是可以继承父类原型中的属性和方法，缺点是会有属性共享的问题，即子类实例共享父类属性。

2.  构造函数继承

构造函数继承是通过在子类构造函数中调用父类构造函数并传递参数来实现继承。这种继承方式的优点是可以避免属性共享的问题，缺点是无法继承父类原型中的属性和方法。

3.  实例继承

实例继承是通过创建一个父类实例作为子类的原型来实现继承。这种继承方式的优点是可以继承父类实例中的属性和方法，缺点是无法继承父类原型中的属性和方法。

4.  拷贝继承

拷贝继承是通过将父类实例的属性和方法拷贝到子类实例中来实现继承。这种继承方式的优点是可以避免属性共享的问题，缺点是效率低，且无法继承父类原型中的属性和方法。

5.  组合继承

组合继承是通过原型链继承和构造函数继承相结合来实现继承。这种继承方式的优点是可以继承父类原型中的属性和方法，同时也可以避免属性共享的问题。

6.  寄生组合继承

寄生组合继承是在组合继承的基础上优化而来的一种继承方式，可以避免重复调用父类构造函数。其实现思路是创建一个中间函数，该函数的原型指向父类的原型，再将该函数的实例作为子类的原型。这种继承方式的优点是可以避免属性共享的问题，同时也可以继承父类原型中的属性和方法。

Q:如何解决异步回调地狱

异步回调地狱指的是多个异步操作之间存在嵌套回调函数，导致代码可读性和可维护性变差的情况。为了解决这个问题，可以采用以下几种方式：

1.  使用 Promise：Promise 是 JavaScript 中处理异步操作的一种方式，可以避免嵌套回调的情况。使用 Promise 可以将异步操作分为几个阶段，并在每个阶段之间传递数据，使得代码更易读、更易维护。
    
2.  使用 async/await：async/await 是 ES7 中引入的异步编程解决方案，可以在代码中使用同步的方式来处理异步操作，避免了回调地狱的情况。async/await 的语法简单，使用方便，是解决异步回调地狱的一种常用方法。
    
3.  使用事件发布/订阅模式：事件发布/订阅模式是一种常用的解耦方式，通过将异步操作的结果发布到事件中心，其他需要这些结果的地方可以通过订阅事件的方式来获取数据。这种方式可以减少回调函数的嵌套，提高代码的可维护性。
    
4.  模块化编程：将代码分成多个模块，每个模块处理特定的任务。这种方式可以将异步操作封装在模块中，避免回调地狱的情况。同时，模块化编程可以提高代码的可维护性和可复用性。
    

总之，解决异步回调地狱的关键是将异步操作分离出来，使代码更易读、更易维护。以上几种方式都可以达到这个目的，具体选择哪种方式取决于具体的应用场景和个人偏好。

Q:如何通过 generator 解决回调地狱

通过 Generator 函数可以避免回调地狱，使异步操作像同步操作一样的写法，从而使代码可读性更高，更易于维护。

Generator 函数是 ES6 中新增的一种特殊函数，通过 `yield` 关键字可以将函数执行过程挂起，暂停函数执行，等待下一步操作指令。在遇到异步操作时，可以使用 `yield` 暂停函数执行，等待异步操作的结果，然后再继续执行。

下面是使用 Generator 函数解决回调地狱的示例：

```
function* getUserInfo() {
  try {
    const userId = yield fetch('https://api.example.com/userId');
    const userInfo = yield fetch(`https://api.example.com/user/${userId}`);
    console.log(userInfo);
  } catch (error) {
    console.error(error);
  }
}

const iterator = getUserInfo();
const userIdPromise = iterator.next().value;
userIdPromise.then((userId) => {
  const userInfoPromise = iterator.next(userId).value;
  userInfoPromise.then((userInfo) => {
    iterator.next(userInfo);
  });
});

```

在这个示例中，我们通过 Generator 函数 `getUserInfo` 定义了获取用户信息的操作。使用 `yield` 挂起函数执行，等待异步操作的结果。在主函数中，我们通过获取迭代器对象，并调用 `next` 方法，逐步执行函数体中的操作，直到函数体全部执行完成。

通过使用 Generator 函数，我们可以将异步操作和同步操作融合在一起，使代码更加简洁易读。但是需要注意，使用 Generator 函数并不是万能的解决方案，在某些场景下可能并不适用，需要根据具体情况进行选择。

Q:介绍一下 generator

Generator 是 ES6 中新增的一种函数类型，可以用来控制函数的执行过程，实现函数的暂停和恢复，以及提供一种异步编程的解决方案。

Generator 函数使用 function* 语法声明，使用 yield 关键字返回值，并可以使用 next() 方法来控制函数的执行过程。当遇到 yield 关键字时，Generator 函数会返回一个暂停执行的状态，并将 yield 的值作为状态对象的 value 属性值，当再次调用 next() 方法时，函数会从上次暂停的位置继续执行。

Generator 函数的一个主要应用场景是异步编程。通过使用 Generator 函数和 yield 关键字，可以实现异步代码的同步写法，从而解决回调地狱的问题。同时，由于 Generator 函数可以控制函数的执行过程，也可以用来实现状态机等功能。

除了异步编程和状态机等应用场景，Generator 函数还可以用来实现可迭代对象和迭代器，实现自定义的迭代器行为，以及实现数据流处理等功能。

Q:说说前端中的事件流

前端中的事件流（event flow）是指浏览器中处理事件的流程，包括事件捕获（capture）、目标阶段（target）和事件冒泡（bubble）三个阶段。

事件捕获是指从根节点开始逐级往下，先处理事件的最外层元素，最后到达事件的最终目标元素。目标阶段是指在目标元素上触发事件的阶段。事件冒泡是指从目标元素开始逐级往上，依次处理祖先元素，直到根节点为止。

在事件流中，事件从上往下依次被捕获处理，然后在目标元素上进行处理，最后从下往上冒泡处理。在这个过程中，事件可以被阻止或者取消。

事件流在前端开发中非常重要，因为事件流的不同处理方式可以帮助我们更好地处理和优化事件处理。例如，通过使用事件代理（event delegation），可以在一个父元素上处理所有子元素的事件，减少事件处理的次数，提升性能。

Q:如何让事件先冒泡后捕获

在默认情况下，事件的捕获会先于事件的冒泡发生。如果想要先触发事件的冒泡，然后再触发捕获，可以使用 `addEventListener` 的第三个参数，该参数表示是否在捕获阶段处理事件。

如果该参数为 `true`，则表示在捕获阶段处理事件；如果该参数为 `false` 或者不传递该参数，则表示在冒泡阶段处理事件。

例如，下面的代码中，`div` 元素会先触发点击事件的冒泡，然后再触发捕获：

```
document.querySelector('div').addEventListener('click', function() {
  console.log('bubble');
}, false);

document.querySelector('div').addEventListener('click', function() {
  console.log('capture');
}, true);

```

Q:说一下事件委托

事件委托（Event Delegation）是一种常用的前端开发技巧，它利用了事件冒泡的机制，将事件处理器添加到祖先元素上，以代理处理其子元素的事件。通过这种方式，可以避免在子元素上添加大量的事件处理器，从而提高了性能和代码的可维护性。

事件委托的实现一般有两种方式：

1.  使用 `addEventListener` 方法：在祖先元素上使用 `addEventListener` 方法添加事件处理器，然后在处理器函数中使用 `event.target` 属性获取触发事件的子元素，从而进行相应的处理。

例如，下面的代码中，使用事件委托为列表元素添加了点击事件处理器：

```
// HTML
<ul id="list">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

// JS
document.querySelector('#list').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') {
    console.log('You clicked on:', event.target.textContent);
  }
});

```

2.  使用 on 事件属性：在祖先元素上使用 on 事件属性添加事件处理器，然后在处理器函数中使用 event 对象的 srcElement 属性获取触发事件的子元素，从而进行相应的处理。

例如，下面的代码中，使用事件委托为列表元素添加了点击事件处理器：

```
// HTML
<ul id="list">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

// JS
document.getElementById('list').onclick = function(event) {
  event = event || window.event;
  var target = event.target || event.srcElement;
  if (target.tagName === 'LI') {
    console.log('You clicked on:', target.textContent);
  }
};

```

需要注意的是，在使用事件委托时，要根据具体场景选择合适的祖先元素和事件类型，并确保处理器函数能正确处理所有可能的子元素的事件。同时，事件委托也不是适用于所有情况的解决方案，需要根据具体的业务需求和性能优化考虑是否使用事件委托。

Q:说一下图片的懒加载和预加载

图片的懒加载和预加载都是前端优化常用的技术。

图片的懒加载指的是在页面加载时，先不加载所有图片，而是在用户滚动到需要加载的图片时，再进行图片的加载，从而优化了页面加载速度。常用的实现方法是将图片的真实地址保存在自定义属性中，等到图片进入可视区域时再将图片的真实地址赋值给 src 属性，从而实现图片的加载。

图片的预加载指的是在页面加载时，提前将需要加载的图片资源预先加载到缓存中，以便在需要时能够快速加载，从而优化了用户的体验。常用的实现方法是使用 Image 对象预加载图片资源，一般在页面加载时使用 JavaScript 预加载。

需要注意的是，在使用图片的懒加载和预加载时，要注意页面性能的影响，避免过度预加载或者懒加载导致页面性能下降。

Q:mouseover 和 mouseenter 的区别

`mouseover` 和 `mouseenter` 都是鼠标移入事件，但是它们的触发时机和冒泡机制略有不同：

*   `mouseover` 事件在鼠标指针移入元素或其子元素时触发，会冒泡。也就是说，如果鼠标移入了子元素，那么该元素和其父元素都会触发 `mouseover` 事件。
    
*   `mouseenter` 事件在鼠标指针移入元素时触发，不会冒泡。也就是说，如果鼠标移入了子元素，那么只有该子元素会触发 `mouseenter` 事件，其父元素不会触发。
    

因此，使用 `mouseenter` 事件可以避免一些不必要的冒泡行为，比如鼠标移入一个有多个子元素的父元素时，只想触发子元素的特定行为而不是父元素的行为。

但需要注意的是，`mouseover` 和 `mouseenter` 的事件属性不同，需要根据实际需求进行选择。

Q:new 操作符做了哪些事情

在 JavaScript 中，`new` 操作符用于创建一个新对象，并将这个对象的原型指向构造函数的原型，然后将构造函数的作用域赋给这个新对象（因此 `this` 就指向了这个新对象），最后返回这个新对象。

具体来说，`new` 操作符做了以下几件事情：

1.  创建一个新的空对象。
2.  将这个新对象的原型指向构造函数的 `prototype` 属性。
3.  将构造函数的作用域赋给新对象，即将 `this` 指向新对象。
4.  执行构造函数中的代码，为新对象添加属性和方法。
5.  返回这个新对象（如果构造函数有返回值且返回值为对象，则返回该对象；否则返回新对象）。

举个例子，下面是一个使用 `new` 操作符创建对象的示例：

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
};

const person = new Person('Alice', 20);
person.sayHello(); // Hello, my name is Alice and I'm 20 years old.

```

在这个例子中，`new` 操作符创建了一个新对象 `person`，并将这个对象的原型指向 `Person.prototype`，然后将 `Person` 函数的作用域赋给这个新对象，最后执行 `Person` 函数中的代码，将 `name` 和 `age` 属性添加到新对象中。最终，`new` 操作符返回这个新对象 `person`，使我们可以调用 `sayHello` 方法。

Q:改变函数内部 this 指针的指向函数（bind，apply，call 的区别）

在 JavaScript 中，函数的 `this` 指向调用该函数的对象。但有时候我们希望函数的 `this` 指向特定的对象，这时候可以使用 `bind`、`apply`、`call` 等方法来改变函数内部的 `this` 指向。

*   `bind` 方法：该方法会创建一个新的函数，并将其 `this` 值绑定到指定的对象上。`bind` 方法不会立即调用函数，而是返回一个新函数，需要手动调用该函数才能执行原函数。
    
    ```
    javascriptCopy code``const obj = {name: 'Alice'}
    function sayHi() {
      console.log(`Hi, ${this.name}!`)
    }
    const sayHiToAlice = sayHi.bind(obj)
    sayHiToAlice() // Hi, Alice!`` 
    ```
    
*   `apply` 和 `call` 方法：这两个方法可以改变函数的 `this` 值，并立即调用函数。它们的第一个参数都是指定的 `this` 值，第二个参数及之后的参数不同，`apply` 方法接受一个数组作为参数，`call` 方法接受若干个参数。
    
    ```
    javascriptCopy code``const obj1 = {name: 'Alice'}
    const obj2 = {name: 'Bob'}
    function sayHi(greeting) {
      console.log(`${greeting}, ${this.name}!`)
    }
    sayHi.apply(obj1, ['Hello']) // Hello, Alice!
    sayHi.call(obj2, 'Hi') // Hi, Bob!`` 
    ```
    

区别：

*   `bind` 方法会返回一个新函数，需要手动调用该函数才能执行原函数；而 `apply` 和 `call` 方法会立即调用函数，并改变其 `this` 值。
*   `apply` 和 `call` 方法的参数可以是数组或者单个参数，而 `bind` 方法只能接受单个参数。

Q:JS 拖拽功能的实现

实现 JS 拖拽功能需要用到 HTML5 的拖放 API，主要有以下几个步骤：

1.  给拖动的元素绑定 dragstart 事件，该事件在元素开始被拖动时触发。
2.  在 dragstart 事件中设置数据传输，通常通过 event.dataTransfer 对象来设置传输数据。
3.  给目标元素绑定 dragover 事件，该事件在拖动元素经过目标元素时触发。
4.  在 dragover 事件中阻止默认行为，通常需要通过 event.preventDefault() 来阻止浏览器默认处理拖拽事件。
5.  在 dragover 事件中设置反馈，通常需要通过 event.dataTransfer.dropEffect 属性来设置反馈效果。
6.  给目标元素绑定 drop 事件，该事件在拖动元素在目标元素上松开鼠标时触发。
7.  在 drop 事件中获取传输数据，通常需要通过 event.dataTransfer.getData() 方法来获取传输的数据。

在以上步骤中，dragstart、dragover 和 drop 事件是拖放操作的核心事件，需要注意以下几点：

1.  dragstart 事件中需要设置 dataTransfer 数据传输对象，可以通过 setData() 方法设置传输的数据。
2.  dragover 事件中需要阻止默认行为，以便实现拖放操作。
3.  dragover 事件中可以设置反馈效果，通常通过设置 dataTransfer.dropEffect 属性来实现。
4.  drop 事件中需要获取传输的数据，可以通过 getData() 方法获取。

另外，使用 HTML5 拖放 API 实现拖拽功能时，需要注意浏览器兼容性问题。不同浏览器可能会有不同的 API 实现，需要进行兼容性处理。

Q:异步加载 JS 的方法

异步加载 JavaScript 是一种优化网页加载速度的方法。以下是几种异步加载 JavaScript 的方法：

1.  动态创建 script 标签 使用 JavaScript 动态创建 script 标签，并将其插入到文档中。可以设置 script 标签的 src 属性来指定需要加载的 JavaScript 文件的 URL。这种方法可以异步加载 JavaScript，但是需要手动处理加载成功或失败后的回调函数。

```
let script = document.createElement('script');
script.src = 'path/to/script.js';
document.body.appendChild(script);

```

2.  使用 async 属性 HTML5 引入了 async 属性，可以让浏览器在下载 JavaScript 文件的同时继续渲染页面。当浏览器下载完成 JavaScript 文件后，会立即执行该文件。注意，使用 async 属性加载的 JavaScript 文件不能保证执行顺序，因此如果需要保证执行顺序，建议使用 defer 属性。

```
<script async src="path/to/script.js"></script>

```

3.  使用 defer 属性 与 async 属性类似，defer 属性也可以异步加载 JavaScript 文件，但是它可以保证 JavaScript 文件的执行顺序。浏览器会在页面解析完毕后按照顺序执行 defer 属性指定的 JavaScript 文件。

```
<script defer src="path/to/script.js"></script>

```

4.  使用模块化加载器 使用模块化加载器（如 RequireJS、SystemJS 等）可以让 JavaScript 代码更加模块化，从而更好地管理和优化 JavaScript 代码的加载和执行。模块化加载器会在需要时异步加载 JavaScript 文件，从而提高页面加载速度。需要注意的是，模块化加载器需要进行额外的配置和使用，因此不适用于简单的小型项目。

Q:Ajax 解决浏览器缓存问题

在使用 Ajax 请求数据时，由于浏览器的缓存机制，可能会导致请求到的数据并不是最新的。解决这个问题有以下几种方法：

1.  添加时间戳或随机数：在请求 URL 后面添加一个不同的时间戳或随机数，这样每次请求的 URL 都不同，浏览器就不会使用缓存的数据了。
    
2.  设置请求头：可以通过设置请求头来告诉浏览器不要使用缓存的数据。例如，可以设置 `Cache-Control`、`Pragma`、`Expires` 等头部信息。
    
3.  使用 POST 请求：由于 GET 请求会被浏览器缓存，所以可以使用 POST 请求来避免缓存问题。
    
4.  使用缓存控制：可以在服务器端对响应进行缓存控制，例如设置响应头部的 `Cache-Control`，`Expires` 等字段来告诉浏览器是否需要缓存数据，以及缓存多长时间。
    

需要注意的是，以上方法并不是每个情况都适用，需要根据具体的业务场景和需求来选择合适的方法。

Q:JS 的节流和防抖

JS 中的节流和防抖是优化高频触发事件的常用技巧。

节流（throttle）是指一定时间间隔内只执行一次任务，比如在滚动条滚动过程中，如果每一次滚动都会触发一次事件的执行，那么会占用很多的浏览器资源，导致性能下降，使用节流可以避免这种情况的发生。

防抖（debounce）是指一定时间间隔内只执行最后一次任务，比如在用户连续输入时，每输入一个字符就要触发一次请求，这样会对服务器造成很大的压力，使用防抖可以避免这种情况的发生。

以下是一些简单的实现示例：

节流的实现：

```
function throttle(fn, wait) {
  let timer = null;
  return function() {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, arguments);
        timer = null;
      }, wait);
    }
  }
}

```

防抖的实现：

```
function debounce(fn, delay) {
  let timer = null;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, delay);
  }
}

```

需要注意的是，以上实现是基本的节流和防抖，如果需要更加复杂的应用，可以根据实际情况进行调整和优化。

Q:JS 中的垃圾回收机制

JavaScript 中的垃圾回收是自动进行的，即不需要手动去回收垃圾。垃圾回收的机制是在运行时动态分配和管理内存。在 JavaScript 中，当某个值不再被引用时，它就会被标记为垃圾，并在垃圾回收器运行时被清除。

垃圾回收器有多种实现方式，其中最常用的方式是基于引用计数和标记清除。引用计数指的是在 JavaScript 中每当一个对象被引用时，它的引用计数加 1，当引用该对象的变量被赋值为其他值或者离开作用域时，该对象的引用计数减 1。当对象的引用计数为 0 时，就会被标记为垃圾，等待垃圾回收器清除。但是，引用计数机制容易出现循环引用的情况，导致无法回收垃圾，因此现代浏览器一般采用标记清除的机制，即在回收垃圾时，先将所有当前可达对象标记，然后将没有被标记的对象清除。

JavaScript 中的垃圾回收器通常是在后台运行的，并根据需要自动进行垃圾回收。但是，在某些情况下，我们需要手动触发垃圾回收，例如在内存占用较高的时候，可以通过调用 `window.gc()` 函数手动触发垃圾回收。但是，不建议在生产环境中过度使用这个函数，因为它可能会导致性能问题。

Q:eval 是做什么的，分析它的优劣

`eval()` 函数是 JavaScript 中的一个内置函数，它接受一个字符串作为参数，并将其解析为代码执行。它可以执行任何代码，包括修改变量、创建函数、甚至是执行任意的系统命令。因此，使用 `eval()` 函数时需要非常小心，以避免安全风险。

下面是 `eval()` 函数的优点和缺点：

优点：

*   `eval()` 函数非常灵活，可以解析和执行任何 JavaScript 代码。
*   在某些情况下，使用 `eval()` 函数可以更方便地实现某些功能，比如动态地创建函数和变量名等。

缺点：

*   `eval()` 函数会将字符串转换为代码执行，因此会增加代码的执行时间和内存开销。
*   `eval()` 函数会将执行权限交给了字符串中的代码，因此存在安全风险，恶意代码可能会被注入并执行。
*   `eval()` 函数不利于代码的可读性和可维护性，因为它会将代码打散在不同的地方，使得代码逻辑难以理解和修改。

综上所述，尽量避免使用 `eval()` 函数，除非确实有必要，并且需要谨慎处理输入的字符串，确保它是安全的。

Q:如何理解前端模块化

前端模块化是指将前端代码按照一定的规则划分成独立的模块，模块之间可以相互依赖、引用和调用。前端模块化的目的是为了让代码更加可维护、可重用、可扩展。

在过去，前端代码通常都是以文件为单位进行组织，不同的文件之间存在大量的全局变量和函数调用。这样的代码结构不仅难以维护，也难以重用和扩展。

前端模块化通过将代码划分为独立的模块，避免了全局变量和函数调用的污染，使得代码更加可维护和可重用。同时，前端模块化还能够提供更好的代码管理和版本控制。

常见的前端模块化方案包括：

1.  CommonJS：Node.js 的模块化方案，通过 require 和 module.exports 实现模块的导入和导出。
2.  AMD：异步模块定义，通过 define 和 require 实现模块的异步加载。
3.  ES6 模块化：ES6 中新增的模块化方案，通过 import 和 export 实现模块的导入和导出。

不同的模块化方案有不同的实现方式和特点，开发者可以根据项目的具体需求选择合适的模块化方案。

Q:说一下 CommonJS、AMD 和 CMD

CommonJS、AMD和CMD都是前端模块化的标准，它们的实现方式和使用方法有所不同。

CommonJS是Node.js所采用的模块规范，它使用`require()`和`exports`来定义和导出模块。模块中的代码会被执行，模块中的变量、函数等都只属于模块自身。

AMD（Asynchronous Module Definition）是异步模块定义，它可以在页面加载的同时异步加载模块，不阻塞页面的加载速度。AMD使用的是`define()`来定义模块，使用`require()`来异步加载模块。

CMD（Common Module Definition）也是异步模块定义，它与AMD类似，使用`define()`来定义模块，但在加载模块时会一次性加载完全部依赖，不会异步加载。

三种模块化规范各有优劣，CommonJS适合服务器端的模块加载，AMD和CMD适合浏览器端的模块加载，具体选择哪种方式需要根据具体的项目需求来决定。

Q:对象深度克隆的简单实现

实现对象深度克隆的一种简单方法是使用 JSON 对象的 `stringify` 和 `parse` 方法。这种方法可以将一个 JavaScript 对象序列化成一个 JSON 字符串，然后再将 JSON 字符串解析成一个新的对象，达到深度克隆的效果。

具体实现方法如下：

```
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

```

该方法的缺点是不能处理一些特殊的数据类型，如函数、RegExp 对象等，因为 JSON 不支持这些数据类型的序列化。此外，该方法还可能存在一些性能问题，因为它需要进行序列化和解析操作，对于复杂的对象可能会比较耗时。

Q:提出几种对象深度克隆的简单实现

以下是几种对象深度克隆的简单实现方式：

1.  使用 JSON 序列化和反序列化

```
let obj = {a: 1, b: [1, 2, 3]};
let newObj = JSON.parse(JSON.stringify(obj));

```

这种方法可以对大部分常规的对象进行深度克隆，但是对于函数、RegExp 等对象会有问题，而且会忽略掉对象的 constructor、prototype、undefined 等属性。

2.  递归实现

```
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  let newObj = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    newObj[key] = deepClone(obj[key]);
  }
  return newObj;
}

```

这种方法适用于大部分对象，但是对于函数等特殊对象会出现问题。

3.  利用 ES6 提供的 Map 数据结构

```
function deepClone(obj, hash = new Map()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  let newObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, newObj);
  Object.keys(obj).forEach(key => {
    newObj[key] = deepClone(obj[key], hash);
  });
  return newObj;
}

```

这种方法可以对所有对象进行深度克隆，包括函数等特殊对象。但是需要注意的是，如果对象中包含循环引用，会出现死循环，因此需要用 Map 数据结构记录已经克隆过的对象，防止重复克隆和死循环。

Q:实现一个 once 函数，传入函数参数只执行一次

可以通过闭包来实现一个 once 函数，保证传入的函数只被执行一次。代码如下：

```
function once(fn) {
  let executed = false;
  return function(...args) {
    if (!executed) {
      executed = true;
      return fn.apply(this, args);
    }
  };
}

```

这个函数返回了一个新的函数，利用了闭包的特性来保存一个 `executed` 变量，表示传入的函数是否被执行过。当返回的新函数被执行时，首先检查 `executed` 是否为 `true`，如果为 `true`，则说明传入的函数已经被执行过，直接返回 `undefined`，否则将 `executed` 设置为 `true`，并执行传入的函数并返回执行结果。这样保证了传入的函数只被执行一次。

Q:将原生的 ajax 封装成 promise

将原生的 AJAX 封装成 Promise 可以提高代码的可读性和可维护性，以下是一个简单的实现示例：

```
function ajax(method, url, data) {
  return new Promise(function(resolve, reject) {
    const xhr = new XMLHttpRequest();
    xhr.open(method, url, true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(xhr.responseText);
        } else {
          reject(new Error(xhr.statusText));
        }
      }
    };
    xhr.onerror = function() {
      reject(new Error("Network Error"));
    };
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.send(data);
  });
}

```

以上代码封装了一个 `ajax` 函数，接受三个参数：请求方法、请求 URL 和请求数据。返回一个 Promise 对象，当请求成功时，调用 `resolve` 方法，将响应文本作为参数传递给 `resolve`；当请求失败时，调用 `reject` 方法，将 `XMLHttpRequest` 对象的 `statusText` 属性作为错误信息传递给 `reject`。

这个封装可以让我们更加方便地使用 AJAX，比如：

```
ajax("GET", "/api/data")
  .then(function(response) {
    console.log(response);
  })
  .catch(function(error) {
    console.error(error);
  });

```

Q:接着上一条回答的末尾“这个封装可以让我们更加方便地使用 AJAX，比如：”讲

这个封装可以让我们更加方便地使用 AJAX，比如：

1.  更加简洁：使用 Promise 对象可以将 AJAX 的回调函数写成链式结构，减少了嵌套层数，使代码更加简洁易懂。
    
2.  更加可控：使用 Promise 对象可以更好地控制 AJAX 请求的状态，可以轻松地处理请求成功、请求失败、请求超时等情况。
    
3.  更加灵活：使用 Promise 对象可以很方便地进行扩展，比如增加请求超时、请求重试等功能，让 AJAX 请求更加灵活。
    
4.  更加规范：使用 Promise 对象可以让代码更加规范，符合现代 JavaScript 的编程风格，使代码更易于维护和扩展。
    

Q:JS 监听对象属性的改变

在 JavaScript 中，可以使用 `Object.defineProperty` 方法来监听对象属性的改变。

`Object.defineProperty` 方法接收三个参数：

1.  要监听的对象。
2.  要监听的属性名。
3.  描述符对象，包括 `get` 和 `set` 两个属性。

例如，我们可以创建一个对象 `person`，并使用 `Object.defineProperty` 来监听其 `name` 属性的改变：

```
const person = {
  name: 'Alice',
  age: 20
};

Object.defineProperty(person, 'name', {
  get() {
    console.log('get name');
    return this._name;
  },
  set(value) {
    console.log('set name');
    this._name = value;
  }
});

person.name = 'Bob';
console.log(person.name);

```

运行上述代码会输出：

```
set name
get name
Bob

```

当我们给 `person` 对象的 `name` 属性赋值时，会触发 `set` 函数，从而输出 `'set name'`。当我们读取 `person` 对象的 `name` 属性时，会触发 `get` 函数，从而输出 `'get name'`。最后输出 `'Bob'`，说明属性值已经被改变。

这种方法可以用来监听对象属性的改变，并在属性值被改变时执行一些特定的操作。

Q:如何实现一个私有变量，用 getName 方法可以访问，不能直接访问

在 JavaScript 中，由于没有内置的访问修饰符，所以要实现私有变量，需要利用闭包的特性。

可以通过在一个函数内部定义一个变量，然后返回一个具有访问该变量的函数的对象。这样，外部代码就无法直接访问该变量，只能通过该对象提供的访问方法来访问该变量。

下面是一个简单的示例代码：

```
function Person(name) {
  var _name = name; // 定义私有变量

  this.getName = function() {
    return _name;
  };
}

var person = new Person("张三");
console.log(person.getName()); // 输出：张三
console.log(person._name); // 输出：undefined

```

在上面的代码中，Person 函数中定义了一个私有变量 `_name`，并在该函数中返回了一个具有访问该变量的方法 `getName` 的对象。外部代码可以通过调用该对象的 `getName` 方法来访问私有变量 `_name`，而无法直接访问该变量。

需要注意的是，在使用闭包实现私有变量时，每次创建对象都会创建一个新的访问方法，因此可能会造成一定的性能问题。

Q:==和===、以及 Object.is 的区别

JavaScript 中有三种比较相等的方法：

1.  `==` 相等运算符（loose equality operator）：会进行类型转换再进行比较。
2.  `===` 严格相等运算符（strict equality operator）：不会进行类型转换，只有在两个操作数的类型相同且值相等时才返回 true。
3.  `Object.is` 方法：用于比较两个值是否严格相等，与 `===` 不同的是，`Object.is` 认为 `NaN` 等于自身，认为 `-0` 不等于 `+0`。

例如：

```
console.log(1 == "1"); // true，因为 "1" 被转换为数字 1
console.log(1 === "1"); // false，类型不同
console.log(Object.is(NaN, NaN)); // true
console.log(Object.is(-0, +0)); // false

```

需要注意的是，由于 `==` 和 `===` 的区别可能会导致一些奇怪的行为，因此建议在比较相等性时始终使用 `===`，除非你明确知道 `==` 的行为是你需要的。而 `Object.is` 则可以用于比较两个值是否严格相等，特别是在处理特殊值时可以更加准确。

Q:setTimeout、setInterval 和 requestAnimationFrame 之间的联系与区别

`setTimeout`、`setInterval` 和 `requestAnimationFrame` 都是 JavaScript 提供的用于进行定时循环操作的方法，它们之间有以下联系和区别：

联系：

1.  它们都可以周期性地执行某个函数。
2.  它们都可以通过返回的句柄来取消定时操作。

区别：

1.  `setTimeout` 和 `setInterval` 的精度是受限的，它们的时间间隔不能保证准确无误，而 `requestAnimationFrame` 的精度较高，是根据浏览器刷新频率决定的。
2.  `setTimeout` 和 `setInterval` 会受到页面是否被激活的影响，而 `requestAnimationFrame` 不会受到这种影响。
3.  `setTimeout` 和 `setInterval` 会在指定的时间间隔之后立即执行，而 `requestAnimationFrame` 会在浏览器下一次绘制时执行，可以避免一些不必要的计算。

因此，在动画、游戏等对时间精度要求较高的场景中，建议使用 `requestAnimationFrame`，而在一些简单的定时循环操作中可以使用 `setTimeout` 和 `setInterval`。

Q:实现一个两列等高布局，讲讲思路

实现两列等高布局的一种思路是使用 flex 布局。具体实现步骤如下：

1.  父元素设置 display: flex，使其成为一个 flex 容器。
2.  设置两个子元素的宽度，并将它们的 display 属性设置为 flex。
3.  将两个子元素的 flex 属性都设置为 1，使它们占据相同的空间。
4.  子元素内部的内容如果撑开高度，则两列的高度会相等。

示例代码如下：

HTML 代码：

```
<div class="container">
  <div class="left">左侧内容</div>
  <div class="right">右侧内容</div>
</div>

```

CSS 代码：

```
.container {
  display: flex;
}

.left, .right {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.left {
  width: 50%;
  background-color: #f0f0f0;
}

.right {
  width: 50%;
  background-color: #d9d9d9;
}

```

该实现方式的优点是简单易懂，不需要使用复杂的计算和布局技巧，能够在大多数浏览器中正常工作。缺点是如果两列中的内容高度不一致，会出现高度不相等的情况。此外，如果需要支持 IE11 及以下版本的浏览器，还需要使用 -ms- 前缀和旧版 flexbox 语法。

Q:自己实现一个 bind 函数

bind 是用于绑定函数中 this 指向的方法，可以手写实现如下：

```
Function.prototype.bind = function(context) {
  var fn = this;
  var args = Array.prototype.slice.call(arguments, 1);

  function boundFn() {
    var boundArgs = Array.prototype.slice.call(arguments);
    fn.apply(this instanceof boundFn ? this : context, args.concat(boundArgs));
  }

  boundFn.prototype = Object.create(fn.prototype);
  return boundFn;
};

```

这个实现首先保存了原始函数的引用，然后使用 Array.prototype.slice.call 将参数列表转化为数组，并且使用 apply 方法将原始函数在指定的上下文中执行。此外，我们还在返回函数的 prototype 属性中创建一个与原始函数相同的原型链。

Q:用 setTimeout 来实现 setInterval，这样的优劣是什么？

在使用 `setTimeout` 来模拟 `setInterval` 时，每个计时器都会在执行后重新创建一个新的计时器。这会导致一些问题，例如当代码执行时间超过设定的时间间隔时，会出现两个或多个函数同时执行的情况。此外，如果计时器的执行时间比间隔时间要长，那么后续计时器的间隔时间也会被延长。

相比之下，`setInterval` 会在每次执行完当前函数之后，等待设定的时间间隔后再次执行，而不会重新创建一个新的计时器，这样能够更加准确和可靠地执行函数。

因此，一般来说使用 `setInterval` 会比使用 `setTimeout` 来模拟 `setInterval` 更好。不过，也要注意在使用 `setInterval` 时，要考虑到函数执行时间可能超过设定的时间间隔，以及函数执行时间不确定的情况，需要进行相应的处理和优化。

Q:用 setTimeout 来实现 setInterval

可以通过在 setTimeout 回调函数内再次调用 setTimeout 来模拟 setInterval 的效果。

具体实现方法是，在 setTimeout 回调函数内部再次调用 setTimeout，并将递归调用的 setTimeout 函数的引用存储到一个变量中，以便之后清除定时器。

下面是一个示例代码：

```
function mySetInterval(callback, interval) {
  let timer = setTimeout(function tick() {
    callback();
    timer = setTimeout(tick, interval);
  }, interval);
  return {
    clear() {
      clearTimeout(timer);
    }
  };
}

```

该函数接受两个参数：回调函数和时间间隔。它会返回一个对象，其中包含一个 `clear` 方法，用于清除定时器。

使用示例：

```
const interval = mySetInterval(() => {
  console.log('Hello, world!');
}, 1000);

// 5 秒后清除定时器
setTimeout(() => {
  interval.clear();
}, 5000);

```

这种实现方式相比于使用 setInterval 的优点是，可以更灵活地控制定时器，可以动态调整时间间隔或者随时清除定时器。同时也可以避免 setInterval 的一些问题，比如可能出现的性能问题。

Q:JS 怎么控制一次加载一张图片，加载完后再加载下一张

实现一次只加载一张图片，可以使用递归调用的方式，每次加载完一张图片后再加载下一张，直到所有图片都加载完成。具体实现如下：

首先，创建一个图片数组，存储需要加载的图片路径：

```
var imgList = [
  'img1.png',
  'img2.png',
  'img3.png',
  // ...
];

```

然后，定义一个变量 `i`，用于记录当前需要加载的图片索引：

```
var i = 0;

```

接下来，定义一个 `loadImage` 函数，用于加载一张图片，该函数接受一个图片路径作为参数，并返回一个 Promise 对象，表示图片加载完成后的状态：

```
function loadImage(url) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      resolve(img);
    };
    img.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };
    img.src = url;
  });
}

```

最后，定义一个递归函数 `loadImages`，用于逐个加载图片。该函数首先判断当前需要加载的图片索引 `i` 是否超过了图片数组的长度，如果超过了，则表示所有图片都已经加载完成，直接返回。否则，调用 `loadImage` 函数加载当前索引对应的图片，并在加载完成后递归调用 `loadImages` 函数加载下一张图片：

```
function loadImages() {
  if (i >= imgList.length) {
    return;
  }
  loadImage(imgList[i])
    .then(function(img) {
      // 图片加载完成后的操作
      console.log('Loaded image ' + i + ': ' + img.src);
      i++;
      loadImages(); // 递归调用加载下一张图片
    })
    .catch(function(error) {
      console.log(error);
    });
}

```

最后，调用 `loadImages` 函数开始加载图片：

```
loadImages();

```

这样就实现了一次只加载一张图片，加载完后再加载下一张的功能。

Q:如何实现 sleep 的效果

在 JavaScript 中没有直接提供 `sleep` 函数，但可以使用 `setTimeout` 或 `Promise` 来实现相似的效果。

使用 `setTimeout` 可以延迟一定的时间执行指定的代码，可以通过循环调用 `setTimeout` 实现 `sleep` 的效果。

下面是一个使用 `setTimeout` 实现 `sleep` 函数的示例：

```
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function run() {
  console.log('start');
  await sleep(2000);
  console.log('end');
}

run();

```

使用 `Promise` 可以创建一个等待一定时间后返回结果的 Promise 对象，可以通过调用 `Promise` 对象的 `then` 方法来处理结果。

下面是一个使用 `Promise` 实现 `sleep` 函数的示例：

```
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function run() {
  console.log('start');
  await sleep(2000);
  console.log('end');
}

run();

```

以上两种方式都可以达到类似 `sleep` 的效果，可以根据具体的使用场景选择其中的一种实现方式。

Q:简单的实现一个 promise

以下是一个简单的实现 promise 的示例代码：

```
class MyPromise {
  constructor(executor) {
    this.status = 'pending';
    this.value = null;
    this.callbacks = [];

    const resolve = (value) => {
      if (this.status === 'pending') {
        this.status = 'fulfilled';
        this.value = value;
        this.callbacks.forEach((callback) => callback.onFulfilled(value));
      }
    };

    const reject = (reason) => {
      if (this.status === 'pending') {
        this.status = 'rejected';
        this.value = reason;
        this.callbacks.forEach((callback) => callback.onRejected(reason));
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function') {
      onFulfilled = (value) => value;
    }

    if (typeof onRejected !== 'function') {
      onRejected = (reason) => {
        throw reason;
      };
    }

    return new MyPromise((resolve, reject) => {
      const handleCallback = (callback) => {
        try {
          const result = callback(this.value);
          if (result instanceof MyPromise) {
            result.then(resolve, reject);
          } else {
            resolve(result);
          }
        } catch (error) {
          reject(error);
        }
      };

      if (this.status === 'pending') {
        this.callbacks.push({
          onFulfilled: (value) => {
            handleCallback(onFulfilled);
          },
          onRejected: (reason) => {
            handleCallback(onRejected);
          },
        });
      } else if (this.status === 'fulfilled') {
        setTimeout(() => {
          handleCallback(onFulfilled);
        }, 0);
      } else if (this.status === 'rejected') {
        setTimeout(() => {
          handleCallback(onRejected);
        }, 0);
      }
    });
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }

  static resolve(value) {
    return new MyPromise((resolve) => {
      resolve(value);
    });
  }

  static reject(reason) {
    return new MyPromise((resolve, reject) => {
      reject(reason);
    });
  }

  static all(promises) {
    return new MyPromise((resolve, reject) => {
      const results = new Array(promises.length);
      let count = 0;

      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(
          (value) => {
            results[index] = value;
            count++;

            if (count === promises.length) {
              resolve(results);
            }
          },
          (reason) => {
            reject(reason);
          }
        );
      });
    });
  }

  static race(promises) {
    return new MyPromise((resolve, reject) => {
      promises.forEach((promise) => {
        MyPromise.resolve(promise).then(resolve, reject);
      });
    });
  }
}

```

这是一个比较简单的实现，仅供参考。在此实现中，promise 的构造函数接受一个 executor 函数作为参数，该函数会立即执行，传入两个函数参数 resolve 和 reject，分别表示 promise 的成功和失败。

then 方法用于注册回调函数，当 promise 状态变为 fulfilled 时调用 onFulfilled 函数，当 promise 状态变为 rejected 时调用 onRejected 函数。同时，then 方法返回一个新的 promise 对象，使得

Q:接着上一条回答的末尾 “同时，then 方法返回一个新的 promise 对象，使得” 讲

then 方法返回一个新的 Promise 对象，它的状态和值取决于回调函数的返回值，具体有以下几种情况：

1.  回调函数返回一个非 Promise 的值，新的 Promise 对象的状态为 resolved，值为这个非 Promise 的值。
2.  回调函数返回一个 Promise 对象，新的 Promise 对象的状态和值都取决于这个 Promise 对象。
3.  回调函数抛出一个异常，新的 Promise 对象的状态为 rejected，值为这个异常对象。

由于 Promise 的 then 方法返回的是一个新的 Promise 对象，所以可以通过链式调用 then 方法，把多个异步操作串联起来，形成一个 Promise 链，以实现更复杂的异步操作。

Q:Object.getPrototypeOf() 是什么

`Object.getPrototypeOf()` 是一个获取对象原型的方法，它返回指定对象的原型。它可以被用于取代 `__proto__` 属性，后者在 ES6 中被认为是已废弃的。

示例：

```
const obj = {};
const proto = { a: 1 };
Object.setPrototypeOf(obj, proto);

console.log(Object.getPrototypeOf(obj) === proto); // true
console.log(obj.__proto__ === proto); // true，已废弃

```

在上面的示例中，`Object.setPrototypeOf()` 被用于将 `obj` 的原型设置为 `proto`，`Object.getPrototypeOf()` 用于获取 `obj` 的原型，其值为 `proto`。同时，`__proto__` 属性也被用于获取 `obj` 的原型，但它已经被废弃了。

Q:实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正则对象）

实现 JS 中所有对象的深度克隆需要对不同类型的对象进行不同的处理，下面是一个实现示例：

```
function deepClone(obj) {
  // 判断是否是对象或者数组
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  
  let clone = null;
  
  // 判断是否是 Date 对象
  if (obj instanceof Date) {
    clone = new Date(obj.getTime());
    return clone;
  }
  
  // 判断是否是正则表达式对象
  if (obj instanceof RegExp) {
    clone = new RegExp(obj);
    return clone;
  }
  
  // 判断是否是 DOM 元素对象
  if (obj.nodeType && typeof obj.cloneNode === 'function') {
    clone = obj.cloneNode(true);
    return clone;
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    clone = [];
    for (let i = 0; i < obj.length; i++) {
      clone[i] = deepClone(obj[i]);
    }
    return clone;
  }
  
  // 处理对象
  clone = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key]);
    }
  }
  
  return clone;
}

```

需要注意的是，在处理对象时，要使用 `hasOwnProperty()` 方法来判断对象自身是否包含该属性，以防止因为对象原型链上的属性造成重复克隆或者丢失属性。

Q:简单实现 Node 的 Events 模块

Node.js 的 Events 模块提供了一种处理事件的机制，可以让我们在编写代码时更加方便地处理异步事件。下面是一个简单实现 Node 的 Events 模块的例子：

```
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
  }

  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach(listener => {
        listener.apply(this, args);
      });
    }
  }

  removeListener(event, listenerToRemove) {
    if (!this.events[event]) {
      return;
    }
    this.events[event] = this.events[event].filter(listener => {
      return listener !== listenerToRemove;
    });
  }

  once(event, listener) {
    const wrapper = (...args) => {
      listener.apply(this, args);
      this.removeListener(event, wrapper);
    };
    this.on(event, wrapper);
  }
}

```

这个简单的实现提供了 `on`、`emit`、`removeListener`、`once` 四个方法，分别用于绑定事件、触发事件、删除事件监听器和一次性事件监听器。

在这个实现中，使用一个对象 `events` 来存储事件和它对应的监听器。在 `on` 方法中，如果事件不存在，就创建一个新的数组来存储监听器；如果事件已经存在，就将监听器添加到已有的数组中。

在 `emit` 方法中，首先检查事件是否存在，如果存在，就遍历事件对应的监听器数组，依次调用监听器。

在 `removeListener` 方法中，首先检查事件是否存在，如果存在，就使用 `filter` 方法从事件对应的监听器数组中删除指定的监听器。

在 `once` 方法中，创建一个包装器函数，在调用一次监听器后，从事件对应的监听器数组中删除这个包装器函数。

这样就实现了一个简单的 Events 模块。

Q:讲一讲箭头函数中 this 指向，并举例说明

箭头函数中的 this 指向在函数定义时就已经确定，它不会因为函数调用的不同而改变指向。通常情况下，箭头函数的 this 指向父级作用域中的 this 值。如果箭头函数在全局作用域中定义，它的 this 指向全局对象（即 window 对象）。

举例来说，假设有一个对象 person，它有一个 name 属性和一个 sayName 方法：

```
const person = {
  name: 'Alice',
  sayName() {
    console.log(this.name);
  }
}

```

如果我们使用普通函数来定义 sayName 方法，那么它的 this 指向将会是运行时对象，即 person 对象：

```
const person = {
  name: 'Alice',
  sayName: function() {
    console.log(this.name);
  }
}

person.sayName(); // 输出 "Alice"

```

但如果我们使用箭头函数来定义 sayName 方法，那么它的 this 指向将会是父级作用域中的 this 值，即全局对象：

```
const person = {
  name: 'Alice',
  sayName: () => {
    console.log(this.name);
  }
}

person.sayName(); // 输出 undefined

```

上述代码中，箭头函数的 this 指向全局对象，因为它是在全局作用域中定义的。由于全局对象没有 name 属性，因此输出 undefined。

需要注意的是，在某些情况下，箭头函数中的 this 指向并不是父级作用域中的 this 值。比如在使用 bind、apply、call 方法绑定 this 值时，箭头函数中的 this 指向仍然会被改变。

Q:讲几种JS 判断类型的方法

JS 中判断类型的方法有很多种，以下是几种常用的方法：

1.  typeof 运算符

typeof 运算符可以判断大部分基本类型和函数类型，返回值为字符串，比如：

```
console.log(typeof 'hello'); // 输出：string
console.log(typeof 123); // 输出：number
console.log(typeof true); // 输出：boolean
console.log(typeof function(){}); // 输出：function

```

需要注意的是，typeof null 的返回值为 'object'，这是一个历史遗留问题，因为 null 被当作一个空对象的标记，详见 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof)。

2.  instanceof 运算符

instanceof 运算符可以判断一个对象是否属于某个类或其子类，返回值为布尔类型，比如：

```
class Person {};
const p = new Person();
console.log(p instanceof Person); // 输出：true
console.log(p instanceof Object); // 输出：true

```

需要注意的是，instanceof 运算符只能用来判断对象类型，无法判断基本类型。

3.  Object.prototype.toString 方法

Object.prototype.toString 方法可以返回一个对象的类型，它返回一个字符串，格式为 "[object 类型]"，比如：

```
console.log(Object.prototype.toString.call('hello')); // 输出：[object String]
console.log(Object.prototype.toString.call(123)); // 输出：[object Number]
console.log(Object.prototype.toString.call(true)); // 输出：[object Boolean]
console.log(Object.prototype.toString.call(function(){})); // 输出：[object Function]
console.log(Object.prototype.toString.call([])); // 输出：[object Array]
console.log(Object.prototype.toString.call({})); // 输出：[object Object]

```

需要注意的是，这种方法可以准确地判断各种对象类型，包括内置对象和自定义对象，但是需要注意不同的对象类型的字符串格式不同，例如数组和普通对象的格式就不一样。

4.  Array.isArray 方法

Array.isArray 方法可以判断一个对象是否为数组，返回值为布尔类型，比如：

```
console.log(Array.isArray([])); // 输出：true
console.log(Array.isArray({})); // 输出：false

```

需要注意的是，这种方法只能用来判断是否为数组，无法判断其他对象类型。

Q:数组常用方法

JavaScript 数组有很多常用的方法，下面列举一些常见的方法：

1.  push：在数组末尾添加一个或多个元素，并返回新的长度。
2.  pop：从数组末尾删除一个元素，并返回该元素。
3.  shift：从数组开头删除一个元素，并返回该元素。
4.  unshift：在数组开头添加一个或多个元素，并返回新的长度。
5.  slice：截取数组中的一部分，返回一个新的数组。
6.  splice：从数组中添加或删除元素，返回被删除的元素组成的数组。
7.  concat：将两个或多个数组合并成一个新数组，并返回该新数组。
8.  join：将数组中的所有元素转化为一个字符串，并返回该字符串。
9.  indexOf：返回指定元素在数组中的位置，如果数组中不存在该元素，则返回 -1。
10.  lastIndexOf：返回指定元素在数组中的最后一个位置，如果数组中不存在该元素，则返回 -1。
11.  forEach：对数组中的每个元素执行一次回调函数。
12.  map：对数组中的每个元素执行一次回调函数，并返回一个新的数组，新数组中的元素是回调函数的返回值。
13.  filter：对数组中的每个元素执行一次回调函数，根据回调函数的返回值过滤出一个新的数组。
14.  reduce：对数组中的每个元素执行一次回调函数，将所有回调函数的返回值累加，并返回累加后的结果。

以上是一些常用的数组方法，可以根据实际需求选择使用。

Q:提供几种数组去重的方法

数组去重是前端开发中常见的操作之一，下面提供几种去重的方法：

1.  利用 Set 数据结构去重

```
const arr = [1, 2, 3, 1, 2];
const result = Array.from(new Set(arr));
console.log(result); // [1, 2, 3]

```

2.  利用 indexOf() 方法去重

```
const arr = [1, 2, 3, 1, 2];
const result = [];
for (let i = 0; i < arr.length; i++) {
  if (result.indexOf(arr[i]) === -1) {
    result.push(arr[i]);
  }
}
console.log(result); // [1, 2, 3]

```

3.  利用 includes() 方法去重

```
const arr = [1, 2, 3, 1, 2];
const result = [];
for (let i = 0; i < arr.length; i++) {
  if (!result.includes(arr[i])) {
    result.push(arr[i]);
  }
}
console.log(result); // [1, 2, 3]

```

4.  利用 reduce() 方法去重

```
const arr = [1, 2, 3, 1, 2];
const result = arr.reduce((prev, curr) => {
  if (prev.indexOf(curr) === -1) {
    prev.push(curr);
  }
  return prev;
}, []);
console.log(result); // [1, 2, 3]

```

5.  利用 filter() 方法去重

```
const arr = [1, 2, 3, 1, 2];
const result = arr.filter((item, index) => {
  return arr.indexOf(item) === index;
});
console.log(result); // [1, 2, 3]

```

6.  利用 Map 数据结构去重

```
const arr = [1, 2, 3, 1, 2];
const map = new Map();
const result = [];
for (let i = 0; i < arr.length; i++) {
  if (!map.has(arr[i])) {
    map.set(arr[i], true);
    result.push(arr[i]);
  }
}
console.log(result); // [1, 2, 3]

```

以上是一些常见的数组去重方法，根据场景选择适合的方法可以提高代码效率。

Q:事件代理在捕获阶段的实际应用

事件代理是通过事件冒泡机制实现的，可以在祖先元素上监听事件，从而处理子孙元素的事件。一般情况下，事件代理是在目标元素的祖先元素上添加事件监听器，在事件捕获阶段就能捕获目标元素的事件。

事件代理在捕获阶段的实际应用较少，因为大多数事件都是在冒泡阶段处理的。但也有一些场景下可以使用事件代理在捕获阶段处理事件，比如以下几种情况：

1.  阻止默认事件

在目标元素的祖先元素上监听事件，在捕获阶段处理事件，可以提前阻止默认事件的触发，避免后续事件的影响。

2.  在元素还未插入 DOM 树中处理事件

可以在目标元素插入 DOM 树前的祖先元素上监听事件，从而处理目标元素的事件，避免在目标元素插入 DOM 树后再监听事件带来的额外开销。

3.  提前处理事件

如果在目标元素的祖先元素上监听事件，在捕获阶段就能捕获到目标元素的事件，从而提前处理事件，避免后续事件的影响。

需要注意的是，在捕获阶段处理事件时，由于事件冒泡的机制，事件处理程序可能会被多次调用。因此，需要在事件处理程序中使用 `event.stopPropagation()` 方法来防止事件冒泡，避免重复处理。

Q:讲几种去除字符串首尾空格的方法

去除字符串首尾空格的方法有以下几种：

1.  使用 `trim()` 方法：该方法返回一个新的字符串，表示原始字符串的副本，其中删除了字符串两端的空格。
    
    ```
    javascriptCopy code`const str = '  hello world  ';
    const trimmedStr = str.trim();
    console.log(trimmedStr); // 'hello world'` 
    ```
    
2.  使用正则表达式：通过正则表达式匹配字符串两端的空格，并使用 `replace()` 方法将其替换为空字符串。
    
    ```
    javascriptCopy code`const str = '  hello world  ';
    const trimmedStr = str.replace(/^\s+|\s+$/g, '');
    console.log(trimmedStr); // 'hello world'` 
    ```
    
3.  使用 `substring()` 方法：从字符串的第一个非空格字符到最后一个非空格字符之间的子字符串。
    
    ```
    javascriptCopy code`const str = '  hello world  ';
    let startIndex = 0;
    let endIndex = str.length - 1;
    while (str[startIndex] === ' ') {
      startIndex++;
    }
    while (str[endIndex] === ' ') {
      endIndex--;
    }
    const trimmedStr = str.substring(startIndex, endIndex + 1);
    console.log(trimmedStr); // 'hello world'` 
    ```
    
4.  使用 `split()` 和 `join()` 方法：将字符串按照空格字符分割成数组，再将数组元素用空字符串拼接成一个新字符串。
    
    ```
    javascriptCopy code`const str = '  hello world  ';
    const trimmedStr = str.split(' ').join('');
    console.log(trimmedStr); // 'helloworld'` 
    ```
    

注意，以上方法都会返回一个新的字符串，原始字符串不会被修改。

Q:如何判断一个数组

判断一个变量是否为数组有多种方法，下面列举几种常用的方法：

1.  使用 Array.isArray() 方法，该方法会返回一个布尔值，用来判断传入的参数是否为数组。

```
let arr = [1, 2, 3];
console.log(Array.isArray(arr)); // true

```

2.  使用 instanceof 运算符，判断变量的构造函数是否为 Array。

```
let arr = [1, 2, 3];
console.log(arr instanceof Array); // true

```

3.  使用 Object.prototype.toString() 方法，获取变量的类型字符串，然后进行比较。

```
let arr = [1, 2, 3];
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true

```

4.  使用 Array.prototype.forEach() 方法，判断数组的每个元素是否符合要求，如果符合则将结果保存在一个变量中。

```
let arr = [1, 2, 3];
let isArray = true;
arr.forEach(function (item) {
  if (typeof item !== 'number') {
    isArray = false;
  }
});
console.log(isArray); // true

```

需要注意的是，在使用第四种方法时，如果数组为空，则无法判断其类型，因此需要额外处理。

Q:JS 实现跨域

跨域是指在浏览器中，一个页面所在的域名无法访问另一个域名的资源，这是浏览器的同源策略导致的。为了解决跨域问题，我们可以使用以下几种方法：

1.  JSONP

JSONP（JSON with Padding）是一种跨域数据请求方式，可以跨域加载不同域上的数据，它利用了 `<script>` 标签没有跨域限制的特点。具体实现是通过在请求地址中添加一个回调函数名，服务器返回的数据会作为参数传递给回调函数。

2.  CORS

CORS（Cross-Origin Resource Sharing）是现代浏览器支持的一种跨域资源共享方案。通过在服务端设置相应的 HTTP 头部，让浏览器知道该资源可以被跨域访问。

例如，在 Node.js 中，我们可以使用 `cors` 模块来设置 CORS 头部：

```
const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors());

// ...

```

3.  代理

代理是一种通过后端接口转发的方式实现跨域请求的方法。客户端通过向自己的服务器发送请求，服务器再将请求转发给目标服务器，然后将目标服务器返回的结果再返回给客户端。

4.  postMessage

`postMessage` 是 HTML5 中提供的一种跨域通信机制，可以在不同窗口（甚至不同域名）之间传递数据。在同源策略下，我们只能使用同一个窗口对象中的方法进行通信，但使用 `postMessage` 后，我们可以向其他窗口发送数据，同时也可以接收其他窗口发送的数据。

Q:JS 基本数据类型

JavaScript 的基本数据类型包括：

1.  Number（数字类型）：用于表示数值，包括整数和浮点数。
2.  String（字符串类型）：用于表示文本，可以包含任意字符，包括字母、数字、符号等。
3.  Boolean（布尔类型）：用于表示逻辑值，只有 true 和 false 两个值。
4.  Undefined（未定义类型）：表示变量未被赋值时的默认值。
5.  Null（空类型）：表示变量没有值，可以通过将变量赋值为 null 来清空变量。
6.  Symbol（符号类型）：用于表示唯一的、不可变的值，通常用于对象属性的键名。

这些基本数据类型在 JavaScript 中都是不可变的，也就是说，一旦创建，就不能再改变它们的值。

Q:JS 深度拷贝一个元素的具体实现

JS 中实现深度拷贝一个元素有多种方式，下面给出几种常见的实现方式：

1.  利用 JSON 序列化和反序列化

```
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

```

该方法的优点是简单易用，缺点是无法拷贝函数、循环引用等特殊情况。

2.  递归实现

```
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  let clone = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    clone[key] = deepClone(obj[key]);
  }

  return clone;
}

```

该方法的优点是能够完全拷贝对象及其内部的所有属性和子属性，缺点是在处理循环引用时容易栈溢出。

3.  利用 Object.create() 实现浅拷贝

```
function shallowClone(obj) {
  return Object.create(obj);
}

```

该方法只能拷贝对象的属性，无法拷贝对象的方法和内部属性。

总的来说，深度拷贝是一个比较复杂的问题，需要根据实际情况进行选择和实现。

Q:用 JS 实现全排列

全排列是指对给定的一组数字进行全排列，比如给定数组 [1, 2, 3]，它的全排列为 [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]。

实现全排列的一种简单的方法是使用递归。我们可以将原始数组分成两部分：第一个元素和剩余的元素。然后，我们可以将第一个元素插入到所有剩余元素的全排列中，以获得完整的全排列。递归终止条件是当剩余的元素为空时，我们获得了一个全排列。

下面是用 JS 实现全排列的代码：

```
function permute(nums) {
  let result = [];

  function backtrack(current, remaining) {
    if (remaining.length === 0) {
      result.push(current);
      return;
    }

    for (let i = 0; i < remaining.length; i++) {
      let nextCurrent = current.concat([remaining[i]]);
      let nextRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1));
      backtrack(nextCurrent, nextRemaining);
    }
  }

  backtrack([], nums);
  return result;
}

let nums = [1, 2, 3];
let permutations = permute(nums);
console.log(permutations);

```

在这个实现中，我们定义了一个 `backtrack` 函数，该函数接受两个参数：当前的全排列和剩余的元素。如果剩余的元素为空，则我们将当前的全排列添加到结果数组中。否则，我们迭代剩余的元素，并将它们插入到当前的全排列中，递归调用 `backtrack` 函数以获得完整的全排列。最后，我们返回结果数组。

Q:跨域的原理

跨域是指浏览器发起的请求与当前页面所在的域名不同，包括不同的协议、不同的域名或不同的端口号。跨域请求是浏览器的一种安全机制，是为了防止恶意的网站利用脚本窃取其他网站的信息。跨域通常有以下几种方式：

1.  JSONP：通过动态创建 script 标签，利用 script 标签跨域的特性，把数据以参数的形式传递到回调函数中，从而实现跨域。
    
2.  CORS：CORS 是一种机制，通过在服务端设置响应头来实现浏览器跨域访问。服务端设置响应头中的 Access-Control-Allow-Origin 字段来控制允许跨域的域名。
    
3.  代理：通过在同源服务器上搭建一个代理服务器，然后在该服务器上进行跨域请求，最后再将响应结果返回给客户端，实现跨域。
    
4.  postMessage：通过在两个窗口之间建立消息通道，跨域窗口通过该通道进行相互通信，从而实现跨域。
    
5.  WebSocket：WebSocket 是 HTML5 提供的一种浏览器与服务器间进行全双工通讯的网络技术，可以实现跨域通讯。
    

以上这些方法在实际开发中都有自己的应用场景和优缺点，需要根据具体的情况选择合适的跨域方式。

Q:不同数据类型的值的比较，是怎么转换的，有什么规则

在 JavaScript 中，不同类型的值之间进行比较时会进行隐式类型转换。具体规则如下：

1.  如果比较的两个值类型不同，JavaScript 会尝试将其中一个值转换成另一个值的类型。
2.  如果两个值都是字符串类型，比较的是它们的字符编码值。
3.  如果其中一个值为布尔值，那么它会被转换成数字，true 转换成 1，false 转换成 0。
4.  如果其中一个值为数字，另一个值为字符串，则字符串会被转换成数字。
5.  如果其中一个值为对象或者数组，另一个值为原始类型的值，则对象或数组会被转换成字符串。

在进行比较操作时，如果不同类型的值不能被隐式转换，那么比较的结果将会是 false。

需要注意的是，在使用 `==` 进行比较时，会进行类型转换后再进行比较。而在使用 `===` 进行比较时，不会进行类型转换，如果类型不同，则直接返回 false。

因此，在进行比较时，应该尽可能地使用严格相等运算符 `===`，避免由于类型转换导致的问题。

Q:null == undefined 为什么

在 JavaScript 中，null 和 undefined 是两个不同的数据类型，但是它们的值是非常相似的，都表示“空值”。

当使用相等运算符（==）比较 null 和 undefined 时，它们的值相等，但是数据类型不同，因此 JavaScript 将它们视为相等的。也就是说，null == undefined 返回 true。

但是，使用严格相等运算符（===）比较 null 和 undefined 时，它们的值相等，但是数据类型不同，因此 JavaScript 将它们视为不相等的。也就是说，null === undefined 返回 false。

因此，在编写 JavaScript 代码时，建议使用严格相等运算符（===）进行比较，以避免意外的类型转换。

Q:this 的指向有哪几种

在 JavaScript 中，this 可以指向以下几种情况：

1.  全局对象（Global Object）：在浏览器中是 window 对象，在 Node.js 中是 global 对象。
    
2.  函数上下文对象（Function Context Object）：当一个函数被作为方法调用时，this 指向调用该方法的对象。
    
3.  构造函数的实例对象（Instance Object）：当通过 new 关键字调用构造函数创建对象时，this 指向构造函数创建的实例对象。
    
4.  显示绑定（Explicit Binding）：通过 call、apply 或 bind 方法指定 this 的指向。
    
5.  箭头函数（Arrow Function）：箭头函数没有自己的 this，它的 this 由外部的作用域决定。
    

需要注意的是，this 的指向是在函数执行时才能确定的，而不是在函数定义时。

Q:什么是暂停死区

暂停死区是指在变量声明语句之前不能访问该变量的现象。在 ES6 中，使用 let 和 const 声明变量时会产生暂停死区。在代码块中使用 let 或 const 声明变量时，在该声明语句之前使用该变量会导致暂停死区，会抛出一个 ReferenceError 异常。这是因为 let 和 const 声明的变量不会被提升到代码块的顶部，而是存在于代码块的作用域中，只有声明语句执行完成之后，变量才会被初始化并分配内存空间。

Q:AngularJS 双向绑定原理

AngularJS 双向绑定的实现是通过脏检查的机制来实现的。它的原理如下：

1.  当模型改变时，AngularJS 会将该模型标记为“脏”；
2.  在接下来的 digest 循环中，AngularJS 会遍历所有的“脏”模型，并更新与其相关的视图；
3.  如果在更新视图的过程中，又有新的模型变化，则会再次被标记为“脏”，并在下一次的 digest 循环中进行更新。

这个过程是单向的，即从模型到视图，或者从视图到模型。具体来说，当用户在表单中输入数据时，会触发视图更新，而视图更新会导致相应的模型变化。这个过程中，AngularJS 会在后台自动维护一个监听器，用于监测模型和视图之间的变化，从而实现双向绑定。

总的来说，AngularJS 的双向绑定机制是通过对模型和视图之间的变化进行监听，从而实现双向数据绑定的。这种机制能够减少开发者的代码量，提高代码的可维护性和可读性，是 AngularJS 框架的重要特性之一。

Q:什么是按需加载

按需加载是一种前端优化技术，也称为延迟加载。它的主要思想是根据当前页面的需求，在需要的时候才加载所需的资源，而不是在页面加载时一次性加载所有资源，从而减少页面加载时间和提高用户体验。

按需加载可以应用于各种资源，如图片、脚本、样式表、字体等。例如，在页面中有很多图片时，可以使用按需加载的方式，只有当用户滚动到图片位置时才加载该图片，以避免一次性加载大量图片影响页面性能。

在实现按需加载时，可以使用一些前端框架或库，如React、Vue、jQuery等，也可以手动编写相关代码。常用的按需加载方式包括懒加载、分块加载和异步加载等。

Q:说一下什么是 virtual dom

Virtual DOM（虚拟 DOM）是一种编程概念，用于优化 Web 应用程序的性能和用户体验。它是一个 JavaScript 对象，代表了真实 DOM 的结构和状态。当数据发生变化时，Virtual DOM 会计算出最小的变化并将其更新到真实的 DOM 上，这样可以避免全量重新渲染整个 DOM 树，从而提高性能和用户体验。

Virtual DOM 的工作原理如下：

1.  当数据发生变化时，Virtual DOM 会计算出新的 Virtual DOM 树。
    
2.  Virtual DOM 会和之前的 Virtual DOM 树进行比较，找出差异。
    
3.  Virtual DOM 只会将差异部分更新到真实 DOM 上。
    

由于真实 DOM 操作非常消耗性能，而 Virtual DOM 可以减少 DOM 操作的次数，因此在一些需要高性能的应用场景中，使用 Virtual DOM 可以有效提升应用性能和用户体验。常见的 Virtual DOM 实现包括 React 的 Virtual DOM 和 Vue.js 的 Virtual DOM。

Q:讲一讲 webpack

Webpack 是一个模块化的打包工具，它将应用程序视为一个模块化的系统，并通过一系列的加载器和插件将这些模块打包成可在浏览器中运行的静态文件。Webpack 通过静态分析依赖关系，构建依赖关系图，并将所有依赖项打包成一个或多个 bundle。

Webpack 的核心是 Loader 和 Plugin，Loader 负责将文件转换成模块，Plugin 负责解决其他的自动化任务。Webpack 还支持热替换，这意味着在开发过程中对代码的更改会立即反映在浏览器中，从而提高了开发效率。

Webpack 的配置文件为 webpack.config.js，其中可以配置入口文件、输出路径、加载器、插件等。通过配置不同的加载器和插件，Webpack 可以处理 JavaScript、CSS、图片等不同类型的文件，并且支持代码分离和懒加载等特性。

Q:讲一讲 ant-design 优点和缺点

Ant Design 是一个基于 React 的 UI 组件库，它提供了丰富的 UI 组件，能够快速开发高质量的 Web 应用程序。

优点：

*   提供了丰富的高质量的 UI 组件，能够大大加快开发速度。
*   提供了良好的文档和示例，方便开发者使用和学习。
*   支持多种主题和定制化配置，方便根据项目需要进行个性化定制。
*   遵循 Ant Design 设计规范，设计美观且易用。

缺点：

*   由于提供了大量的组件和功能，整个库的体积比较大，可能会导致项目打包后体积较大，加载时间变长。
*   由于遵循 Ant Design 设计规范，因此在某些场景下，可能需要进行一些额外的样式修改或适配，比如与既有的项目风格不匹配等情况。

Q:写一个函数，第一秒打印 1，第二秒打印 2，一共打印 5 次

可以使用定时器 setInterval() 实现。在每次触发定时器时，将计数器加 1 并判断是否达到打印次数。若达到，则清除定时器。示例代码如下：

```
let count = 1;
const timer = setInterval(() => {
  console.log(count);
  count++;
  if (count > 5) {
    clearInterval(timer);
  }
}, 1000);

```

上述代码中，定义了一个计数器 count，每秒将其加 1，并输出当前的值。当计数器值超过 5 时，清除定时器。

Q:Vue2 的生命周期

Vue2 的生命周期可以分为 8 个阶段，分别是：

1.  `beforeCreate`：实例创建之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。
    
2.  `created`：实例已经创建完成之后被调用。在这一步，实例已经完成了数据的观测、属性和方法的运算，但是还没有开始 DOM 的渲染。
    
3.  `beforeMount`：在挂载之前被调用，即将开始 DOM 渲染。
    
4.  `mounted`：实例挂载到 DOM 上后被调用，这时 DOM 元素已经生成。
    
5.  `beforeUpdate`：数据更新之前被调用，可以在这里更改数据，不会触发重新渲染。
    
6.  `updated`：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这一步，组件 DOM 已经更新。
    
7.  `beforeDestroy`：实例销毁之前被调用，此时实例上所有的绑定和监听器都会被移除。
    
8.  `destroyed`：实例销毁之后被调用，此时组件完全被销毁，所有的事件监听器和子实例都被移除。
    

需要注意的是，以上生命周期钩子函数都是可选的，并非必须实现。

Q:Vue3 的生命周期

Vue3 的生命周期相比于 Vue2 发生了一些变化，具体如下：

1.  beforeCreate 和 created 阶段没有变化，用来初始化实例数据和生命周期钩子。
    
2.  Vue2 中的 beforeMount 和 mounted 阶段，在 Vue3 中分别变成了 beforeMount 和 onMounted。
    
3.  Vue2 中的 beforeUpdate 和 updated 阶段，在 Vue3 中分别变成了 beforeUpdate 和 onUpdated。
    
4.  Vue2 中的 beforeDestroy 和 destroyed 阶段，在 Vue3 中分别变成了 beforeUnmount 和 onUnmounted。
    
5.  Vue3 中新增了两个生命周期钩子：onRenderTriggered 和 onRenderTracked，用于调试组件的性能问题。
    
6.  Vue3 中新增了一个全局的生命周期钩子：onRenderEffectSetup，用于在渲染组件前执行一些操作。
    

总的来说，Vue3 的生命周期相对于 Vue2 有所简化，但是也增加了一些新的生命周期钩子，方便开发者进行调试和性能优化。

Q:简单介绍一下 symbol

Symbol 是 ES6 中新增的一种基本数据类型，用来表示一个独一无二的值，可以用作对象的属性名，避免属性名的冲突。

Symbol 的特点是：

1.  唯一性：每个 Symbol 值都是唯一的，即使是同样的参数创建的 Symbol 值也不相等。
2.  不可枚举：Symbol 作为属性名，不会出现在 for...in、Object.keys() 和 JSON.stringify() 等操作中。
3.  隐藏性：使用 Symbol 作为属性名时，它并不会出现在对象的原型链上，也不会被对象方法访问到。

Symbol 通常用来表示对象的私有属性、常量、枚举值等。可以通过 `Symbol()` 函数创建 Symbol 类型的值，也可以使用 `Symbol.for()` 方法创建全局共享的 Symbol 值。

Q:什么是事件监听

事件监听（event listener）指的是在 JavaScript 中，对某个 DOM 元素绑定一个或多个事件处理函数，当该元素上的对应事件发生时，这些函数会被调用。

事件监听可以帮助我们在用户操作页面时做出相应的处理。常见的事件包括点击事件、鼠标移动事件、滚动事件、键盘输入事件等等。我们可以使用事件监听来实现页面上的交互功能，比如按钮点击、鼠标悬浮提示等等。

Q:说说 C++, Java，Python, go, Rust, JavaScript 这三种语言的区别

C++、Java、Python、Go、Rust 和 JavaScript 都是不同的编程语言，它们有着不同的特点和应用场景。

1.  C++：C++ 是一种通用的高级编程语言，是 C 语言的扩展。它具有高效、快速、面向对象、低级编程和编译器控制等特点。它被广泛应用于操作系统、数据库、游戏、网络和嵌入式设备等领域。
    
2.  Java：Java 是一种广泛应用于企业级应用程序开发的高级编程语言。它具有面向对象、可移植、跨平台、安全等特点，被广泛应用于网络开发、大数据处理、企业级应用程序、游戏开发和移动应用程序等领域。
    
3.  Python：Python 是一种高级的、通用的、解释型的编程语言，具有简单、易读、易维护、高效、可扩展等特点。它被广泛应用于数据分析、人工智能、机器学习、Web 开发、游戏开发等领域。
    
4.  Go：Go 是一种并发性高、编译速度快、语法简洁的编程语言，它被设计用于大规模分布式系统和网络编程。Go 具有高效、并发、内存安全、易于开发等特点。
    
5.  Rust：Rust 是一种系统级编程语言，旨在提供更好的内存安全和并发性能。它是一种高性能、低级别的编程语言，支持面向对象、函数式和并发编程。
    
6.  JavaScript：JavaScript 是一种脚本语言，主要用于在 Web 页面上进行交互式编程。它是一种高级编程语言，支持面向对象和函数式编程。JavaScript 也被广泛应用于服务器端编程、桌面应用程序和移动应用程序开发等领域。
    

以上是这些编程语言的一些简单特点，不同的语言有着不同的应用场景和优缺点，开发者可以根据实际情况选择最合适的语言来完成工作。

Q:JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？

在 JavaScript 中，每个对象都有一个内部的 `[[Prototype]]` 属性，指向其原型对象。原型对象也是一个对象，同样也有自己的原型对象，形成了原型链。当我们在对象上访问一个属性或方法时，如果对象本身没有这个属性或方法，JavaScript 引擎会沿着原型链向上查找，直到找到对应的属性或方法，或者到达原型链的顶端（即 `Object.prototype`）。

`Object.prototype` 是所有 JavaScript 对象的顶层原型，包括数组、函数、日期、正则表达式等。它是原型链的顶端。

`Object.prototype` 的原型是 `null`，即它没有原型，是原型链的最末端。这也是原型链的终止点。

需要注意的是，使用 `Object.create(null)` 创建的对象是没有原型的，即它的 `[[Prototype]]` 属性为 `null`。这样的对象被称为“纯净的”对象，因为它没有从原型继承来的任何属性或方法。

Q:在数组原型链上实现删除数组重复数据的方法

可以使用数组原型链上的 reduce 和 includes 方法来实现删除数组重复数据的方法，具体实现如下：

```
Array.prototype.unique = function() {
  return this.reduce((acc, cur) => {
    if (!acc.includes(cur)) {
      acc.push(cur);
    }
    return acc;
  }, []);
}

```

使用方法如下：

```
const arr = [1, 2, 3, 2, 4, 1];
const uniqueArr = arr.unique();
console.log(uniqueArr); // [1, 2, 3, 4]

```

在这个例子中，reduce 方法用于遍历原数组，将不重复的元素添加到一个新数组中。includes 方法用于判断新数组中是否已经存在当前元素。由于在数组原型链上添加了 unique 方法，因此在任何数组实例上都可以调用该方法。

Q:用闭包写个单例模式

单例模式是指一个类仅有一个实例，并提供一个全局的访问点，常用于管理全局唯一的资源。下面是使用闭包实现的一个单例模式的示例：

```
var Singleton = (function () {
  var instance;

  function init() {
    // private methods and variables
    function privateMethod() {
      console.log("I am private");
    }
    var privateVariable = "I'm also private";

    // public methods and variables
    return {
      publicMethod: function () {
        console.log("The public can see me!");
        privateMethod();
      },
      publicVariable: "I'm public",
    };
  }

  return {
    getInstance: function () {
      if (!instance) {
        instance = init();
      }
      return instance;
    },
  };
})();

// Usage
var singleA = Singleton.getInstance();
var singleB = Singleton.getInstance();
console.log(singleA === singleB); // true

```

在这个示例中，使用了闭包来保存单例实例的引用，通过 `init` 方法返回了一个对象字面量，包含了公有和私有方法和变量。在 `getInstance` 方法中判断是否已经创建过实例，如果没有则创建一个新的实例，否则直接返回之前保存的实例。这种方式可以确保全局只有一个实例，并且可以被其他模块轻松地访问。

Q:写个函数，可以转化下划线命名到驼峰命名

可以写一个函数 `underlineToCamel(str)` 来将下划线命名转化为驼峰命名，具体实现如下：

```
function underlineToCamel(str) {
  return str.replace(/_(\w)/g, function(match, letter) {
    return letter.toUpperCase();
  });
}

```

该函数使用了正则表达式来匹配下划线后的字符并将其转化为大写字母，然后返回转化后的驼峰命名字符串。例如，`underline_to_camel` 会被转化为 `underlineToCamel`。

Q:深浅拷贝的区别和实现

浅拷贝和深拷贝都是对于对象和数组这种引用类型而言的。

浅拷贝是指创建一个新的对象或者数组，将原始对象或者数组中的元素复制到新对象或者数组中，如果原始对象或者数组的元素是基本数据类型，则复制元素的值；如果原始对象或者数组的元素是对象或者数组，则复制元素的引用。因此，浅拷贝得到的新对象或者数组中的元素和原始对象或者数组中的元素指向同一块内存地址，如果修改了新对象或者数组中的元素，则原始对象或者数组中的元素也会随之改变。

深拷贝是指创建一个新的对象或者数组，并递归地将原始对象或者数组中的元素复制到新对象或者数组中，直到原始对象或者数组中的元素全部都是基本数据类型为止。因此，深拷贝得到的新对象或者数组中的元素和原始对象或者数组中的元素不指向同一块内存地址，如果修改了新对象或者数组中的元素，则原始对象或者数组中的元素不会改变。

实现浅拷贝的方法有很多，比如 `Object.assign()`、扩展运算符 `...`、`Array.prototype.concat()`、`Array.prototype.slice()` 等。

实现深拷贝的方法也有很多，比如递归复制、JSON 序列化反序列化、`lodash.cloneDeep()` 等。

下面是一个使用递归实现深拷贝的例子：

```
function deepClone(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj
  }
  let clone = Array.isArray(obj) ? [] : {}
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key])
    }
  }
  return clone
}

```

这个函数会递归地复制原始对象或者数组中的元素，如果原始对象或者数组中的元素是基本数据类型，则直接复制元素的值；如果原始对象或者数组中的元素是对象或者数组，则递归地复制这些元素。这样得到的新对象或者数组中的元素和原始对象或者数组中的元素不指向同一块内存地址，修改新对象或者数组中的元素不会影响原始对象或者数组中的元素。

Q:JS 中 string 的 startwith 和 indexof 两种方法的区别

`startsWith()` 和 `indexOf()` 是两种不同的字符串方法，它们都可以用于确定字符串中是否包含特定的文本。它们之间的区别如下：

*   `startsWith()` 方法是 ES6 中的新增方法，用于判断字符串是否以指定文本开头。`startsWith()` 方法返回布尔值，如果字符串以指定文本开头，则返回 `true`，否则返回 `false`。
*   `indexOf()` 方法是字符串的一个原生方法，可以用于查找一个字符串中是否包含某个子串。如果包含，则返回该子串第一次出现的位置，如果不包含，则返回 -1。

另一个区别是，`startsWith()` 方法只接受一个参数，即要检查的文本，而 `indexOf()` 方法接受两个参数，第一个参数是要查找的子串，第二个参数是起始查找位置的索引值。

示例代码如下：

```
const str = 'Hello World';

console.log(str.startsWith('Hello')); // true
console.log(str.startsWith('World')); // false

console.log(str.indexOf('Hello')); // 0
console.log(str.indexOf('World')); // 6
console.log(str.indexOf('Javascript')); // -1

```

至于哪个更好，这取决于你需要做什么。如果你只需要检查一个字符串是否以指定的文本开头，那么 `startsWith()` 方法可能更加简单明了。如果你需要查找字符串中的子串并执行更复杂的操作，那么 `indexOf()` 方法可能更加有用。

Q:讲几种 JS 字符串转数字的方法

在 JavaScript 中将字符串转为数字有以下几种方法：

1.  使用 `parseInt()` 函数将字符串转为整数。例如：`parseInt('123')`，将返回数字 123。`parseInt()` 还可以接收第二个参数，用来指定进制数。例如：`parseInt('0xff', 16)` 将返回数字 255。
2.  使用 `parseFloat()` 函数将字符串转为浮点数。例如：`parseFloat('3.14')`，将返回数字 3.14。
3.  使用 `Number()` 构造函数将字符串转为数字。例如：`Number('123')`，将返回数字 123。`Number()` 函数还可以将布尔值转为数字，`true` 转为 1，`false` 转为 0。
4.  使用 `+` 运算符将字符串转为数字。例如：`+'123'`，将返回数字 123。这种方法通常被称为隐式类型转换。

需要注意的是，如果字符串无法被解析为有效的数字，以上方法都会返回 `NaN`（Not a Number）。

另外，ES6 引入了新的方法 `Number.parseInt()` 和 `Number.parseFloat()`，与 `parseInt()` 和 `parseFloat()` 作用类似，但是可以避免一些历史遗留问题，推荐使用。例如：`Number.parseInt('123')` 将返回数字 123。

Q:let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现 块级作用域（立即执行函数），ES6 呢

`let`、`const`、`var` 都是用来声明变量的关键字。它们之间的区别如下：

1.  `var` 声明的变量存在变量提升，可以在声明前使用，而 `let` 和 `const` 不会存在变量提升，声明前使用会抛出错误。
2.  `let` 和 `const` 声明的变量存在块级作用域，而 `var` 声明的变量不存在块级作用域，它是函数作用域或全局作用域。
3.  `let` 和 `const` 声明的变量不允许重复声明，而 `var` 声明的变量可以重复声明。
4.  `let` 声明的变量可以重新赋值，`const` 声明的变量不允许重新赋值。

块级作用域指的是在一对大括号 `{}` 内部定义的变量或函数只在该大括号内部有效。在 ES5 中，可以通过立即执行函数的方式实现块级作用域，即通过定义一个匿名函数并立即调用它来创建一个作用域，使得其中定义的变量不会污染全局作用域。例如：

```
(function() {
  var foo = 1;
  console.log(foo); // 1
})();
console.log(foo); // ReferenceError: foo is not defined

```

在 ES6 中，由于 `let` 和 `const` 声明的变量存在块级作用域，因此可以直接使用 `{}` 来创建块级作用域。例如：

```
{
  let foo = 1;
  console.log(foo); // 1
}
console.log(foo); // ReferenceError: foo is not defined

```

在 ES6 中，也可以使用 `const` 来创建常量，例如：

```
const PI = 3.1415926;

```

常量在声明时必须进行赋值，且不能重新赋值。

Q:ES6 箭头函数的特性

ES6 中的箭头函数是一种新的函数语法，其主要特点是简洁和词法作用域绑定。

具体来说，箭头函数有以下特性：

1.  简洁：省略了 function 关键字，使用箭头符号（=>）来代替。
2.  词法作用域绑定：箭头函数没有自己的 this、arguments、super、new.target 绑定。它们通过词法作用域链来继承这些变量，因此箭头函数内部的 this 值指向定义时所在的对象，而不是运行时所在的对象。

除此之外，箭头函数还有一些注意点：

1.  箭头函数没有自己的 arguments 对象，但是可以使用 rest 参数来代替。
2.  箭头函数不能作为构造函数使用，因为它们没有自己的 this 值。
3.  箭头函数不能使用 yield 关键字，因此不能用作 generator 函数。

总的来说，箭头函数的出现使得我们能够更加方便地书写函数，并且避免了一些 this 指向的问题。但是需要注意它的一些限制，以及在特定的场景下可能并不适用。

Q:有了解过事件模型吗，DOM0 级和 DOM2 级有什么区别，DOM 的分级是什么

事件模型是指在 HTML 中，如何处理事件（比如单击一个按钮）。DOM（Document Object Model，文档对象模型）定义了 HTML 页面中所有的对象和属性，这些对象和属性可以被 JavaScript 脚本访问和操作。

DOM 事件模型主要分为 DOM0 级和 DOM2 级两种。

*   DOM0 级事件模型：是最初的事件模型，也被称为“传统事件模型”。在 DOM0 级事件模型中，事件是直接绑定到 DOM 元素上的。可以通过为元素的事件属性（比如 onclick）指定一个 JavaScript 函数来注册事件处理程序。DOM0 级事件模型缺乏对事件流的明确支持，因此无法通过 DOM0 级事件模型来实现事件委托。
    
*   DOM2 级事件模型：是当前广泛使用的事件模型，也被称为“标准事件模型”。在 DOM2 级事件模型中，事件是先被绑定到文档结构的顶层（也就是文档对象）上，然后逐级向下传播到最具体的元素（也就是事件目标）上。DOM2 级事件模型提供了对事件流的明确支持，使得事件委托等高级技术变得更加容易实现。
    

DOM 事件模型根据事件流分为三个阶段：

*   捕获阶段（Capture phase）：事件从文档根节点向事件目标传播的过程中，先经过文档根节点，然后依次经过各个父元素，最终到达事件目标。
    
*   目标阶段（Target phase）：事件到达事件目标时触发的阶段。
    
*   冒泡阶段（Bubbling phase）：事件从事件目标向文档根节点传播的过程中，沿途经过各个父元素，最终到达文档根节点。
    

ES6 中新增了一种事件模型，叫做“可选捕获模型”。它在 DOM2 级事件模型的基础上做了一些改进，可以让开发者更方便地控制事件的捕获和冒泡。

DOM 的分级主要分为四个级别：

*   DOM Level 0：也叫 DOM0 级，是最早的 DOM 规范，定义了一些最基本的 DOM 操作。比如，document.write 方法就属于 DOM Level 0。
    
*   DOM Level 1：定义了核心 DOM 结构，包括元素、文本、属性等。并且增加了事件模型、样式操作、动画效果等功能。
    
*   DOM Level 2：定义了 DOM 视图（Views）、事件模型、遍历和范围（Traversal and Range）、CSS、XML 支持等。
    
*   DOM Level 3：进一步扩展了
    

Q:接着上一个回答中“DOM 的分级主要分为四个级别：”继续讲

DOM 的分级主要分为四个级别：

1.  DOM Level 1：于 1998 年发布，包括 DOM Core 和 DOM HTML 两个模块，主要定义了基本的文档结构和操作方法。
    
2.  DOM Level 2：于 2000 年发布，包括 DOM Core、DOM Views、DOM Events 和 DOM Style 四个模块，增强了对文档的访问和操作能力，增加了事件处理和样式控制方面的支持。
    
3.  DOM Level 3：于 2004 年发布，包括 DOM Core、DOM Load and Save、DOM Validation、DOM Events、DOM Stylesheets 和 DOM Traversal and Range 六个模块，增加了对 XML 的支持，并加强了文档操作的细节。
    
4.  DOM Level 4：于 2015 年发布，包括 DOM Core 和 DOM Standardization 两个模块，进一步扩展了 DOM 的功能和规范。但是，由于浏览器的兼容性问题，目前还未广泛应用。
    

在 DOM 的分级中，每一级别都是在前一级别的基础上进行扩展，同时还会对之前的 API 进行优化和修复。

Q:提供几种获得对象上的属性的方法

获取对象上的属性可以使用以下几种方法：

1.  点操作符：使用点操作符 `.` 直接获取对象的属性值，例如 `obj.propertyName`。
2.  方括号操作符：使用方括号 `[]` 访问对象的属性值，例如 `obj['propertyName']`。
3.  Object.keys() 方法：该方法返回对象的所有可枚举属性的数组，可以通过遍历数组获取每个属性的值。
4.  Object.values() 方法：该方法返回对象所有属性的值的数组，可以通过遍历数组获取每个属性的值。
5.  Object.getOwnPropertyNames() 方法：该方法返回对象的所有属性名，包括不可枚举属性名，可以通过遍历属性名获取每个属性的值。
6.  Reflect.ownKeys() 方法：该方法返回对象的所有属性名，包括 Symbol 类型的属性名，可以通过遍历属性名获取每个属性的值。

需要注意的是，点操作符和方括号操作符只适用于对象自有属性和继承属性中可访问的属性，而不适用于不可访问的属性。而 Object.keys()、Object.values()、Object.getOwnPropertyNames()、Reflect.ownKeys() 方法则可以访问所有属性，包括不可枚举属性和 Symbol 类型的属性。

Q:简单讲一讲 ES6 的一些新特性

ES6（ECMAScript 6）是 JavaScript 的一个标准版本，也被称为 ES2015，于 2015 年 6 月正式发布。它引入了很多新特性和语法，包括但不限于以下几个方面：

1.  let 和 const 声明变量：let 和 const 关键字可以用来声明变量，其中 let 声明的变量是块级作用域，而 const 声明的变量则是常量，值不可更改。
    
2.  箭头函数：箭头函数是一种简写形式的函数声明，可以使用箭头（=>）来定义函数。它有简洁的语法、更加清晰的代码结构以及更好的性能。
    
3.  解构赋值：可以使用解构赋值来快速获取对象或数组中的值，并将其赋值给变量。它可以让代码更加简洁、可读性更高。
    
4.  模板字符串：模板字符串是一种新的字符串形式，可以使用反引号来定义，其中可以包含变量、表达式等内容，提高了字符串的可读性和灵活性。
    
5.  Promise 对象：Promise 对象是一种用于异步编程的新机制，它可以使得异步代码更加可读、易于维护。它可以将回调地狱的代码结构化，简化异步代码的编写。
    
6.  class 关键字：ES6 引入了 class 关键字，使得 JavaScript 可以更加轻松地使用面向对象的编程方法。
    
7.  模块化：ES6 引入了模块化的概念，使得 JavaScript 可以更加轻松地编写可维护的代码。
    
8.  简化对象定义：ES6 引入了新的语法糖，使得定义对象的代码更加简洁。
    

除此之外，ES6 还引入了一些新的内置对象和方法，例如 Set 和 Map 对象、数组的扩展方法等等。这些新特性和语法使得 JavaScript 更加强大、灵活和易于使用。

Q:讲一讲 private 和 public

在面向对象编程中，私有成员和公有成员是常见的概念。私有成员是指只能在类内部访问的成员，而公有成员则可以在类内部和外部都可以访问。

在 JavaScript 中，没有内置的私有成员和公有成员的概念，但可以通过一些方式模拟出这种行为。

一种方式是使用闭包来实现私有成员，这种方法通常会将私有成员保存在函数作用域中，通过暴露公有方法来访问这些私有成员。

例如，下面是一个使用闭包实现私有成员的示例：

```
function Counter() {
  var count = 0;

  this.increment = function() {
    count++;
  };

  this.getCount = function() {
    return count;
  };
}

var counter = new Counter();
counter.increment();
console.log(counter.getCount()); // 1
console.log(counter.count); // undefined

```

在上面的代码中，`count` 变量是私有成员，只能通过 `increment` 和 `getCount` 方法访问。尝试直接访问 `count` 变量会返回 `undefined`。

另一种方式是使用 ES6 中的类和访问控制符来实现私有成员和公有成员。ES6 中的类可以使用 `constructor` 和 `get`/`set` 方法定义私有成员和公有成员，以及使用 `#` 符号定义私有成员。

例如，下面是一个使用 ES6 类和访问控制符实现私有成员和公有成员的示例：

```
class Counter {
  #count = 0;

  increment() {
    this.#count++;
  }

  getCount() {
    return this.#count;
  }

  get count() {
    return this.#count;
  }

  set count(value) {
    this.#count = value;
  }
}

let counter = new Counter();
counter.increment();
console.log(counter.getCount()); // 1
console.log(counter.count); // 1

```

在上面的代码中，`#count` 属性是私有成员，只能通过 `increment` 和 `getCount` 方法访问。同时，通过 `get` 和 `set` 方法定义了公有成员 `count`，可以直接访问。

总的来说，JavaScript 中并没有内置的私有成员和公有成员的概念，但可以通过闭包和 ES6 类和访问控制符来模拟这种行为。

Q:JS 加载过程阻塞，解决方法

JS 加载过程可能会阻塞页面的渲染和交互，影响用户体验。为了解决这个问题，可以采取以下几种方法：

1.  将 JS 代码放在页面底部：将 JS 代码放在页面底部可以让页面的 HTML 和 CSS 先加载和渲染完成，用户可以先看到页面的内容，而不必等待 JS 代码加载完成。
    
2.  使用 defer 和 async 属性：defer 属性指示浏览器立即加载 JS 文件，但是在文档解析完毕后再执行 JS 代码。async 属性则是指示浏览器立即加载 JS 文件，并且在下载完成后立即执行 JS 代码，不会阻塞页面的渲染，但是代码执行的先后顺序可能不同。
    
3.  使用 CDN 加速：将 JS 文件存放在 CDN 上，利用 CDN 的分布式节点，可以让用户从最近的节点下载文件，提高文件下载的速度，缩短加载时间。
    
4.  压缩和合并 JS 文件：将多个 JS 文件合并成一个文件，可以减少 HTTP 请求的次数，提高加载速度。同时，还可以通过压缩 JS 文件的方式减小文件的体积，加快加载速度。
    

Q:怎么实现一个计算一年中有多少周

可以使用 JavaScript 来计算一年中有多少周，具体实现方法如下：

```
function getWeeksInYear(year) {
  const firstDayOfYear = new Date(year, 0, 1);
  const daysOffset = firstDayOfYear.getDay();
  const daysInYear = (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0 ? 366 : 365;
  return Math.ceil((daysInYear - (7 - daysOffset)) / 7) + 1;
}

console.log(getWeeksInYear(2022)); // 输出 53

```

这个函数的实现思路是：

*   获取一年中的第一天 `firstDayOfYear`，使用 `new Date(year, 0, 1)` 实现。
*   计算第一天是星期几，使用 `firstDayOfYear.getDay()` 实现，得到的是 0-6 的数字，0 表示星期日。
*   计算一年有多少天，如果是闰年则有 366 天，否则有 365 天。闰年的判断方法是：年份能被 4 整除但不能被 100 整除，或者能被 400 整除。
*   计算一年中的第一周有几天，即 `(7 - daysOffset)` 天。
*   从一年中减去第一周的天数，得到剩余天数 `daysInYear - (7 - daysOffset)`，然后除以 7，得到的是一年中有多少周（向下取整）。
*   最后加上第一周，即 `Math.ceil((daysInYear - (7 - daysOffset)) / 7) + 1`。

注意，这个方法是按照 ISO 标准计算一年中的周数，即一周的第一天是周一，并且第一周必须包含当年的 4 日。不同地区可能有不同的计算方式。

Q:讲一讲 Event Loop

Event Loop 是 JavaScript 的一种运行机制，用于协调调用堆栈（call stack）和消息队列（message queue）之间的事件循环。在 JavaScript 中，代码是单线程执行的，Event Loop 机制就是为了在单线程执行中实现异步操作。

当我们编写 JavaScript 代码时，所有代码都是按照顺序进入调用堆栈执行的。如果调用堆栈中的代码执行时间过长，可能会阻塞后续代码的执行，导致页面出现假死状态。

为了解决这个问题，JavaScript 引入了异步编程的机制。异步编程中，当需要执行一个耗时的操作时，不会一直等待操作结束，而是将这个操作放到消息队列中，并注册一个回调函数。当操作结束后，会将对应的回调函数放到消息队列的末尾。当调用堆栈中的代码执行完毕后，就会从消息队列中取出任务，放入调用堆栈中执行。

Event Loop 机制的核心就是不断地检查调用堆栈和消息队列。当调用堆栈为空时，Event Loop 就会从消息队列中取出任务，放入调用堆栈中执行。

需要注意的是，JavaScript 中存在微任务（microtask）和宏任务（macrotask）之分。微任务会优先于宏任务执行，因此当调用堆栈为空时，Event Loop 会先检查是否有微任务需要执行，如果有，则会执行所有微任务，直到微任务队列为空后再执行宏任务。常见的微任务包括 Promise 的 then 方法、MutationObserver 和 process.nextTick（Node.js 环境中）。常见的宏任务包括 setTimeout、setInterval、setImmediate（Node.js 环境中）和 DOM 事件。

Event Loop 机制是 JavaScript 异步编程的基础，了解 Event Loop 的原理和机制有助于我们编写更高效的 JavaScript 代码。