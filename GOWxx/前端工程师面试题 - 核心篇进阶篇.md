
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码

> 前端工程师面试题 - 核心进阶篇 - ChatGPT plus 答案版。 本册参照《2022年前端工程师面试题》核心、进阶，由 [GOWxx](https://github.com/GOWxx) 于 2023.3.1 操作并整理。

Q:你好，ChatGPT！我希望你扮演一位 高级前端工程师/前端专家 岗位面试的面试者(interviewee)，积极回答面试官的问题，努力展现你的能力与经验，争取通过面试，取得 offer. 接下来我会问你一些问题，希望你尽力作答。

您好！作为一个人工智能语言模型，我将尽我最大的努力来回答您的问题。让我们开始吧！

Q:JSONP 的缺点

JSONP 是一种通过动态添加`<script>`标签来实现跨域请求数据的技术，它具有以下缺点：

1.  安全问题：由于 JSONP 的工作方式是通过 `<script>` 标签加载数据，因此如果服务器返回的 JSONP 数据被恶意修改，那么将会导致安全问题，例如注入恶意脚本。
    
2.  只支持 GET 方法：JSONP 只支持通过 GET 方法请求数据，这意味着无法使用其他 HTTP 方法（例如 POST）来发送数据，从而限制了它的应用场景。
    
3.  只支持单个请求：由于 JSONP 的实现方式是通过动态添加 `<script>` 标签来请求数据，因此它只支持单个请求。这对于一些需要同时请求多个数据源的应用场景来说，不是一个很好的选择。
    
4.  依赖于客户端的实现：JSONP 的实现方式需要客户端（浏览器）支持 JavaScript，并且需要客户端开发人员自己实现一个回调函数来处理数据。这样会使代码的复杂度增加，并且会产生一些兼容性问题。
    

因此，在使用 JSONP 技术时，我们需要权衡其优缺点，并谨慎选择是否使用 JSONP。在一些需要高度安全性的场景，我们应该考虑使用其他更为安全可靠的技术来实现跨域请求。

Q:跨域（jsonp，ajax）

跨域是指在同一个域名下的不同页面之间，浏览器可以自由地进行数据交互，但是在不同域名之间进行数据交互时，由于浏览器的同源策略限制，数据交互将受到限制。

为了解决跨域的问题，我们可以使用以下两种技术来实现数据交互：

1.  JSONP（JSON with Padding）：JSONP 通过动态创建 script 标签的方式来实现跨域请求数据。它利用 script 标签的 src 属性是不受同源策略限制的特点，向服务器请求一个包含数据的 js 文件，并在请求 url 中携带一个回调函数名，服务器将请求结果包裹在该回调函数中返回给客户端。客户端通过回调函数获取服务器返回的数据。JSONP 的缺点在上一道题中已经进行了介绍。
    
2.  AJAX（Asynchronous JavaScript and XML）：AJAX 是利用 XMLHttpRequest 对象来实现异步数据交互。通过 XMLHttpRequest 对象，客户端可以向服务器发送请求并接收响应，从而实现异步数据交互。但是，由于同源策略的限制，AJAX 无法跨域请求数据。为了解决这个问题，可以通过在服务器端设置 CORS（Cross-Origin Resource Sharing）来允许跨域访问。CORS 通过在响应头中添加 Access-Control-Allow-Origin 字段来指定允许访问的域名。除了CORS，还可以使用其他的跨域技术，例如代理和JSONP等。
    

总之，JSONP 和 AJAX 都是常用的跨域技术，开发人员需要根据实际需求选择适合的技术来实现数据交互。

Q:如何实现跨域

实现跨域的方法有多种，下面列举一些常用的方法：

1.  JSONP（JSON with Padding）：JSONP 通过动态创建 `<script>` 标签的方式来实现跨域请求数据。它利用 `<script>` 标签的 src 属性是不受同源策略限制的特点，向服务器请求一个包含数据的 js 文件，并在请求 url 中携带一个回调函数名，服务器将请求结果包裹在该回调函数中返回给客户端。客户端通过回调函数获取服务器返回的数据。
    
2.  CORS（Cross-Origin Resource Sharing）：CORS 是浏览器实现的一种跨域资源共享标准，通过在响应头中添加 Access-Control-Allow-Origin 字段来指定允许访问的域名。开发人员在服务端进行相应的配置，使得浏览器可以从其他域名获取数据。
    
3.  代理：使用代理服务器转发请求，客户端通过向代理服务器发起请求，代理服务器再向真实的服务器请求数据，从而实现跨域数据交互。这种方式需要服务器端进行相应的配置。
    
4.  window.postMessage()：该 API 允许在两个窗口之间安全地传递消息。客户端通过向目标窗口发送消息并等待响应，从而实现跨域数据交互。
    
5.  WebSocket：WebSocket 是一种浏览器与服务器之间双向通信的技术，由于它不受同源策略的限制，可以实现跨域数据交互。
    

总之，实现跨域有多种方法，开发人员需要根据实际需求选择适合的技术来实现数据交互。同时，为了确保数据的安全性，我们应该谨慎使用跨域技术，确保跨域请求不会带来安全风险。

Q:dom 是什么，你的理解？

DOM（Document Object Model，文档对象模型）是用于表示和操作 HTML 和 XML 文档的编程接口。DOM 将文档表示为由节点（node）和对象（object）组成的树形结构，每个节点都表示文档中的一个元素、属性、文本或注释等。通过 DOM 接口，开发人员可以通过 JavaScript 来动态地创建、访问和修改文档的内容和结构。

DOM 由三个核心部分组成：

1.  文档对象模型（Document Object Model）：表示整个文档树，包括文档元素、文本节点、注释节点等。
    
2.  HTML 对象模型（HTML Object Model）：表示 HTML 文档的元素和属性。
    
3.  浏览器对象模型（Browser Object Model）：表示浏览器窗口和框架，例如 window 和 location 对象等。
    

开发人员可以使用 DOM 提供的 API 来操作文档树中的节点和对象，例如添加、删除、替换、移动节点，修改节点的属性和文本内容等。通过 DOM，开发人员可以动态地改变页面的内容和样式，实现一些动态交互效果。

总之，DOM 是一种用于表示和操作 HTML 和 XML 文档的编程接口，它将文档表示为节点和对象的树形结构，并提供了一系列的 API，方便开发人员对文档进行动态操作。

Q:关于 dom 的 api 有什么

DOM API 是一组用于操作 HTML 和 XML 文档节点的接口，这些接口定义了一些属性和方法，可以通过 JavaScript 来访问和操作文档的内容和结构。下面列举一些常用的 DOM API：

1.  document.getElementById(id)：返回指定 ID 的元素节点。
    
2.  document.querySelector(selector)：返回符合指定 CSS 选择器的第一个元素节点。
    
3.  element.innerHTML：获取或设置元素的 HTML 内容。
    
4.  element.textContent：获取或设置元素的文本内容。
    
5.  element.getAttribute(name)：获取元素的指定属性值。
    
6.  element.setAttribute(name, value)：设置元素的指定属性值。
    
7.  element.classList：获取元素的类名列表。
    
8.  element.style：获取或设置元素的样式属性。
    
9.  element.appendChild(node)：将一个节点添加到元素的子节点列表的末尾。
    
10.  element.removeChild(node)：从元素的子节点列表中移除指定节点。
    
11.  element.addEventListener(type, listener[, options])：为元素添加事件监听器。
    
12.  element.removeEventListener(type, listener[, options])：从元素移除事件监听器。
    
13.  element.getBoundingClientRect()：返回元素的大小及其相对于视口的位置。
    

总之，DOM API 提供了一系列用于操作 HTML 和 XML 文档的接口，可以让开发人员方便地访问和操作文档的内容和结构，实现一些动态交互效果。开发人员可以根据实际需求选择适合的 DOM API 进行操作。

Q:ajax 返回的状态

在使用 AJAX 进行异步请求时，会返回一个 XMLHttpRequest 对象，该对象的 readyState 属性表示当前请求的状态。readyState 的值是一个从 0 到 4 的整数，表示当前请求的不同阶段。以下是各个阶段的含义：

0: 请求未初始化。XMLHttpRequest 对象已创建，但尚未调用 open 方法。

1: 服务器连接已建立。open 方法已被调用，但 send 方法尚未被调用。

2: 请求已接收。send 方法已被调用，并且已接收到服务器返回的响应头。

3: 请求处理中。正在接收服务器的响应体。

4: 请求已完成，且响应已就绪。XMLHttpRequest 对象已接收到服务器返回的完整响应。

在请求的不同阶段，我们可以通过检查 readyState 的值来了解当前请求的状态，从而根据需要进行相应的操作，例如在 readyState 为 4 时，可以通过 XMLHttpRequest 对象的 responseText 或者 responseXML 属性获取服务器返回的数据，从而更新页面的内容。

除了 readyState 属性之外，XMLHttpRequest 对象还有一个 status 属性，表示服务器返回的 HTTP 状态码。常见的状态码包括：

200：请求成功。

404：请求的资源不存在。

500：服务器内部错误。

总之，在使用 AJAX 进行异步请求时，了解各个状态码的含义以及如何处理不同状态的响应非常重要，可以帮助我们更好地进行开发和调试。

Q:实现一个 Ajax

下面是一个简单的示例代码，使用 JavaScript 实现基本的 AJAX 请求：

```
// 创建 XMLHttpRequest 对象
var xhr = new XMLHttpRequest();

// 设置请求的类型、URL 以及是否异步
xhr.open('GET', '/example/api/data', true);

// 设置响应类型
xhr.responseType = 'json';

// 监听状态改变事件
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    // 请求成功，处理响应数据
    var data = xhr.response;
    console.log(data);
  } else if (xhr.readyState === 4 && xhr.status !== 200) {
    // 请求失败
    console.log('请求失败');
  }
};

// 发送请求
xhr.send();

```

以上代码创建了一个 XMLHttpRequest 对象，设置了请求的类型、URL 以及是否异步，设置了响应类型为 JSON，监听了状态改变事件，当 readyState 为 4 且 status 为 200 时，表示请求成功，可以通过 xhr.response 获取响应数据。当 status 不为 200 时，表示请求失败。最后通过 send 方法发送请求。

当然，以上代码只是一个简单的示例，实际使用中还需要根据具体的需求进行修改。例如，需要根据实际情况设置请求的类型（GET 或 POST）、URL 和参数等，并且需要处理请求失败的情况等。

Q:如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域

要实现 AJAX 请求，可以使用 XMLHttpRequest 对象，该对象提供了一组 API，可以通过 JavaScript 来异步请求数据。以下是一些基本的步骤：

1.  创建 XMLHttpRequest 对象：使用 new XMLHttpRequest() 来创建一个 XMLHttpRequest 对象。
    
2.  设置请求的类型、URL 和参数：使用 open() 方法设置请求的类型（GET 或 POST）、URL 和参数等。
    
3.  设置响应类型和编码：使用 responseType 和 charset 属性设置响应类型和编码方式。
    
4.  监听状态改变事件：使用 onreadystatechange 事件来监听状态的改变。
    
5.  发送请求：使用 send() 方法发送请求。
    

如果有多个 AJAX 请求需要按照某种顺序执行，可以使用回调函数或者 Promise 来实现。例如，可以在一个 AJAX 请求完成后，再发起下一个请求，并将上一个请求的结果作为参数传递给下一个请求的回调函数。这样可以保证 AJAX 请求的顺序执行。

处理 AJAX 跨域问题有多种方法，例如使用 JSONP、CORS、代理、WebSocket、postMessage 等。其中，JSONP 是一种常用的跨域技术，它通过动态创建 `<script>` 标签来实现跨域请求数据，服务器将请求结果包裹在回调函数中返回给客户端。使用 JSONP 的时候，需要注意安全问题，确保回调函数的安全性。

除了 JSONP，CORS 也是一种常用的跨域解决方案，它通过在服务器端设置 Access-Control-Allow-Origin 字段来允许跨域请求。使用 CORS 的时候，需要注意浏览器的兼容性问题，以及服务器的安全问题。其他跨域技术也各有优缺点，开发人员需要根据实际情况选择适合的解决方案。

Q:写出原生 Ajax

以下是一个使用原生 JavaScript 实现 AJAX 请求的基本示例：

```
// 创建 XMLHttpRequest 对象
var xhr = new XMLHttpRequest();

// 监听状态改变事件
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    // 请求成功，处理响应数据
    var data = xhr.responseText;
    console.log(data);
  } else if (xhr.readyState === 4 && xhr.status !== 200) {
    // 请求失败
    console.log('请求失败');
  }
};

// 设置请求的类型、URL 以及是否异步
xhr.open('GET', '/example/api/data', true);

// 发送请求
xhr.send();

```

以上代码创建了一个 XMLHttpRequest 对象，监听了状态改变事件，当 readyState 为 4 且 status 为 200 时，表示请求成功，可以通过 xhr.responseText 获取响应数据。当 status 不为 200 时，表示请求失败。最后通过 open 方法设置请求的类型、URL 以及是否异步，并通过 send 方法发送请求。

需要注意的是，使用原生 JavaScript 实现 AJAX 请求需要手动处理各个状态的改变，相对来说比较繁琐。因此，在实际开发中，我们通常会使用封装好的 AJAX 库来简化操作。常用的 AJAX 库包括 jQuery、axios、fetch 等。

Q:如何实现一个 ajax 请求？如果我想发出两个有顺序的 ajax 需要怎么做？

要实现 AJAX 请求，可以使用 XMLHttpRequest 对象，该对象提供了一组 API，可以通过 JavaScript 来异步请求数据。以下是一些基本的步骤：

1.  创建 XMLHttpRequest 对象：使用 new XMLHttpRequest() 来创建一个 XMLHttpRequest 对象。
    
2.  设置请求的类型、URL 和参数：使用 open() 方法设置请求的类型（GET 或 POST）、URL 和参数等。
    
3.  设置响应类型和编码：使用 responseType 和 charset 属性设置响应类型和编码方式。
    
4.  监听状态改变事件：使用 onreadystatechange 事件来监听状态的改变。
    
5.  发送请求：使用 send() 方法发送请求。
    

如果有多个 AJAX 请求需要按照某种顺序执行，可以使用回调函数或者 Promise 来实现。例如，可以在一个 AJAX 请求完成后，再发起下一个请求，并将上一个请求的结果作为参数传递给下一个请求的回调函数。这样可以保证 AJAX 请求的顺序执行。

以下是一个使用 Promise 实现 AJAX 请求的示例代码，可以发出两个有顺序的 AJAX 请求：

```
function ajax(url) {
  return new Promise(function(resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(xhr.responseText);
        } else {
          reject(xhr.status);
        }
      }
    };
    xhr.open('GET', url, true);
    xhr.send();
  });
}

// 发出两个有顺序的 AJAX 请求
ajax('/example/api/data1')
  .then(function(data) {
    console.log(data);
    return ajax('/example/api/data2');
  })
  .then(function(data) {
    console.log(data);
  })
  .catch(function(error) {
    console.log(error);
  });

```

以上代码定义了一个 ajax 函数，使用 Promise 包装 AJAX 请求，如果请求成功则调用 resolve 方法，否则调用 reject 方法。在主函数中，先发出第一个 AJAX 请求，当请求成功后再发出第二个请求，保证了两个请求的顺序执行。如果发生错误，则调用 catch 方法处理异常情况。

需要注意的是，Promise 的链式调用可以简化 AJAX 请求的顺序执行，同时还可以方便地处理异常情况。另外，使用 ES6 的 async/await 语法也可以方便地实现异步请求的顺序执行。例如：

```
async function fetchData() {
  try {
    const data1 = await ajax('/example/api/data1');
    console.log(data1);
    const data2 = await ajax('/example/api/data2');
    console.log(data2);
  } catch (error) {
    console.log(error);
  }
}

fetchData();

```

以上代码使用 async/await 语法实现了两个有顺序的 AJAX 请求，与 Promise 的方式类似。需要注意的是，在使用 async/await 时需要在函数前面加上 async 关键字，以及在异步请求前面加上 await 关键字。

Q:Fetch 和 Ajax 比有什么优缺点？

Fetch 和 AJAX 都是常用的客户端向服务器发送请求的方式。以下是它们的优缺点比较：

Fetch 的优点：

1.  简洁和语义化：Fetch 提供了一种简洁和语义化的方式来发送 HTTP 请求，使用起来比较直观，易于理解。
    
2.  支持 Promise：Fetch 是基于 Promise 设计的，可以使用 Promise 的方式来处理异步请求，可以方便地进行顺序执行和错误处理。
    
3.  更好的 CORS 支持：Fetch 支持 CORS，可以在客户端实现跨域请求。
    
4.  可以自定义请求头和请求体：Fetch 支持自定义请求头和请求体，可以方便地添加额外的请求参数。
    
5.  可以使用 ES6 的新特性：Fetch 是标准的 Web API，可以使用 ES6 的新特性，例如 async/await 等。
    

Ajax 的优点：

1.  更好的兼容性：Ajax 是老式的 Web API，已经被广泛使用和测试，具有更好的兼容性。
    
2.  可以取消请求：Ajax 支持取消请求，可以在请求过程中取消请求。
    
3.  支持 JSONP：Ajax 支持 JSONP，可以在客户端实现跨域请求。
    
4.  可以更加灵活地处理请求：Ajax 可以通过一系列事件处理程序来处理请求，可以更加灵活地处理请求。
    

综上所述，Fetch 和 Ajax 都有各自的优缺点，需要根据实际需求选择适合的方式。如果需要在现代浏览器中开发应用，可以优先考虑使用 Fetch，因为它具有更好的语义化、Promise 支持、CORS 支持和 ES6 特性等优点。如果需要考虑兼容性，或者需要使用 Ajax 独有的特性，可以使用 Ajax。需要注意的是，在实际开发中，可以使用封装好的 AJAX 库来简化操作，例如 jQuery、axios 等。

Q:Fetch 和 Ajax 各自的缺点？

Fetch 和 AJAX 都是常用的客户端向服务器发送请求的方式。以下是它们的一些缺点：

Fetch 的缺点：

1.  兼容性问题：Fetch 是 HTML5 中新增的 Web API，对于旧版本的浏览器不太支持，需要使用 polyfill 或者其他方式来解决兼容性问题。
    
2.  没有原生支持超时和取消：Fetch API 没有原生支持请求超时和取消功能，需要手动处理。
    
3.  无法监测进度：Fetch 无法监测上传和下载进度。
    
4.  存在跨域问题：由于 Fetch 的跨域策略比较严格，如果要进行跨域请求，需要服务器端支持 CORS。
    
5.  无法直接处理二进制数据：Fetch API 只支持 Text 和 JSON 类型的响应数据，无法直接处理二进制数据。
    

Ajax 的缺点：

1.  代码冗余：使用原生的 AJAX API 实现请求需要编写大量的冗余代码，使代码变得复杂且难以维护。
    
2.  回调地狱：使用原生的 AJAX API 实现请求容易陷入回调地狱，使代码变得难以理解和维护。
    
3.  可读性差：使用原生的 AJAX API 实现请求代码可读性较差，需要花费较多时间理解和修改。
    
4.  安全问题：使用原生的 AJAX API 实现请求容易出现安全问题，例如跨站脚本攻击（XSS）等。
    
5.  不支持 Promise：原生的 AJAX API 不支持 Promise，使得代码难以实现顺序执行和错误处理。
    

综上所述，Fetch 和 AJAX 都有各自的优缺点。需要根据实际需求选择适合的方式，并根据实际情况进行兼容性处理、错误处理和安全处理。同时，可以使用封装好的 AJAX 库来简化操作，例如 jQuery、axios 等。

Q:知道 PWA 吗

是的，PWA 是渐进式 Web 应用程序（Progressive Web App）的缩写，是一种通过 Web 技术实现类似原生应用的应用程序。PWA 的特点包括：

1.  可靠性：PWA 能够离线访问，并具有自适应能力，能够根据网络环境调整优化策略。
    
2.  快速响应：PWA 使用缓存技术和 Service Worker 来提高响应速度和性能。
    
3.  渐进式：PWA 能够逐渐地增强应用程序的功能和能力，兼容性好，可以逐步替代传统的应用程序。
    
4.  可发现性：PWA 能够像网站一样被搜索引擎索引，并且能够通过链接分享和推广。
    
5.  安全性：PWA 通过 HTTPS 协议来保证数据的安全性和隐私性。
    
6.  可安装性：PWA 可以安装到设备上，就像原生应用一样，通过应用商店或者 Add to Home Screen 等方式安装。
    

PWA 可以在移动端、桌面端和其他终端使用，并且能够跨平台，实现类似原生应用的体验。PWA 是未来 Web 应用程序的趋势之一，已经得到了众多公司和开发者的支持和使用，例如 Twitter、Pinterest、Uber 等。

Q:移动布局方案

移动布局方案主要是为了解决不同移动设备的屏幕大小和分辨率的差异，使网页在各种移动设备上能够自适应地展示。

以下是常用的移动布局方案：

1.  固定布局：使用固定像素值布局，适用于固定分辨率的移动设备，例如移动端游戏。
    
2.  流式布局：使用百分比值来布局，适用于屏幕宽度变化较大的移动设备，例如电视机和大屏幕手机。
    
3.  弹性布局：使用弹性盒子布局（Flexbox）或网格布局（Grid）来布局，适用于不同屏幕大小和方向的移动设备。
    
4.  响应式布局：使用 CSS3 的媒体查询（Media Queries）来根据屏幕尺寸和分辨率等信息来调整布局，适用于不同屏幕大小和分辨率的移动设备。
    
5.  rem 布局：使用 rem 单位来进行布局，根据根元素的字体大小来调整布局，适用于不同屏幕大小和分辨率的移动设备。
    
6.  vw/vh 布局：使用 vw 和 vh 单位来进行布局，根据屏幕宽度和高度的百分比来调整布局，适用于不同屏幕大小和方向的移动设备。
    

需要注意的是，不同的移动布局方案各有优缺点，需要根据实际情况选择适合的方案。同时，为了提高开发效率和代码质量，可以使用现代的 CSS 框架（如 Bootstrap、Semantic UI 等）或者 CSS 预处理器（如 Sass、Less 等）来实现移动布局。

Q:谈一谈 Rem 和 Em

Rem 和 Em 都是 CSS 中的长度单位，主要用于实现网页的响应式布局，使网页在不同设备上自适应地展示。

Rem：是相对于根元素（html）字体大小的单位。1rem 等于根元素的字体大小，如果根元素字体大小为 16px，则 1rem 等于 16px。Rem 的优点是可以根据根元素的字体大小来调整布局，适用于不同屏幕大小和分辨率的移动设备。同时，Rem 也具有兼容性好、使用方便等优点。缺点是在某些情况下可能需要进行嵌套计算，稍微有点麻烦。

Em：是相对于当前元素的字体大小的单位。例如，如果一个元素的字体大小为 16px，1em 等于 16px。Em 的优点是可以根据当前元素的字体大小来调整布局，适用于某些特定的场景，例如字体大小缩放。同时，Em 也具有兼容性好、使用方便等优点。缺点是在多层嵌套的情况下，可能会出现意料之外的计算结果，需要进行注意。

两者的区别在于，Rem 是相对于根元素的字体大小计算的，而 Em 是相对于当前元素的字体大小计算的。如果需要根据根元素的字体大小来调整布局，可以使用 Rem；如果需要根据当前元素的字体大小来调整布局，可以使用 Em。在实际开发中，Rem 更加常用，因为它更加适合于响应式布局。不过，在某些特殊情况下，Em 也有它的用武之地。同时，需要注意的是，使用 Rem 和 Em 时，也需要考虑兼容性和计算方式等问题。

Q:rem 单位如何转换为像素值

Rem 是相对于根元素（html）字体大小的单位。如果根元素字体大小为 16px，那么 1rem 等于 16px。因此，要将 Rem 转换为像素值，只需要将 Rem 的值乘以根元素的字体大小即可。

例如，如果某个元素的字体大小设置为 2rem，而根元素的字体大小为 16px，则这个元素的实际字体大小为 32px（2 x 16px）。如果根元素的字体大小为 20px，则这个元素的实际字体大小为 40px（2 x 20px）。

在实际开发中，为了方便计算，可以将根元素的字体大小设置为 10px，这样 1rem 等于 10px，乘除计算更加方便。

需要注意的是，Rem 的值是相对于根元素的字体大小计算的，因此如果根元素的字体大小改变了，那么所有使用 Rem 的元素的大小都会发生改变。同时，如果在某些情况下需要进行嵌套计算，需要注意计算顺序和准确性。

Q:em 是如何转换成 px 的

Em 是相对于当前元素的字体大小的单位。如果当前元素的字体大小为 16px，而该元素的子元素的字体大小设置为 2em，那么这个子元素的字体大小为 32px（2 x 16px）。

要将 Em 转换为像素值，只需要将 Em 的值乘以当前元素的字体大小即可。例如，如果某个元素的字体大小为 16px，而它的子元素的字体大小设置为 2em，那么这个子元素的实际字体大小为 32px（2 x 16px）。

需要注意的是，Em 的值是相对于当前元素的字体大小计算的，因此如果当前元素的字体大小改变了，那么所有使用 Em 的子元素的大小都会发生改变。同时，如果在多层嵌套的情况下，可能会出现意料之外的计算结果，需要进行注意。

在实际开发中，由于 Em 的计算方式比较复杂，同时也容易出现意料之外的计算结果，因此 Rem 更加常用，而 Em 通常只在特殊场景下使用，例如字体大小缩放等。如果需要进行响应式布局，Rem 更加方便和实用。

Q:根 html 的元素将会继承浏览器中设置的字体大小

是的，根元素（html）中的字体大小是网页中所有元素的基准字体大小，它会影响到整个网页的布局和样式。如果没有指定根元素的字体大小，它将继承浏览器中设置的字体大小。

在 CSS 中，可以通过设置根元素的 font-size 属性来改变根元素的字体大小，例如：

```
html {
  font-size: 16px;
}

```

上述代码将根元素的字体大小设置为 16px。如果在网页中没有指定其他元素的字体大小，那么它们的字体大小将默认继承根元素的字体大小。

需要注意的是，根元素的字体大小设置过大或过小都可能会影响到网页的布局和样式，因此应该根据实际情况选择合适的字体大小。同时，为了实现响应式布局，可以使用 Rem 或者 Em 等相对单位来设置元素的字体大小，这样可以根据根元素的字体大小来调整布局，适应不同屏幕大小和分辨率的移动设备。

Q:当 em 单位设置在 html 元素上时

当 Em 单位设置在根元素（html）上时，Em 单位将相对于浏览器默认字体大小（16px）进行计算。例如，如果根元素的字体大小设置为 1.5em，则它的实际字体大小为 24px（1.5 x 16px）。

需要注意的是，Em 的计算方式是相对于当前元素的字体大小进行计算的。而当 Em 单位设置在根元素上时，它相对的是浏览器默认字体大小。因此，在某些情况下，这可能会导致计算结果与预期不符。

在实际开发中，为了避免这种情况的发生，通常会将根元素的字体大小设置为固定值，例如 16px 或者 10px，这样可以方便计算和控制。而在其他元素上使用 Em 单位进行布局，则可以根据当前元素的字体大小进行计算，适应不同屏幕大小和分辨率的移动设备。同时，为了提高布局效率和代码质量，也可以使用 CSS 框架（如 Bootstrap、Semantic UI 等）或者 CSS 预处理器（如 Sass、Less 等）来实现移动布局。

Q:flex 布局及优缺点

Flexbox（弹性盒子）是 CSS3 中的一种布局模式，它提供了一种灵活的方式来排列、对齐和分配元素的空间，使网页的布局更加简单和高效。

Flexbox 的优点：

1.  灵活性：Flexbox 可以实现任意方向和任意排列方式的布局，例如水平居中、垂直居中、两端对齐等。
    
2.  自适应性：Flexbox 可以根据容器的大小自动调整元素的布局和排列方式，适应不同的屏幕大小和分辨率。
    
3.  简单易用：Flexbox 的语法简单、直观，可以用少量的 CSS 代码实现复杂的布局效果，减少了开发时间和代码量。
    
4.  维护性：Flexbox 的布局方式更加清晰、直观，可以提高代码的可读性和可维护性，同时也方便后期修改和维护。
    
5.  兼容性好：Flexbox 的兼容性较好，大部分现代浏览器都支持 Flexbox。
    

Flexbox 的缺点：

1.  学习成本较高：Flexbox 的语法和理念与传统的 CSS 布局方式有较大的区别，需要一定的学习成本和适应期。
    
2.  兼容性问题：虽然现代浏览器都支持 Flexbox，但是一些老旧的浏览器（如 IE8、IE9 等）不支持 Flexbox。
    
3.  长度单位问题：由于 Flexbox 布局中元素的尺寸和位置通常使用百分比或者 Flex 单位（类似于比例），因此在一些特殊情况下，可能会出现长度单位计算不准确的问题。
    

总的来说，Flexbox 布局是一种灵活、高效、可维护性好的布局方式，可以提高网页的布局效果和开发效率。虽然存在一些学习成本和兼容性问题，但是在现代浏览器中，Flexbox 已经成为一种主流的布局方式。

Q:Rem 布局及其优缺点

Rem 布局是一种相对于根元素（html）字体大小的布局方式，它主要用于实现网页的响应式布局，使网页在不同设备上自适应地展示。

Rem 布局的优点：

1.  响应式布局：Rem 布局可以根据根元素的字体大小来调整布局，适应不同屏幕大小和分辨率的移动设备，实现响应式布局。
    
2.  相对单位：Rem 使用相对单位进行布局，避免了固定单位带来的布局限制和不便。
    
3.  兼容性好：Rem 的兼容性较好，大部分现代浏览器都支持 Rem。
    
4.  使用方便：Rem 的使用方式与传统的 CSS 单位类似，使用方便。
    
5.  维护性好：Rem 布局代码清晰、简洁，易于维护和修改。
    

Rem 布局的缺点：

1.  兼容性问题：在一些老旧的浏览器（如 IE8、IE9 等）中，可能不支持 Rem 单位。
    
2.  嵌套计算：在某些情况下，可能需要进行嵌套计算，稍微有点麻烦。
    
3.  取整问题：由于 Rem 使用浮点数进行计算，可能存在取整问题，影响布局精度。
    

总的来说，Rem 布局是一种方便、灵活、可维护性好的布局方式，可以实现响应式布局，适应不同的屏幕大小和分辨率。虽然存在一些兼容性和计算问题，但是在现代浏览器中，Rem 布局已经成为一种主流的布局方式。同时，为了避免兼容性和计算问题，还可以使用 CSS 框架（如 Bootstrap、Semantic UI 等）或者 CSS 预处理器（如 Sass、Less 等）来实现移动布局。

Q:谈一谈百分比布局

百分比布局是一种常见的网页布局方式，它使用百分比来表示元素的尺寸和位置，使元素相对于其父元素或者根元素进行布局和排列。

百分比布局的优点：

1.  灵活性：百分比布局可以根据容器的大小和屏幕的分辨率自适应地调整元素的尺寸和位置，适应不同的设备和屏幕大小。
    
2.  相对单位：百分比布局使用相对单位进行布局，避免了固定单位带来的布局限制和不便。
    
3.  简单易用：百分比布局的语法简单、直观，可以用少量的 CSS 代码实现复杂的布局效果，减少了开发时间和代码量。
    
4.  兼容性好：百分比布局的兼容性较好，大部分现代浏览器都支持百分比布局。
    

百分比布局的缺点：

1.  计算问题：由于百分比布局使用百分比进行计算，因此在一些情况下，可能会出现计算不准确的问题，影响布局精度。
    
2.  限制性：百分比布局相对固定单位（如像素、点等）而言，布局方式和效果存在一定的限制，有些情况下难以实现复杂的布局。
    
3.  代码维护：百分比布局代码量较大，如果不合理组织和维护，可能会影响代码质量和开发效率。
    

总的来说，百分比布局是一种常见、灵活、易用的布局方式，可以实现响应式布局，适应不同的屏幕大小和分辨率。但是在一些特殊情况下，可能会存在计算问题和布局限制等缺点。因此，在实际开发中，需要根据具体情况选择合适的布局方式，或者使用多种布局方式组合实现复杂的布局效果。

Q:百分比单位布局应用

百分比单位是一种常用的 CSS 布局单位，它可以用于实现响应式布局，适应不同的屏幕大小和分辨率。以下是一些常见的百分比单位布局应用：

1.  盒子模型的百分比布局

盒子模型中的 width、height、padding、margin 等属性都可以使用百分比单位来设置，例如：

```
.box {
  width: 50%;
  height: 50%;
  padding: 10% 5%;
  margin: 5% auto;
}

```

上述代码将盒子的宽度和高度设置为父元素的 50%，上下内边距设置为盒子宽度的 10%，左右内边距设置为盒子宽度的 5%，外边距设置为 5% 的自适应居中。

2.  文本的百分比布局

文本的字体大小和行高等属性也可以使用百分比单位来设置，例如：

```
p {
  font-size: 120%;
  line-height: 150%;
}

```

上述代码将段落的字体大小设置为父元素的 120%，行高设置为字体大小的 150%。

3.  图片的百分比布局

图片的宽度和高度可以使用百分比单位来设置，例如：

```
img {
  width: 100%;
  height: auto;
}

```

上述代码将图片的宽度设置为父元素的 100%，高度自适应，可以实现图片响应式布局。

4.  布局容器的百分比布局

布局容器（如 body、html 等）的宽度和高度也可以使用百分比单位来设置，例如：

```
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

```

上述代码将 html 和 body 的宽度和高度设置为浏览器窗口的宽度和高度，同时去除了默认的外边距和内边距。

总的来说，百分比单位布局是一种灵活、易用的布局方式，可以实现响应式布局，适应不同的屏幕大小和分辨率。在实际开发中，需要根据具体需求选择合适的百分比单位进行布局，或者与其他布局方式（如 Flexbox、Grid、Rem、Em 等）进行组合实现复杂的布局效果。同时，为了提高布局效率和代码质量，也可以使用 CSS 框架（如 Bootstrap、Semantic UI 等）或者 CSS 预处理器（如 Sass、Less 等）来实现移动布局。

Q:用百分比单位来实现响应式的布局的缺点

使用百分比单位来实现响应式布局确实有一些缺点，主要包括以下几点：

1.  计算问题：由于百分比布局的计算方式是相对于父元素的大小进行计算，因此在一些情况下，可能会出现计算不准确的问题，影响布局精度。
    
2.  布局限制：百分比布局相对于固定单位（如像素、点等）而言，布局方式和效果存在一定的限制，有些情况下难以实现复杂的布局。
    
3.  嵌套计算：在某些情况下，可能需要进行嵌套计算，稍微有点麻烦。
    
4.  兼容性问题：在一些老旧的浏览器（如 IE8、IE9 等）中，可能不支持百分比单位，因此需要做兼容性处理。
    
5.  不利于开发效率：百分比布局的代码量相对较大，如果不合理组织和维护，可能会影响代码质量和开发效率。
    

总的来说，虽然百分比单位可以用于实现响应式布局，但是存在一些缺点。在实际开发中，需要根据具体需求选择合适的布局方式，或者与其他布局方式（如 Flexbox、Grid、Rem、Em 等）进行组合实现复杂的布局效果。同时，为了提高布局效率和代码质量，也可以使用 CSS 框架（如 Bootstrap、Semantic UI 等）或者 CSS 预处理器（如 Sass、Less 等）来实现移动布局。

Q:移动端适配 1px 的问题

在移动端中，由于设备像素和 CSS 像素的差异，导致在某些设备上会出现 1px 线条粗细问题，即本应该是 1px 的线条，在某些屏幕上显示为 2px 或更宽。

解决这个问题的主要方法有以下几种：

1.  使用 viewport 缩放

可以通过设置 meta 标签中的 viewport 属性，将视口缩放到一个较小的值，可以在一定程度上解决 1px 线条粗细问题。

```
<meta >

```

2.  使用 border-image 和 box-shadow

可以使用 CSS3 中的 border-image 和 box-shadow 属性来实现细线条的效果，可以解决 1px 线条粗细问题。

```
.border {
  border: none;
  border-image: url('path/to/image.png') 0 0 1 stretch;
}

.shadow {
  box-shadow: 0 1px 1px rgba(0, 0, 0, .15);
}

```

3.  使用 transform

可以使用 CSS3 中的 transform 属性来进行缩放，使得元素的宽度或高度增加或减少 0.5px，从而解决 1px 线条粗细问题。

```
.scale {
  transform: scaleY(.5);
}

```

4.  使用伪元素

可以使用 CSS 中的伪元素 ::before 和 ::after，将元素的边框样式设置在伪元素上，从而实现细线条的效果。

```
.line {
  position: relative;
}
.line::before {
  content: '';
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 1px;
  background-color: #000;
  transform-origin: left bottom;
  transform: scaleY(.5);
}

```

总的来说，解决移动端 1px 线条粗细问题的方法较多，需要根据具体情况选择合适的解决方案。同时，在实际开发中，还可以使用 CSS 框架（如 Bootstrap、Semantic UI 等）或者 CSS 预处理器（如 Sass、Less 等）来实现移动布局和 1px 线条解决方案。

Q:移动端性能优化相关经验

移动端性能优化是移动应用开发中非常重要的一环，下面列举一些相关经验：

1.  尽可能减少 HTTP 请求

在移动设备上，网络带宽和连接速度往往比较有限，因此尽可能减少 HTTP 请求对性能优化至关重要。可以通过合并 CSS 和 JS 文件、压缩图片等方式来减少 HTTP 请求，提高页面加载速度。

2.  使用 CSS3 动画代替 JavaScript 动画

CSS3 动画可以使用硬件加速，比 JavaScript 动画效率更高。在实现动画效果时，应尽量使用 CSS3 动画代替 JavaScript 动画，提高性能。

3.  避免在 JavaScript 中使用复杂的选择器

复杂的选择器会使得 JavaScript 查找 DOM 元素的时间变长，从而影响性能。在编写 JavaScript 代码时，应尽量避免使用复杂的选择器，尽可能精简和优化代码。

4.  使用 Web Workers

Web Workers 是 HTML5 新增的 API，它可以在后台线程中执行 JavaScript 代码，从而避免阻塞 UI 线程，提高页面响应速度。在一些复杂的计算场景中，可以考虑使用 Web Workers 来优化性能。

5.  压缩和合并代码

通过压缩和合并代码，可以减少 HTTP 请求和网络传输的时间，提高页面加载速度。在实际开发中，可以使用工具（如 Gulp、Grunt、Webpack 等）来自动化压缩和合并代码。

6.  使用图片懒加载和无限滚动

图片懒加载和无限滚动是移动端性能优化的常见技术。图片懒加载可以延迟加载图片，减少页面加载时间；无限滚动可以动态加载数据，避免一次性加载过多数据，从而提高页面性能。

7.  使用缓存

通过使用缓存，可以减少网络请求和加载时间，提高页面性能。在移动应用开发中，可以使用本地缓存（如 localStorage、IndexedDB 等）和服务器缓存（如 CDN、浏览器缓存等）来优化性能。

总的来说，移动端性能优化需要结合具体场景和需求来进行，需要综合考虑网络带宽、设备性能、页面结构、代码质量等因素，才能实现最佳的性能优化效果。在实际开发中，还可以使用性能分析工具（如 Chrome DevTools、Safari Web Inspector 等）来进行性能分析和调优。

Q:toB 和 toC 项目的区别

toB（Business to Business）和toC（Business to Consumer）是电商领域中常见的两种业务模式，它们有以下几个区别：

1.  目标客户群体不同

toB 主要面向企业客户，涉及的业务范围较广，包括供应链管理、物流配送、支付结算等。toC 则面向普通消费者，主要涉及在线购物、客户服务、社交营销等业务。

2.  交易模式不同

toB 的交易模式通常是长期合作关系，通过谈判和协商来确定交易方式和价格。toC 则通常是短期交易，消费者直接在线购买商品或服务。

3.  商品属性不同

toB 的商品通常是批量化、标准化的，涉及的产品种类较多，包括原材料、生产设备、半成品、成品等。toC 则涉及的商品较为简单，主要是消费品、服务、娱乐等。

4.  营销方式不同

toB 的营销方式通常是针对企业的专业媒体和行业展会，借助多渠道的营销手段来获取客户资源。toC 则更注重社交营销和口碑传播，通过社交媒体、微信公众号、直播等方式来提高品牌知名度和产品曝光率。

5.  用户需求不同

toB 用户更注重供应链的效率和成本控制，通常需要采购大量的商品或服务，对价格敏感性较高。toC 用户更注重购物体验和服务质量，通常会在品质、价格和品牌信誉等方面进行综合考虑。

总的来说，toB 和 toC 项目有着明显的差异，需要根据不同的目标客户、商品属性和营销方式来进行差异化的设计和运营。在实际开发中，需要根据具体情况选择合适的技术架构和运营模式，才能实现最佳的商业价值和用户体验。

Q:讲一讲移动端兼容性的问题和解决方法

移动端兼容性问题是移动应用开发中常见的问题，主要涉及以下几个方面：

1.  浏览器兼容性问题

由于不同浏览器之间的差异，同一个页面在不同浏览器上可能会出现布局、样式、事件等方面的兼容性问题。在解决浏览器兼容性问题时，可以使用 CSS Reset 或者 Normalize.css 等工具来统一样式效果，减少浏览器差异。

2.  设备兼容性问题

由于移动设备的硬件和软件差异，同一个页面在不同设备上可能会出现兼容性问题，例如分辨率、屏幕尺寸、操作系统等方面的差异。在解决设备兼容性问题时，可以使用媒体查询和响应式设计技术，根据不同设备的特点进行页面布局和样式调整。

3.  JavaScript 兼容性问题

由于不同浏览器对 JavaScript 的支持程度不同，同一个页面在不同浏览器上可能会出现 JavaScript 兼容性问题。在解决 JavaScript 兼容性问题时，可以使用 polyfill 或者使用现代的 JavaScript 标准语法和新特性，尽量避免使用过时的 API 和语法。

4.  第三方库兼容性问题

在使用第三方库时，可能会出现与移动设备和浏览器兼容性不一致的问题。在选择第三方库时，应选择稳定、经过测试的库，并尽量避免使用过时的库。

在解决移动端兼容性问题时，可以采用以下几种方法：

1.  采用流行的移动开发框架（如 Ionic、React Native、Flutter 等），这些框架已经考虑了各种兼容性问题，可以减少开发者的工作量。
    
2.  使用 HTML5、CSS3 和 JavaScript 标准语法和新特性，尽量避免使用过时的 API 和语法。
    
3.  进行移动设备的测试，以确保应用在不同设备和浏览器上都能够正常运行。
    
4.  使用 polyfill 或者现代的 JavaScript 标准语法和新特性，尽量避免使用过时的 API 和语法。
    

总的来说，移动端兼容性问题需要结合具体情况进行分析和解决，需要综合考虑不同浏览器、不同设备和不同 API 的差异，以确保应用能够在各种设备和浏览器上正常运行。同时，在实际开发中，还可以使用性能分析工具（如 Chrome DevTools、Safari Web Inspector 等）来进行性能分析和调

Q:讲一讲小程序开发

小程序是一种新型的移动应用，是微信、支付宝等平台提供的一种轻量级应用开发方式，可以在不安装应用的情况下，快速地实现各种功能。下面讲一下小程序开发的相关内容：

1.  小程序的开发语言和框架

小程序的开发语言主要有两种，一种是微信小程序使用的 WXML、WXSS 和 JavaScript，另一种是支付宝小程序使用的 AXML、ACSS 和 JavaScript。在开发小程序时，需要使用相应的开发语言和框架来进行开发。

2.  小程序的开发工具

小程序的开发工具主要有微信开发者工具和支付宝开发者工具，可以在开发过程中提供实时的调试、模拟器等功能，方便开发者进行开发和测试。

3.  小程序的架构和组件

小程序采用了类似于 MVC 的架构模式，将应用分为视图层、逻辑层和数据层三个部分，同时提供了众多的组件和 API，可以方便地实现各种功能。

4.  小程序的发布和管理

小程序的发布需要在相应的平台上进行审核和上线，需要遵循相应的开发规范和审核标准，才能通过审核并上线。同时，需要对已发布的小程序进行管理和维护，及时修复bug、更新功能和优化用户体验。

总的来说，小程序开发需要掌握相应的开发语言和框架，熟悉相应的开发工具和架构模式，同时需要遵循相应的开发规范和审核标准，才能开发出高质量、符合用户需求的小程序。在实际开发中，还需要注重用户体验、性能优化和安全性，从而提高小程序的使用率和商业价值。

Q:2X 图 3X 图适配

2X 图和3X图是指在移动端开发中，为了适应高分辨率的屏幕而提供的两种不同尺寸的图片，2X图的尺寸是1倍，3X图的尺寸是1.5倍。在适配高分辨率屏幕时，通常需要提供2X图和3X图，以适应不同的屏幕分辨率。

在适配2X图和3X图时，可以采用以下几种方法：

1.  使用 @2x 和 @3x 后缀来命名图片，以便系统能够自动识别不同分辨率的图片。例如，将一张图片命名为[image@2x.png](mailto:image@2x.png) 和 [image@3x.png](mailto:image@3x.png)，分别对应2X图和3X图。
    
2.  使用 CSS 属性来指定不同分辨率的图片，例如使用 background-image 属性和 media queries 实现适配不同分辨率的屏幕。
    
3.  使用 JS 动态加载图片，通过判断设备的屏幕分辨率来动态加载相应的图片。
    
4.  使用第三方库或者框架，例如 React Native、Flutter、Ionic 等，这些框架都提供了相应的图片适配机制，可以方便地实现不同分辨率的图片适配。
    

总的来说，在移动端开发中，适配高分辨率屏幕是一个必要的步骤，需要提供不同分辨率的图片，以保证用户体验。在选择适配方法时，需要考虑实际开发情况、技术水平和开发成本等因素，从而选择最适合的适配方案。

Q:图片在安卓上，有些设备模糊问题

在 Android 设备上出现图片模糊的问题，通常是由于像素密度不匹配导致的。Android 设备的屏幕分辨率相对于屏幕尺寸较高，为了保证在同样大小的屏幕上显示相同大小的图像，通常需要提供高分辨率的图片（即2倍或3倍），而低分辨率的图片将会被缩放，导致图片模糊。

为了解决这个问题，可以使用以下方法：

1.  提供高分辨率的图片：针对不同分辨率的 Android 设备提供2倍或3倍的高分辨率图片，可以在高分辨率设备上显示清晰的图片。
    
2.  设置图片的宽度和高度：在设置图片宽度和高度时，可以使用 px 单位来确保图片在不同分辨率的设备上显示一致。同时，也可以使用百分比单位来适应不同的屏幕尺寸。
    
3.  使用 CSS 的 background-size 属性：可以使用 CSS 的 background-size 属性来设置图片的大小和比例，以适应不同分辨率的屏幕。
    
4.  使用响应式图片库：有些第三方库和框架（如 Responsive Images Community Group）提供了响应式图片的功能，可以根据设备的分辨率和屏幕尺寸自动选择适当的图片。
    

总的来说，在 Android 设备上解决图片模糊的问题需要综合考虑设备的分辨率、屏幕尺寸和像素密度等因素，从而采取适当的措施来提供高质量的图片。同时，也需要注意图片的大小和比例，以确保在不同的设备上显示一致。

Q:固定定位布局键盘挡住输入框内容

在使用固定定位布局时，可能会出现键盘挡住输入框内容的问题。这个问题的根本原因是，当键盘弹起时，浏览器会自动调整可视区域的高度，此时如果固定定位元素的位置没有随之调整，就会出现键盘挡住输入框内容的问题。

为了解决这个问题，可以采用以下几种方法：

1.  使用滚动容器：将需要固定定位的元素放在一个滚动容器中，并设置滚动容器的高度，这样当键盘弹起时，滚动容器的高度会自动调整，从而避免了元素被键盘遮挡的问题。
    
2.  监听键盘事件：在键盘弹起和收起的时候，使用 JavaScript 监听键盘事件，根据键盘的高度和可视区域的高度，动态调整固定定位元素的位置。
    
3.  使用 CSS3 媒体查询：使用 CSS3 的媒体查询功能，根据不同设备的屏幕尺寸和像素密度，调整固定定位元素的位置。
    
4.  使用插件或框架：有些插件和框架（如 iScroll、FastClick 等）提供了自动适应键盘的功能，可以方便地解决键盘挡住输入框内容的问题。
    

总的来说，在固定定位布局中，遇到键盘挡住输入框内容的问题需要采用合适的方法进行解决，从而提高用户体验。在选择解决方法时，需要根据实际情况和技术水平选择最合适的方法。

Q:click 的 300ms 延迟问题和点击穿透问题

click事件在移动端中存在两个常见问题，分别是“300ms延迟”和“点击穿透”问题。

1.  300ms 延迟问题

在移动端浏览器中，为了区分单击事件和双击事件，浏览器会对单击事件进行延迟处理，即会在点击后等待300ms后再触发click事件。这种延迟可以增加用户判断双击事件和放大操作的准确性，但也会给用户带来一定的体验延迟。为了解决这个问题，可以采用以下方法：

*   使用FastClick插件来解决。FastClick插件可以通过将click事件转换为touchend事件来避免300ms延迟。
*   使用meta标签来设置视口宽度和缩放比例。这样可以让浏览器正确地解释触摸事件，从而避免300ms延迟。
*   使用CSS样式来设置点击事件的样式，例如使用:hover来模拟click事件。

2.  点击穿透问题

点击穿透问题是指在移动端上，在某些场景下（如弹出层、滑动列表等），在点击一个元素后，会穿透到下面的元素上触发事件。这个问题的原因是，当用户点击一个元素时，浏览器会先触发该元素的touchstart事件和touchend事件，然后在事件冒泡过程中触发下面元素的touchstart事件和click事件，从而导致点击穿透。

为了解决这个问题，可以采用以下方法：

*   使用preventDefault方法阻止touchend事件的默认行为。这样可以避免touchend事件的默认行为（即click事件）触发下面元素的事件。
*   使用事件委托来绑定事件。使用事件委托的方式绑定事件可以将事件绑定在容器元素上，这样就可以在容器元素中统一处理事件，从而避免了点击穿透问题。
*   使用CSS属性pointer-events:none。这个属性可以将元素的鼠标事件禁用，从而避免点击穿透。

总的来说，点击延迟和点击穿透问题在移动端开发中是常见的问题，需要我们合理的使用技术手段和方法来解决。同时，我们也应该注重用户体验和交互设计，从而提高产品的质量和用户满意度。

Q:iphone 及 ipad 下输入框默认内阴影

在 iPhone 和 iPad 上，输入框默认会出现内阴影效果，这是因为浏览器会默认为 input 元素添加 CSS 样式 -webkit-appearance: none，该样式会将 input 元素的默认外观样式去掉，从而导致输入框出现内阴影效果。虽然这个内阴影效果可以提高输入框的可视性和边框的清晰度，但在某些情况下，也会对页面的视觉效果产生负面影响。

为了去掉 iPhone 和 iPad 下输入框的内阴影效果，可以通过以下方法实现：

1.  使用 CSS 样式 -webkit-appearance: none; 来去除默认样式。

```
input[type="text"],input[type="password"],textarea{
  -webkit-appearance:none;
}

```

2.  设置 input 元素的 box-shadow 样式为 none，去除内阴影效果。

```
input[type="text"],input[type="password"],textarea{
  box-shadow:none;
}

```

3.  使用伪类选择器 ::-webkit-input-placeholder，设置输入框的 placeholder 样式。

```
input[type="text"],input[type="password"],textarea::-webkit-input-placeholder{
  color:#ccc;
}

```

总的来说，为了提高页面的视觉效果和用户体验，在去掉 iPhone 和 iPad 下输入框的内阴影效果时，需要根据实际情况和设计需求，选择最合适的方法和样式，从而达到最佳的效果。同时，也需要注意兼容性和维护成本，避免出现不必要的问题和影响。

Q:防止手机中页面放大和缩小

在移动端开发中，有时需要禁止用户对页面进行放大和缩小操作，以确保页面的布局和样式不会被用户随意更改。以下是一些常用的方法，可以帮助我们实现防止手机中页面放大和缩小的效果：

1.  禁用用户缩放

可以在 HTML 页面中添加以下 meta 标签，来禁用用户对页面进行缩放操作。

```
<meta >

```

其中 user-scalable=no 表示禁用用户缩放。

2.  禁用用户双击缩放

可以使用 CSS 属性 touch-action: manipulation 来禁用用户双击缩放。

```
body {
  touch-action: manipulation;
}

```

该属性表示在用户进行手势操作时，浏览器会忽略默认的手势行为，从而避免了双击缩放。

3.  使用 JavaScript 禁用用户缩放

可以使用 JavaScript 来动态设置 viewport 的缩放比例，从而禁用用户缩放。以下是一个简单的示例代码：

```
function disableZoom() {
  var viewport = document.querySelector('meta[]');
  if (viewport) {
    viewport.content = "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-sca;
  }
}

disableZoom();

```

以上是几种常用的方法，可以帮助我们实现防止手机中页面放大和缩小的效果。但是需要注意的是，禁用用户缩放和双击缩放有可能影响到用户体验，因此需要根据实际情况进行取舍。同时，我们还需要保证页面布局和样式的响应性和可适应性，以确保页面在不同设备上的可用性和可访问性。

Q:px、 em、rem、%、vw、vh、wm 这些单位的区别

在网页布局和样式设计中，常见的单位有px、em、rem、%、vw、vh和vmin，每种单位都有自己的特点和用途。

1.  px

px（Pixel）是像素单位，是相对于设备屏幕分辨率而言的。在 Web 开发中，一般使用 px 来指定元素的尺寸和位置。由于 px 单位的尺寸是固定的，因此在不同设备和分辨率下，同样大小的元素可能会在屏幕上显示的不同。

2.  em

em 是相对于父元素的字体大小而言的。例如，如果一个元素的字体大小为16px，它的子元素的字体大小为0.5em，则子元素的字体大小为8px。由于 em 单位的大小是相对于父元素的字体大小，因此它可以用来实现弹性和自适应的布局效果。

3.  rem

rem（Root em）是相对于根元素（即 html 元素）的字体大小而言的。例如，如果根元素的字体大小为16px，一个元素的字体大小为1.5rem，则它的字体大小为24px。由于 rem 单位的大小是相对于根元素的字体大小，因此它可以用来实现整个页面的自适应布局。

4.  %

%（Percent）是相对于父元素的尺寸而言的。例如，如果一个元素的宽度为50%，则它的宽度为父元素宽度的一半。由于 % 单位的大小是相对于父元素的尺寸大小，因此它可以用来实现响应式布局。

5.  vw

vw（Viewport Width）是相对于视口宽度的单位，1vw 等于视口宽度的 1%。例如，如果视口宽度为 1000px，一个元素的宽度为50vw，则它的宽度为 500px。由于 vw 单位的大小是相对于视口宽度的大小，因此它可以用来实现响应式和自适应的布局效果。

6.  vh

vh（Viewport Height）是相对于视口高度的单位，1vh 等于视口高度的 1%。例如，如果视口高度为 500px，一个元素的高度为50vh，则它的高度为 250px。由于 vh 单位的大小是相对于视口高度的大小，因此它可以用来实现响应式和自适应的布局效果。

7.  vmin

vmin（Viewport Minimum）是相对于视口宽度和高度中较小的那个值的单位。例如，如果视口宽度为 1000px，视口高度为 500px，一个元素的宽度为50vmin，则它的宽

Q:继续讲

高度为 250px。由于 vmin 单位的大小是相对于视口宽度和高度中较小的那个值的大小，因此它可以用来实现响应式和自适应的布局效果。

8.  wm

wm（Width Minus）是一个实验性的 CSS 单位，它是相对于元素自身宽度的大小而言的。例如，如果一个元素的宽度为 300px，wm(50px) 则表示元素的宽度为 300px - 50px = 250px。由于 wm 单位目前还处于实验性阶段，并且不被所有浏览器所支持，因此在实际开发中使用的较少。

以上是常见的网页布局和样式单位，每个单位都有其特点和适用场景。在实际开发中，我们需要根据具体情况和需求，选择最合适的单位和方法，从而达到最佳的效果和体验。同时，还需要注意兼容性和可维护性，避免出现不必要的问题和影响。

Q:讲一讲 移动端适配 - dpr

在移动端适配中，dpr（Device Pixel Ratio）是一个非常重要的概念，它代表设备的物理像素和设备独立像素之间的比例关系。在不同的设备上，dpr 的值可能不同，例如，iPhone 6 的 dpr 值为 2，而 iPhone 6 Plus 的 dpr 值为 3。

设备的物理像素指的是设备屏幕上的实际像素点数量，而设备独立像素则是逻辑像素，是指一个 CSS 像素所对应的设备像素数量。例如，在一个 dpr 值为 2 的设备上，一个 CSS 像素对应两个物理像素。为了保证在高清屏幕上显示清晰，一些设备会将一个 CSS 像素对应多个物理像素，这就是 Retina 屏幕的实现原理。

在移动端适配中，dpr 的作用是帮助我们将设计稿中的像素值转换为实际的 CSS 像素值。为了实现移动端适配，我们需要根据设备的 dpr 值和屏幕宽度，来动态计算出合适的 CSS 像素值，并将其应用到页面的样式中。

例如，在一个 dpr 值为 2 的设备上，设备宽度为 750px，我们可以将 750px 分为 750 个 CSS 像素，每个 CSS 像素对应 2 个物理像素，从而得到 375 个物理像素。在编写页面样式时，我们需要使用 375px 作为基础像素值，并使用 rem 等相对单位来实现自适应布局。

总的来说，dpr 是移动端适配中的一个重要概念，它能够帮助我们实现在不同设备上的自适应布局和像素适配，从而提高页面的可用性和可访问性。在实际开发中，我们需要了解和掌握 dpr 的相关知识和计算方法，以便更好地实现移动端适配和开发。同时，还需要注意兼容性和可维护性，避免出现不必要的问题和影响。

Q:移动端扩展点击区城

在移动端开发中，由于手指的触控区域比鼠标的点击区域要大，因此需要对一些按钮和链接等进行扩展点击区域的处理，以提高用户体验和操作的准确性。常用的方法有以下几种：

1.  使用 padding 或 margin 扩大点击区域

通过在按钮或链接的周围添加 padding 或 margin，可以扩大它们的点击区域，从而使用户更容易点击到它们。例如：

```
button {
  padding: 10px;
}

```

2.  使用伪元素扩大点击区域

通过添加伪元素，并设置它们的尺寸和位置，可以扩大按钮或链接的点击区域。例如：

```
button::before {
  content: "";
  position: absolute;
  top: -10px;
  left: -10px;
  right: -10px;
  bottom: -10px;
}

```

3.  使用 JavaScript 扩大点击区域

通过 JavaScript 监听按钮或链接的点击事件，并将事件委托给其父元素或其他容器元素处理，可以实现点击区域的扩展。例如：

```
<button id="my-button">Click me</button>

`<script>`
  const myButton = document.getElementById("my-button");
  myButton.addEventListener("click", function() {
    // do something
  });
  // delegate click event to parent element
  myButton.parentElement.addEventListener("click", function() {
    myButton.click();
  });
</script>

```

通过上述方法，我们可以实现移动端按钮或链接的点击区域扩展，从而提高用户体验和操作的准确性。在实际开发中，我们需要根据具体需求和场景，选择最合适的方法，并注意兼容性和可维护性，避免出现不必要的问题和影响。

Q:上下拉动滚动条时卡顿、慢

在移动端开发中，上下拉动滚动条时卡顿或慢的问题，一般是由以下原因引起的：

1.  页面结构复杂，DOM 元素过多。

过多的 DOM 元素会导致页面渲染缓慢，从而影响滚动性能。为了解决这个问题，可以通过优化页面结构和样式，减少 DOM 元素的数量，以提高页面渲染性能。

2.  图片加载过慢，占用资源过多。

图片是移动端页面中最常见的资源，如果图片加载过慢或占用资源过多，会影响页面滚动的流畅性。为了解决这个问题，可以使用懒加载技术和图片压缩技术，以减少图片加载和占用的资源。

3.  JS 执行耗时过长，影响页面渲染性能。

JS 代码的执行速度也会影响页面滚动的性能。为了避免 JS 执行耗时过长，可以将一些复杂的计算和操作放到 Web Worker 中执行，从而减轻主线程的负担。

4.  使用过多的 CSS 动画效果，影响性能。

CSS 动画效果是移动端页面中常用的交互效果，但如果使用过多，也会影响页面滚动的性能。为了避免这个问题，可以使用 CSS3 动画效果，并尽量减少使用 JS 实现的动画效果。

5.  低端设备性能不足，无法满足高要求的页面渲染。

在移动端开发中，由于设备的硬件性能和系统版本的不同，一些低端设备可能无法满足高要求的页面渲染。为了兼容不同设备，可以适当减少页面的样式和特效，以提高页面的性能和流畅度。

以上是解决移动端页面滚动卡顿和慢的一些常见方法和技巧，需要根据具体情况和需求，选择最合适的方法，并注意兼容性和可维护性，避免出现不必要的问题和影响。

Q:长时间按住页面出现闪退

在移动端开发中，长时间按住页面出现闪退的问题，一般是由以下原因引起的：

1.  内存占用过高，导致页面崩溃。

在移动端开发中，内存占用是一个非常重要的因素，如果内存占用过高，就容易导致页面崩溃和闪退。为了避免这个问题，可以采用一些优化技巧，如减少不必要的 DOM 元素、减少页面样式和 JS 代码等。

2.  嵌套过多的事件监听器，影响性能。

在移动端开发中，如果嵌套过多的事件监听器，会影响页面性能和用户体验。为了避免这个问题，可以使用事件委托或者取消不必要的事件监听器。

3.  JS 执行过长，导致页面卡顿或崩溃。

JS 代码的执行速度也会影响页面的性能和流畅度，如果 JS 执行过长，就容易导致页面卡顿或崩溃。为了避免这个问题，可以使用 Web Worker 技术，将一些复杂的计算和操作放到 Worker 中执行。

4.  页面渲染过程中，出现大量的重绘和回流。

在移动端开发中，页面的渲染过程中，如果出现大量的重绘和回流，也会影响页面的性能和流畅度，从而导致页面卡顿或崩溃。为了避免这个问题，可以采用一些优化技巧，如使用 CSS3 动画效果、合并多个 DOM 操作等。

以上是解决长时间按住页面出现闪退问题的一些常见方法和技巧，需要根据具体情况和需求，选择最合适的方法，并注意兼容性和可维护性，避免出现不必要的问题和影响。同时，还需要定期对页面进行优化和维护，以保持页面的性能和流畅度。

Q:如何实现 ios 和 android 下触摸元素时出现半透明灰色遮罩

在移动端开发中，实现 iOS 和 Android 下触摸元素时出现半透明灰色遮罩的方法如下：

1.  使用 CSS 伪类实现

使用 CSS 伪类来设置元素的样式，实现 iOS 和 Android 下触摸元素时出现半透明灰色遮罩。代码如下：

```
button:active {
  background-color: rgba(0, 0, 0, 0.1);
}

```

2.  使用 JavaScript 实现

使用 JavaScript 监听元素的触摸事件，然后通过设置元素的样式来实现 iOS 和 Android 下触摸元素时出现半透明灰色遮罩。代码如下：

```
const myButton = document.getElementById("my-button");
myButton.addEventListener("touchstart", function() {
  myButton.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
});
myButton.addEventListener("touchend", function() {
  myButton.style.backgroundColor = "";
});

```

通过上述方法，我们可以实现 iOS 和 Android 下触摸元素时出现半透明灰色遮罩的效果。在实际开发中，我们需要根据具体需求和场景，选择最合适的方法，并注意兼容性和可维护性，避免出现不必要的问题和影响。同时，还需要对页面进行测试和调试，以确保实现的效果和性能符合预期要求。

Q:移动端 active 兼容处理 即 伪类：active 失效

在移动端开发中，如果在某些机型或浏览器上出现了伪类 `:active` 失效的问题，可以通过以下方法来解决：

1.  使用 `touchstart` 和 `touchend` 事件代替 `:active` 伪类。

在一些 iOS 和 Android 设备上，伪类 `:active` 不一定有效。我们可以通过使用 `touchstart` 和 `touchend` 事件来代替 `:active` 伪类，实现按钮或链接按下时的效果。代码示例：

```
var button = document.querySelector('.button');
button.addEventListener('touchstart', function () {
  this.classList.add('active');
});
button.addEventListener('touchend', function () {
  this.classList.remove('active');
});

```

2.  通过 JS 主动触发 `:active` 伪类。

在某些机型或浏览器上，伪类 `:active` 可能无法自动触发，我们可以通过 JS 代码来手动触发 `:active` 伪类。代码示例：

```
var button = document.querySelector('.button');
button.addEventListener('touchstart', function () {
  this.classList.add('active');
  setTimeout(() => {
    this.classList.remove('active');
  }, 100);
});

```

通过上述方法，我们可以解决在移动端开发中伪类 `:active` 失效的问题。需要注意的是，不同的浏览器和机型可能存在差异，需要根据具体情况选择最合适的解决方案，并进行兼容性测试和调试，以确保实现的效果和性能符合预期要求。

Q:webkit mask 兼容处理

`webkit-mask` 是 WebKit 内核浏览器提供的一个 CSS 属性，用于设置元素的遮罩效果。然而，在一些非 WebKit 内核浏览器中，`webkit-mask` 属性可能无法生效，需要做兼容处理。

针对 `webkit-mask` 属性兼容性问题，我们可以通过以下方法进行兼容处理：

1.  使用 `mask-image` 属性代替 `webkit-mask` 属性。

`mask-image` 是 CSS3 新增的属性，可以实现类似于 `webkit-mask` 的遮罩效果，同时兼容多种浏览器。代码示例：

```
.mask {
  mask-image: url(./mask.png);
  -webkit-mask-image: url(./mask.png);
}

```

2.  使用 `background` 属性实现遮罩效果。

在一些非 WebKit 内核浏览器中，我们可以通过使用 `background` 属性来实现类似于遮罩的效果。代码示例：

```
.mask {
  background: url(./mask.png) no-repeat;
  background-size: cover;
}

```

3.  使用 SVG 图片实现遮罩效果。

我们可以使用 SVG 图片来实现复杂的遮罩效果，并兼容多种浏览器。代码示例：

```
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 600">
  <defs>
    <mask id="mask" x="0" y="0" width="1200" height="600">
      <rect x="0" y="0" width="1200" height="600" fill="#fff"/>
      <circle cx="600" cy="300" r="200" fill="#000"/>
    </mask>
  </defs>
  <image x="0" y="0" width="1200" height="600" href="./image.jpg" mask="url(#mask)"/>
</svg>

```

通过上述方法，我们可以解决 `webkit-mask` 属性兼容性问题，并实现类似的遮罩效果。需要注意的是，不同的浏览器和机型可能存在差异，需要根据具体情况选择最合适的解决方案，并进行兼容性测试和调试，以确保实现的效果和性能符合预期要求。

Q:transiton 闪屏

在移动端开发中，使用 CSS3 动画 `transition` 属性时可能会出现闪屏问题。这是由于浏览器在进行过渡动画时，需要先计算样式变化后的中间状态，然后再执行动画，导致页面出现闪烁现象。

针对 `transition` 属性闪屏问题，我们可以通过以下方法来解决：

1.  使用 `will-change` 属性优化页面渲染。

`will-change` 属性可以提示浏览器元素即将发生变化，从而提前进行优化，减少页面的闪屏问题。代码示例：

```
.box {
  will-change: transform;
  transition: transform 0.3s ease;
}

```

2.  使用 `translate3d()` 或 `scale3d()` 替代 `top`、`left`、`right` 和 `bottom` 属性。

使用 `translate3d()` 或 `scale3d()` 替代 `top`、`left`、`right` 和 `bottom` 属性可以触发 GPU 加速，优化页面的渲染。代码示例：

```
.box {
  transform: translate3d(0, 0, 0);
  transition: transform 0.3s ease;
}

```

3.  避免在父元素和子元素同时使用 `transition` 属性。

在父元素和子元素同时使用 `transition` 属性可能会导致页面出现闪屏问题。我们可以避免这种情况，或者将 `transition` 属性应用到父元素或子元素中的一项。代码示例：

```
.parent {
  transition: height 0.3s ease;
}
.child {
  height: 100px;
}

```

通过上述方法，我们可以有效地解决 `transition` 属性闪屏问题。需要注意的是，在实际开发中，我们需要根据具体情况选择最合适的方法，并进行兼容性测试和调试，以确保实现的效果和性能符合预期要求。

Q:android 手机 圆角 bug

在 Android 手机中，出现圆角 bug 问题的主要原因是由于硬件加速导致的。

在硬件加速下，`border-radius` 属性可能无法正常显示圆角，导致页面显示异常。这种情况下，我们可以通过以下方法来解决：

1.  关闭硬件加速

可以通过设置元素的 `translateZ(0)` 样式来关闭硬件加速，从而解决圆角 bug 问题。代码示例：

```
.element {
  transform: translateZ(0);
  border-radius: 10px;
}

```

2.  使用 SVG 图片代替圆角样式

可以使用 SVG 图片来代替 `border-radius` 样式，以实现类似的效果。代码示例：

```
<svg width="100" height="100">
  <rect width="100" height="100" rx="10" fill="#000"/>
</svg>

```

通过上述方法，我们可以有效地解决 Android 手机中圆角 bug 问题。需要注意的是，不同的浏览器和机型可能存在差异，需要根据具体情况选择最合适的解决方案，并进行兼容性测试和调试，以确保实现的效果和性能符合预期要求。同时，还需要对页面进行测试和调试，以确保解决问题后页面的样式和布局仍然符合要求。

Q:前端工程化 - Babel 的原理是什么?

Babel 是一个 JavaScript 编译器，可以将 ES6/ES7 代码转换成兼容各种浏览器的 ES5 代码，以实现跨浏览器兼容性。

Babel 的原理主要是通过将 ES6/ES7 代码转换成一个抽象语法树（AST），然后使用插件对 AST 进行处理，最终将处理后的 AST 转换成 ES5 代码输出。

Babel 主要包含以下几个核心组件：

1.  Parser（解析器）：用于将源代码转换成 AST。
    
2.  Transformer（转换器）：用于对 AST 进行处理，例如对新语法进行转换，以实现向下兼容。
    
3.  Generator（生成器）：用于将处理后的 AST 转换成目标代码。
    

Babel 支持的新语法包括箭头函数、模板字符串、解构赋值、let 和 const 声明、类和模块等。Babel 还支持通过插件机制扩展转换器的功能，以满足不同的需求。

在实际应用中，Babel 可以与其他工具配合使用，例如 Webpack、Gulp、Grunt 等，以实现前端工程化和自动化构建。同时，为了提高 Babel 的转换速度和性能，我们可以通过优化配置和编写高效的代码来提高 Babel 的性能和稳定性。

Q:如何写一个 babel 插件?

编写 Babel 插件需要了解 AST（抽象语法树）的结构和 Babel 插件的处理流程。下面是编写 Babel 插件的一般步骤：

1.  安装 Babel 和相关工具

首先需要安装 Babel 和相关工具，例如 @babel/core、@babel/types、@babel/parser、@babel/traverse、@babel/generator 等。

```
npm install --save-dev @babel/core @babel/types @babel/parser @babel/traverse @babel/generator

```

2.  编写插件

Babel 插件需要导出一个函数，该函数接收一个 AST 节点并返回一个 AST 节点，用于对 AST 进行转换。

以下是一个简单的插件示例，用于将箭头函数转换成普通函数：

```
module.exports = function(babel) {
  const { types: t } = babel;
  return {
    name: "arrow-function-to-normal-function",
    visitor: {
      ArrowFunctionExpression(path) {
        const { params, body } = path.node;
        const func = t.functionExpression(null, params, body);
        path.replaceWith(func);
      }
    }
  };
}

```

该插件将会将箭头函数转换成普通函数。例如将以下代码：

```
const sum = (a, b) => a + b;

```

转换成：

```
const sum = function(a, b) {
  return a + b;
};

```

3.  测试插件

在编写完插件后，需要进行测试，以确保插件的功能和效果符合预期。

可以通过创建一个单独的测试文件，用于测试插件的转换效果和兼容性。例如：

```
const babel = require("@babel/core");
const plugin = require("../index");

const code = `const sum = (a, b) => a + b;`;
const result = babel.transform(code, {
  plugins: [plugin]
});

console.log(result.code); // 输出转换后的代码

```

在测试过程中，需要注意插件的兼容性和性能等方面的问题，以确保插件能够正常运行并满足实际需求。

通过上述步骤，我们可以编写一个基本的 Babel 插件，并对其进行测试和优化，以满足前端开发中的实际需求。需要注意的是，在编写和使用 Babel 插件时，需要根据具体情况选择合适的插件，并进行兼容性测试和调试，以确保实现的效果和性能符合预期要求。

Q:你的 git 工作流是怎样的?

我的 Git 工作流主要基于 Git Flow，包括以下几个主要分支：

1.  Master 分支：用于存放稳定版本的代码，不能直接修改。
    
2.  Develop 分支：用于存放开发中的代码，从 Master 分支分支出来，包含最新的功能和修复，所有开发人员的代码都合并到这个分支中。
    
3.  Feature 分支：用于开发新功能或修改缺陷，从 Develop 分支分支出来，开发完成后合并回 Develop 分支。
    
4.  Release 分支：用于发布稳定版本，从 Develop 分支分支出来，包含最新的功能和修复，进行一些小的修复和测试，通过测试后合并到 Master 分支和 Develop 分支。
    
5.  Hotfix 分支：用于修复紧急缺陷，从 Master 分支分支出来，修复完成后合并回 Master 分支和 Develop 分支。
    

除了以上主要分支外，我还会创建一些临时分支，例如用于解决某个问题或测试某个功能的分支，等工作完成后会删除这些分支。

在具体的开发中，我会遵循以下几个步骤：

1.  从 Develop 分支创建一个 Feature 分支，并在该分支上开发新功能或修改缺陷。
    
2.  在 Feature 分支上进行代码开发和测试，并定期提交代码到远程仓库。
    
3.  在 Feature 分支开发完成后，将代码提交到远程仓库，并创建一个 Pull Request 请求合并到 Develop 分支。
    
4.  在 Develop 分支上进行代码合并和测试，以确保新功能或修复的缺陷能够正常运行，并在必要时进行修改和调整。
    
5.  在 Develop 分支测试通过后，从 Develop 分支创建一个 Release 分支，进行版本发布和测试。
    
6.  在 Release 分支测试通过后，将代码合并到 Master 分支和 Develop 分支，并打上对应的版本号标签。
    
7.  在 Master 分支中进行代码管理和维护，确保代码的稳定性和安全性，同时定期从 Develop 分支拉取最新代码，以便后续的开发和发布。
    

通过上述 Git 工作流，我可以很好地管理和维护代码，确保代码的可靠性和稳定性，并促进团队的协作和开发效率。同时，还可以有效地进行版本管理和发布，以满足项目的需求和用户的期望。

Q:rebase 与 merge 的区别?

在 Git 中，Rebase 和 Merge 都是用于合并分支的操作，它们之间的主要区别在于合并的方式和结果。

1.  Rebase

Rebase 的基本思想是将一条分支上的修改变成另一条分支上的修改，通过将分支上的修改逐个应用到目标分支上来实现合并。Rebase 操作会将当前分支的提交记录复制到目标分支的末端，并将目标分支的提交记录重新应用到这些复制的提交记录之上，从而实现分支合并。

Rebase 的主要优点是可以保持提交历史的线性，从而使 Git 的提交历史更加清晰和易于管理。但是，Rebase 操作会改变提交的 SHA-1 值，因此在多人协作和公共仓库中使用时需要谨慎，避免造成不必要的冲突和错误。

2.  Merge

Merge 是将两条分支上的修改合并成一条新的提交记录，将两个分支的修改都应用到目标分支上来实现合并。Merge 操作会创建一个新的提交记录，并包含两个分支上的修改内容，以实现分支合并。

Merge 的主要优点是比较直观和简单，适用于一些简单的分支合并操作。但是，Merge 操作会产生合并提交记录，并且提交历史可能比较复杂和难以管理，因此在多人协作和公共仓库中使用时需要注意冲突和错误。

总体来说，Rebase 和 Merge 都是用于合并分支的操作，它们的区别在于合并的方式和结果。Rebase 操作可以保持提交历史的线性，并且适用于复杂的分支合并操作；而 Merge 操作比较直观和简单，并且适用于简单的分支合并操作。因此，在使用 Git 进行分支管理和合并时，可以根据具体情况选择合适的操作方式和策略，以实现高效和可靠的分支管理。

Q:git reset、git revert 和 git checkout 有什么区别

在 Git 中，reset、revert 和 checkout 都是用于撤销提交和修改代码的操作，但它们的作用和方式不同：

1.  Git reset

Git reset 可以将 HEAD 指针和当前分支的提交历史重置到指定的提交记录，并且可以选择是否保留修改的代码。reset 操作会将指定的提交记录和之后的提交记录都删除，因此需要谨慎使用。

2.  Git revert

Git revert 可以创建一个新的提交记录，撤销之前的提交记录，并且保留修改的代码。revert 操作不会删除任何提交记录，而是创建一个新的提交记录，该记录包含之前提交记录的撤销修改。

3.  Git checkout

Git checkout 可以用于切换分支，撤销修改的代码，或者检查历史提交记录的代码。checkout 操作可以从当前分支的提交记录、其他分支的提交记录、或者历史提交记录中恢复代码，而且不会改变分支的提交历史。

因此，Git reset 用于重置分支的提交历史，可以删除提交记录，但也可能丢失修改的代码；Git revert 用于创建一个新的提交记录，撤销之前的提交记录，但会保留修改的代码；Git checkout 用于检查历史提交记录的代码，或者恢复修改的代码，但不会改变分支的提交历史。

在实际开发中，我们可以根据具体的需求和情况，选择合适的 Git 命令和操作，以实现高效和可靠的代码管理和版本控制。同时，也需要注意命令的使用方式和注意事项，避免因为错误操作而导致代码丢失或版本混乱的情况。

Q:webpack 和 gulp 区别（模块化与流的区别）

Webpack 和 Gulp 都是前端构建工具，但它们的设计目的和实现方式有所不同，主要体现在以下两个方面：

1.  模块化

Webpack 的设计目的是解决前端模块化的问题，它支持将所有前端资源（JavaScript、CSS、图片等）视为模块，并且提供了一种统一的打包和加载方式，从而实现模块化开发和构建。Webpack 支持多种模块格式，如 CommonJS、AMD、ES6 模块等，并且提供了一些插件和工具，如 Tree Shaking、Code Splitting 等，以优化打包和加载的性能。

Gulp 的设计目的是提供一种基于流的任务自动化方案，它通过插件来完成各种任务，如编译、压缩、合并等，可以将多个任务组合成一个管道，从而实现高效的任务处理。Gulp 的流式处理机制使得它能够快速处理大量的文件，并且支持多种操作系统和环境。

2.  流式处理

Webpack 和 Gulp 在处理资源时的方式也有所不同，主要体现在以下两个方面：

Webpack 的处理方式是通过插件和 loader 来处理资源，插件和 loader 之间通过一定的规则和流程串联起来，形成一个管道，最终将所有的资源打包成一个或多个文件。Webpack 的资源处理过程是单向的，无法中途插入其他的操作或修改，因此它的处理方式更加确定和稳定。

Gulp 的处理方式是通过流的方式处理资源，将所有的操作封装成流对象，并将流对象串联起来，形成一个管道，从而实现资源的处理。Gulp 的资源处理过程是双向的，可以在流的中途插入其他的操作或修改，从而使得处理过程更加灵活和可定制。

综上所述，Webpack 和 Gulp 都是前端构建工具，但它们的设计目的和实现方式有所不同，主要体现在模块化和流式处理方面。Webpack 更加适合复杂的模块化开发和构建，而 Gulp 更加适合基于流的任务自动化和定制化处理。在实际的开发中，我们可以根据具体的需求和场景选择合适的工具和方案，以实现高效和可靠的前端构建和开发。

Q:有使用过 Vue 吗？说说你对 Vue 的理解

Vue.js 是一款流行的轻量级前端框架，它采用 MVVM 模式，通过双向数据绑定和组件化的方式，实现了高效的前端开发和组织方式。以下是我的对 Vue.js 的理解：

1.  组件化开发

Vue.js 的核心思想是组件化开发，通过将页面拆分为多个独立的组件，每个组件都有自己的模板、样式和行为，可以独立进行开发、测试和维护。Vue.js 的组件系统支持模板、指令、计算属性、事件监听等功能，可以快速构建复杂的页面和应用。

2.  数据驱动

Vue.js 实现了双向数据绑定，可以将数据和视图进行关联，当数据发生变化时，视图也会自动更新。Vue.js 支持计算属性、监听器等功能，可以实现复杂的数据处理和交互逻辑。同时，Vue.js 的响应式系统也是其核心特性之一，它可以通过对数据进行劫持，实现对数据的监听和更新。

3.  轻量级和易用性

Vue.js 作为一个轻量级框架，体积小、性能高，同时也非常易用，可以通过 CDN 引入，也可以通过 Vue CLI 快速创建和初始化项目。Vue.js 的语法简单、清晰，支持 TypeScript 和 JSX 等功能，同时也提供了完善的文档和示例，便于学习和使用。

4.  生态系统

Vue.js 生态系统非常丰富，包括 Vue Router、Vuex、Vue CLI、Element UI 等插件和库，可以快速构建高效的前端应用。Vue.js 还有大量的社区和插件支持，可以满足不同开发需求和场景的使用。

综上所述，Vue.js 是一款轻量级、易用性强、性能高、组件化的前端框架，支持数据驱动和响应式的开发方式，拥有丰富的生态系统和社区支持，适合构建各种类型的前端应用和组件。

Q:说说 Vue 的优缺点

Vue.js 作为一款轻量级的前端框架，具有以下优点：

1.  简单易用

Vue.js 的语法简单明了，易于学习和使用，适合入门级和中级开发者。同时，Vue.js 也提供了完善的文档和示例，便于开发者快速上手。

2.  数据驱动和组件化

Vue.js 采用数据驱动和组件化的开发方式，使得开发者可以更加关注业务逻辑和组件的功能实现，而不必过多关注视图和模板的实现细节。同时，Vue.js 的响应式系统和双向数据绑定功能也使得开发者可以快速构建交互性强、体验优良的应用程序。

3.  灵活可扩展

Vue.js 的设计理念非常灵活，它提供了许多功能强大的特性，如指令、计算属性、过渡动画等，并且也提供了完善的插件和扩展机制，可以方便地扩展和定制。

4.  生态系统和社区支持

Vue.js 拥有强大的生态系统和社区支持，包括 Vue Router、Vuex、Vue CLI、Element UI 等插件和库，可以快速构建高效的前端应用。同时，Vue.js 的社区非常活跃，有大量的插件和扩展，可以满足不同的开发需求和场景。

除此之外，Vue.js 还有以下缺点：

1.  性能问题

在处理大规模数据和复杂应用时，Vue.js 的性能会受到影响，特别是在虚拟 DOM 的处理上，可能存在性能问题。

2.  学习曲线

虽然 Vue.js 的语法简单，但是对于完全不熟悉前端框架的开发者来说，学习 Vue.js 还是需要一定的时间和精力。

3.  生态系统不够完善

相对于 React 和 Angular 这两个更加成熟的前端框架，Vue.js 的生态系统还不够完善，存在一些缺失和不足。

综上所述，Vue.js 是一款简单易用、灵活可扩展、生态系统和社区支持强大的前端框架，但是在处理大规模数据和复杂应用时可能存在性能问题，学习曲线相对较高，生态系统还不够完善等缺点。开发者在选择前端框架时，需要根据具体的需求和场景进行选择和评估。

Q:说说 Vue 的优缺点

Vue.js 是一款流行的前端框架，具有以下优点：

1.  简单易学

Vue.js 的语法简单易懂，学习曲线较低，入门门槛相对较低。它使用了基于 HTML 的模板语法，使得开发者可以快速上手。

2.  组件化开发

Vue.js 采用组件化开发方式，使得开发者可以将应用程序拆分成多个独立的组件，每个组件都有自己的视图、状态和行为。这种开发方式可以提高应用程序的可维护性和可复用性。

3.  响应式数据绑定

Vue.js 提供了响应式数据绑定的机制，使得开发者可以很方便地更新数据并自动更新视图。这种机制大大简化了开发的复杂度，提高了开发效率。

4.  社区活跃度高

Vue.js 的社区活跃度非常高，拥有大量的开源组件和插件，可以快速解决常见的开发问题，提高开发效率。

然而，Vue.js 也存在一些缺点：

1.  处理大型应用程序可能会受到性能影响

Vue.js 使用了虚拟 DOM 技术，它可以显著提高应用程序的性能。但是，当应用程序越来越大时，它的性能可能会受到一定的影响。

2.  与其他框架比较，生态系统相对较小

Vue.js 虽然在近年来得到了广泛的应用，但是相比于其他一些框架，如 React 和 Angular，它的生态系统还比较小。

综上所述，Vue.js 是一款功能强大、易于学习、社区活跃度高的前端框架。然而，对于一些大型应用程序来说，可能需要考虑一些性能问题。此外，相比于其他一些框架，Vue.js 的生态系统还相对较小。开发者应该根据项目需求和情况进行选择。

Q:Vue 和 React 有什么不同？使用场景分别是什么？

Vue 和 React 是目前最受欢迎的前端框架之一，它们有以下不同点：

1.  模板语法不同

Vue 使用基于 HTML 的模板语法，React 使用 JSX 语法。Vue 的模板语法更加直观，易于学习和使用；而 React 的 JSX 语法则更加灵活，可以在 JavaScript 中使用 XML 标签。

2.  数据绑定方式不同

Vue 的数据绑定是双向的，即当数据发生变化时，视图会自动更新；当视图发生变化时，数据也会自动更新。而 React 的数据绑定是单向的，需要手动处理数据的更新。

3.  组件化方式不同

Vue 和 React 的组件化方式都非常强大，但是它们的实现方式略有不同。Vue 的组件化方式更加直观和简单，而 React 的组件化方式则更加灵活和功能强大。

4.  生命周期不同

Vue 和 React 的生命周期不同，Vue 的生命周期钩子函数更加直观和易于理解，而 React 的生命周期钩子函数则更加灵活和自由。

基于以上的不同点，Vue 和 React 的使用场景也略有不同：

1.  Vue 更适合快速开发小型项目和中型项目，它的模板语法和双向数据绑定使得开发者可以快速开发出高质量的应用程序。
    
2.  React 更适合大型项目和高度定制化的应用程序，它的组件化方式和灵活的数据绑定方式使得开发者可以更好地控制应用程序的状态和行为。
    

总的来说，Vue 和 React 都是非常优秀的前端框架，具有各自的优点和适用场景。开发者可以根据项目需求和情况进行选择。

Q:什么是虚拟 DOM？

虚拟 DOM 是指一个虚拟的内存中的 DOM 对象，它是真实 DOM 的抽象表示。虚拟 DOM 是在内存中进行操作，然后通过比较虚拟 DOM 和真实 DOM 的差异，最终只更新需要更新的部分，从而提高应用程序的性能。

虚拟 DOM 由三个部分组成：

1.  DOM 元素的描述信息

虚拟 DOM 中包含了所有 DOM 元素的描述信息，包括元素的标签名、属性、样式等。

2.  子元素的描述信息

虚拟 DOM 中也包含了所有子元素的描述信息，包括子元素的标签名、属性、样式等。

3.  对应真实 DOM 元素的引用

虚拟 DOM 中还包含了对应真实 DOM 元素的引用，以便在需要更新时可以快速地找到对应的 DOM 元素。

虚拟 DOM 的优点在于它可以避免直接操作真实 DOM，而是通过对比虚拟 DOM 和真实 DOM 的差异，只更新需要更新的部分，从而减少 DOM 操作的次数，提高应用程序的性能。此外，虚拟 DOM 还可以跨平台使用，因为它是纯 JavaScript 对象，可以在任何支持 JavaScript 的环境中使用。

虚拟 DOM 的缺点在于它需要额外的计算量来比较虚拟 DOM 和真实 DOM 的差异，并且在初次渲染时需要构建虚拟 DOM，可能会导致一些额外的性能开销。但是，虚拟 DOM 在大多数情况下可以带来更好的性能和开发效率。

Q:请描述下 vue 的生命周期是什么？

Vue 的生命周期是组件从创建到销毁的整个过程，包含了多个钩子函数，开发者可以在这些钩子函数中执行一些操作，以便在组件不同的生命周期阶段进行不同的处理。Vue 的生命周期可以分为以下四个阶段：

1.  创建阶段（Creation）

*   beforeCreate: 在实例被创建之前执行，此时组件的 data、methods、computed 和 watch 都不可用。
*   created: 在实例被创建之后执行，此时组件的 data、methods、computed 和 watch 都已经初始化完成，可以进行数据的获取和初始化操作。

2.  挂载阶段（Mounting）

*   beforeMount: 在组件挂载到 DOM 之前执行，此时组件的 template 被编译成 render 函数，并且还没有进行渲染。
*   mounted: 在组件挂载到 DOM 之后执行，此时组件已经完成了首次渲染，可以进行 DOM 操作和数据请求等操作。

3.  更新阶段（Updating）

*   beforeUpdate: 在组件更新之前执行，此时数据发生了变化，但是页面还没有被重新渲染。
*   updated: 在组件更新之后执行，此时组件已经完成了重新渲染，可以进行 DOM 操作和数据请求等操作。

4.  销毁阶段（Destruction）

*   beforeDestroy: 在组件销毁之前执行，此时组件还可以被使用，可以进行一些清理工作和资源的释放。
*   destroyed: 在组件销毁之后执行，此时组件已经不能被使用，所有的 DOM 元素和事件监听器都已经被移除，可以进行一些最终的清理工作和资源的释放。

开发者可以在不同的生命周期钩子函数中执行不同的操作，以便在组件不同的生命周期阶段进行不同的处理，比如在 created 钩子函数中进行数据的初始化，在 mounted 钩子函数中进行 DOM 操作和数据请求等操作，在 destroyed 钩子函数中进行资源的释放和清理工作等。

Q:vue 如何监听键盘事件？

在 Vue 中监听键盘事件可以使用 v-on 指令绑定键盘事件的名称，例如：

```
<template>
  <div v-on:keydown="onKeyDown"></div>
</template>

`<script>`
export default {
  methods: {
    onKeyDown(event) {
      console.log(event.key);
    },
  },
};
</script>

```

在上面的代码中，我们在 div 元素上绑定了一个 keydown 事件，并且使用 v-on 指令绑定了一个方法 onKeyDown 来处理这个事件。在方法中，我们可以通过 event.key 来获取当前按下的键位名称。

除了 keydown 事件以外，还有 keyup 和 keypress 事件可以用来监听键盘事件，它们的用法与 keydown 类似。

另外，Vue 还提供了一个语法糖，在绑定键盘事件时可以直接使用简写方式：

```
<template>
  <div @keydown="onKeyDown"></div>
</template>

```

在上面的代码中，@keydown 等同于 v-on:keydown，这是一种常用的语法糖，可以使代码更加简洁易读。

Q:watch 怎么深度监听对象变化

在 Vue 中，可以通过设置 `watch` 的 `handler` 函数的 `deep` 属性为 `true` 来深度监听对象的变化，从而在对象的属性值发生改变时触发 `watch` 函数。

例如：

```
<template>
  <div></div>
</template>

`<script>`
export default {
  data() {
    return {
      obj: {
        name: 'Tom',
        age: 18,
        score: {
          math: 90,
          english: 80,
        },
      },
    };
  },
  watch: {
    obj: {
      deep: true,
      handler(newVal, oldVal) {
        console.log('obj changed', newVal, oldVal);
      },
    },
  },
};
</script>

```

在上面的代码中，我们定义了一个名为 `obj` 的对象，其中包含了一个嵌套的对象 `score`。在 `watch` 中，我们通过设置 `obj` 的 `deep` 属性为 `true` 来深度监听 `obj` 对象的变化。当 `obj` 对象的任意属性值发生改变时，都会触发 `watch` 函数，并且会传递两个参数 `newVal` 和 `oldVal`，分别表示新值和旧值。

需要注意的是，深度监听对象变化可能会对性能产生一定的影响，因为它需要递归遍历对象的所有属性。在实际开发中，建议根据实际情况来决定是否使用深度监听。如果只需要监听对象的某个特定属性，可以使用计算属性或者 watch 表达式来实现。

Q:删除数组用 delete 和 Vue.delete 有什么区别？

在 JavaScript 中，可以使用 `delete` 关键字删除对象的属性或者数组中的元素。例如：

```
// 删除对象的属性
let obj = { name: 'Tom', age: 18 };
delete obj.name;

// 删除数组中的元素
let arr = [1, 2, 3, 4, 5];
delete arr[2];

```

在上面的代码中，我们使用 `delete` 关键字分别删除了对象 `obj` 的属性 `name` 和数组 `arr` 中索引为 2 的元素。

但是，在 Vue 中，如果直接使用 `delete` 关键字删除数组中的元素，可能会导致数组的响应式机制失效，从而无法触发视图的更新。这是因为，Vue 对数组的响应式处理机制和 JavaScript 原生的数组处理机制有所不同。

为了解决这个问题，Vue 提供了一个 `Vue.delete` 方法来删除数组中的元素，并且保持数组的响应式特性。例如：

```
let arr = [1, 2, 3, 4, 5];
Vue.delete(arr, 2);

```

在上面的代码中，我们使用 `Vue.delete` 方法删除了数组 `arr` 中索引为 2 的元素。这样做不仅可以保持数组的响应式特性，还能触发视图的更新。

需要注意的是，`Vue.delete` 只能用来删除数组中的元素，而不能用来删除对象的属性。如果需要删除对象的属性，可以使用 JavaScript 原生的 `delete` 关键字。同时，在使用 `Vue.delete` 删除数组元素时，需要确保数组是响应式的，否则可能会出现无法触发视图更新的情况。如果数组不是响应式的，可以将其转换为响应式的数组，或者直接替换为一个新的数组。

Q:watch 和计算属性有什么区别？

在 Vue 中，`watch` 和计算属性都可以用来监听数据的变化并做出相应的处理。它们之间的主要区别在于：

1.  `watch` 监听的是某个数据的变化，只要该数据发生变化就会触发 `watch` 函数执行；而计算属性是基于某个数据计算出来的值，只有该数据发生变化时才会重新计算该属性的值。
    
2.  `watch` 可以监听多个数据的变化，每个数据变化时都会触发 `watch` 函数执行；而计算属性只能依赖于一个数据，不支持监听多个数据的变化。
    
3.  计算属性具有缓存机制，只有当计算属性依赖的数据发生变化时才会重新计算该属性的值，并且下次获取该属性的值时会直接返回缓存的结果；而 `watch` 每次都会触发函数执行，没有缓存机制。
    

因此，当需要根据某个数据计算出一个值时，可以使用计算属性；当需要监听多个数据的变化时，可以使用 `watch`。需要注意的是，在实际开发中，应该根据具体的场景来选择使用计算属性或者 `watch`，以便提高应用程序的性能。如果数据变化频繁，或者计算量比较大，建议使用 `watch`；如果数据变化不频繁，且计算量比较小，可以使用计算属性。

Q:Vue 双向绑定原理

Vue 的双向数据绑定是通过 Vue 的数据绑定系统实现的，其原理可以分为以下几个步骤：

1.  首先，Vue 会在初始化组件时，根据模板中的指令和表达式，将组件中的数据进行解析，生成一个对应的渲染函数。
    
2.  在渲染函数中，Vue 会将组件中的数据和模板中的元素进行关联，从而实现数据的绑定。对于表单元素，Vue 会监听其 `input` 或者 `change` 事件，并将用户输入的数据更新到对应的组件数据中。
    
3.  对于双向数据绑定，Vue 会在渲染函数中，为表单元素绑定一个 `value` 属性，并将其值设置为组件数据中对应的值。当用户输入数据时，Vue 会通过监听 `input` 或者 `change` 事件，将用户输入的数据更新到组件数据中。同时，Vue 也会监听组件数据的变化，当组件数据发生变化时，会将其更新到表单元素的 `value` 属性中，从而实现双向数据绑定。
    
4.  在数据更新时，Vue 会自动检测依赖该数据的所有组件，并重新渲染这些组件，从而更新视图。
    

需要注意的是，Vue 的双向数据绑定是基于对象属性的变化检测实现的。Vue 会将组件数据转换为响应式对象，并通过 `Object.defineProperty` 方法来拦截对组件数据的访问和赋值操作。当访问或者赋值组件数据时，Vue 会自动触发响应式更新，从而更新视图。这种方式能够有效地避免频繁地重新渲染整个组件，提高了应用程序的性能。

Q:v-model 是什么？有什么用呢？

`v-model` 是 Vue 中的一个指令，用于实现表单元素和组件数据的双向数据绑定。通过 `v-model`，我们可以将表单元素的值绑定到组件数据中，并且在用户输入数据时，自动将用户输入的数据更新到组件数据中，从而实现双向数据绑定。

`v-model` 指令主要用于表单元素的双向数据绑定，例如文本框、下拉列表、单选框和复选框等。在使用 `v-model` 指令时，我们需要将其绑定到组件数据的一个属性上，例如：

```
<template>
  <div>
    <input type="text" v-model="message">
    <p>{{ message }}</p>
  </div>
</template>

`<script>`
  export default {
    data() {
      return {
        message: 'Hello Vue!'
      }
    }
  }
</script>

```

在上面的代码中，我们将 `v-model` 指令绑定到了文本框元素上，并将其值绑定到了组件数据中的 `message` 属性上。当用户输入数据时，Vue 会自动将输入的数据更新到 `message` 属性中，并且在模板中使用了 `message` 属性的地方也会自动更新，从而实现双向数据绑定。

需要注意的是，在使用 `v-model` 指令时，要确保表单元素的值和组件数据的值类型一致。例如，如果绑定的是复选框或者单选框，应该将组件数据绑定到其 `checked` 属性上，而不是 `value` 属性上。同时，在使用 `v-model` 指令时，也可以通过自定义组件来实现双向数据绑定，从而扩展 `v-model` 的使用场景。

Q:axios 是什么？怎样使用它？怎么解决跨域的问题？

Axios 是一个基于 Promise 的 HTTP 客户端，可以在浏览器和 Node.js 中使用。它是现代 Web 开发中常用的一个工具，能够方便地向服务器发送 HTTP 请求，并处理响应数据。Axios 支持 Promise API，能够更好地处理异步代码，而且具有易用性、可靠性和灵活性。

Axios 的使用非常简单，我们只需要在项目中安装 Axios，然后在代码中引入并使用即可。下面是一个示例：

```
import axios from 'axios';

axios.get('/api/user?id=123')
  .then(function (response) {
    console.log(response.data);
  })
  .catch(function (error) {
    console.log(error);
  });

```

上面的代码中，我们使用 Axios 发送了一个 GET 请求，并将响应数据输出到控制台中。Axios 还支持其他的 HTTP 请求方式，例如 POST、PUT、DELETE 等。

解决跨域问题可以通过 Axios 的 `withCredentials` 属性来实现。在发送请求时，我们只需要将该属性设置为 `true`，就可以携带跨域请求的 cookie 信息了。例如：

```
axios.get('/api/user?id=123', {
  withCredentials: true
})
.then(function (response) {
  console.log(response.data);
})
.catch(function (error) {
  console.log(error);
});

```

需要注意的是，跨域请求还需要服务器端进行相应的配置，以允许跨域请求。常用的解决跨域问题的方法有：JSONP、CORS、代理等。具体的实现方式需要根据实际情况进行选择和配置。

Q:在 vue 项目中如何引入第三方库（比如 jQuery）？有哪些方法可以做 到？

在 Vue 项目中引入第三方库的方法主要有以下几种：

1.  直接在 `index.html` 中引入

在 `index.html` 文件中可以直接使用 `script` 标签引入第三方库，例如 jQuery：

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Vue App</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="./app.js"></script>
  </body>
</html>

```

2.  使用 `import` 引入

在 Vue 项目中可以使用 `import` 语句引入第三方库，例如：

```
import $ from 'jquery';

export default {
  mounted() {
    $('body').css('background-color', 'red');
  }
}

```

需要注意的是，使用 `import` 引入的第三方库需要先安装到项目中，可以使用 npm 或者 yarn 安装。

3.  使用插件的方式引入

在 Vue 项目中，还可以通过插件的方式引入第三方库。插件是一种 Vue.js 的扩展机制，可以扩展 Vue.js 的功能。例如，我们可以使用 `vue-jquery` 插件来引入 jQuery：

```
import Vue from 'vue';
import jQuery from 'jquery';
import VueJQuery from 'vue-jquery';

Vue.use(VueJQuery, jQuery);

export default {
  mounted() {
    this.$jQuery('body').css('background-color', 'red');
  }
}

```

需要注意的是，使用插件引入第三方库的方式，可能需要对插件进行一些配置，具体的配置方法需要参考插件的文档说明。

Q:说说 Vue React angularjs jquery 的区别

Vue、React、AngularJS 和 jQuery 都是前端开发中常用的框架或库，它们有着各自的特点和使用场景。

1.  Vue

Vue 是一款轻量级、渐进式的 JavaScript 框架，它的特点是易用性和灵活性。Vue 通过数据绑定和组件化的方式实现了高效的开发体验，并且提供了丰富的 API 和生态系统。Vue 的优点是简单易用，学习成本低，支持服务端渲染和组件化开发。Vue 适合用于快速开发中小型应用，以及移动端开发。

2.  React

React 是 Facebook 推出的一款 JavaScript 库，它采用了虚拟 DOM 技术，通过组件化的方式实现了高效的开发体验。React 的特点是可复用性和高性能，支持服务端渲染和组件化开发。React 的优点是灵活性和高性能，缺点是学习成本较高。React 适合用于大型应用中。

3.  AngularJS

AngularJS 是 Google 推出的一款 JavaScript 框架，它采用了双向数据绑定和依赖注入的方式实现了高效的开发体验。AngularJS 的特点是功能强大和可扩展性，提供了丰富的 API 和组件，适合用于大型应用中。AngularJS 的缺点是学习曲线较陡峭，使用起来较为复杂。

4.  jQuery

jQuery 是一款流行的 JavaScript 库，它简化了 DOM 操作、事件处理和动画效果的开发，使开发者可以更加快速地开发出交互性强的页面。jQuery 的优点是易用性和兼容性，缺点是性能较低。jQuery 适合用于简单的页面开发。

总的来说，Vue 和 React 都是现代 Web 开发中常用的框架，具有灵活性和高效性；AngularJS 功能强大，适用于大型应用；而 jQuery 则逐渐被现代框架所取代，适合用于简单的页面开发。选择框架或库应该根据项目的需求和实际情况进行选择。

Q:Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？

Vue 3.0 中使用 Proxy 替代 defineProperty 的主要原因是为了提高性能和开发效率。

在 Vue 2.x 中，Vue 通过 defineProperty 来实现对数据的响应式监听，但是 defineProperty 有一些缺点：

1.  不支持数组的监听。由于 defineProperty 无法监听数组的变化，Vue 在实现数组响应式时需要进行特殊处理，增加了开发的复杂度。
    
2.  需要递归遍历对象。由于 defineProperty 只能对已经存在的属性进行监听，所以 Vue 在实现响应式时需要递归遍历对象，对每个属性都进行 defineProperty 的处理，导致性能较低。
    
3.  对新属性需要手动进行监听。由于 defineProperty 无法监听对象新添加的属性，所以在使用 Vue 时需要手动调用 $set 方法来进行监听。
    

Proxy 是 ES6 中新增的一个 API，可以实现对对象和数组的监听，并且可以监听对象新增的属性。与 defineProperty 相比，Proxy 的优点主要有以下几点：

1.  支持数组的监听。通过 Proxy，可以直接监听数组的变化，无需对数组进行特殊处理。
    
2.  可以避免递归遍历对象。Proxy 可以监听整个对象，不需要对每个属性进行监听，因此避免了递归遍历对象的过程，提高了性能。
    
3.  可以监听对象新增的属性。通过 Proxy，可以直接监听对象新增的属性，无需手动调用 $set 方法。
    

综上所述，Vue 3.0 中使用 Proxy 替代 defineProperty 的主要目的是为了提高性能和开发效率，同时避免了在 Vue 2.x 中 defineProperty 的一些缺陷。

Q:Vue3.0 编译做了哪些优化？

Vue 3.0 在编译方面进行了很多优化，主要包括以下几个方面：

1.  静态根节点提升

Vue 3.0 在编译阶段通过静态分析，将静态根节点提取出来，避免了每次更新时对静态节点的重复渲染。这种优化方式称为“静态根节点提升”。

2.  缓存事件处理器

Vue 3.0 在编译阶段将事件处理器进行缓存，避免了每次重新创建事件处理器的开销。

3.  内置组件和指令

Vue 3.0 中内置了很多常用的组件和指令，如 Teleport、Suspense 等，这些组件和指令可以减少开发者的工作量，同时也可以提高性能。

4.  Hoist 静态节点

Vue 3.0 在编译阶段通过静态分析，将静态节点提升到父节点的作用域中，避免了对子节点重复渲染的开销。

5.  Patch Flag

Vue 3.0 引入了 Patch Flag 的概念，通过标记需要更新的节点类型和属性，避免了对没有变化的节点进行重复渲染的开销。

6.  缓存属性

Vue 3.0 在编译阶段将需要频繁访问的属性进行缓存，避免了多次访问同一个属性的开销。

综上所述，Vue 3.0 在编译方面进行了很多优化，主要目的是提高性能和开发效率。这些优化方式的具体实现可以让 Vue 应用在性能方面得到很大的提升，使得 Vue 应用可以更加高效地运行。

Q:Vue3.0 新特性 —— Composition API 与 React.js 中 Hooks 的异同点

Vue 3.0 中的 Composition API 是一种新的 API 风格，它与 Vue 2.x 中的 Options API 不同，它允许我们更好地组织逻辑，提高代码的可复用性和可维护性。

Composition API 的主要特点是将相关的逻辑组织在一起，使得代码更易于组合和重用。通过 Composition API，我们可以将一个组件中的逻辑分割成多个功能独立的部分，然后将这些部分组合在一起。这样做可以提高代码的可读性和可维护性，同时也可以让我们更方便地进行测试和重构。

与 Vue 2.x 中的 Options API 相比，Composition API 有以下几个优点：

1.  更好的组织逻辑

Composition API 可以将相关的逻辑组织在一起，使得代码更易于组合和重用。

2.  更容易测试和重构

通过将逻辑分割成多个部分，我们可以更容易地对每个部分进行单元测试，同时也可以更方便地进行重构。

3.  更好的类型推断

Composition API 可以提供更好的类型推断，让我们更容易地编写类型安全的代码。

React 中的 Hooks 也有类似的功能，它可以让我们将逻辑分解成更小的可复用部分，并将它们组合在一起。与 Vue 3.0 的 Composition API 相比，React Hooks 更加灵活，可以使用自定义 Hooks 来实现复杂的逻辑组合。此外，Hooks 也可以通过 useContext 和 useReducer 等 API 实现状态管理和共享。

两者的主要区别在于语法和实现方式。Vue 3.0 中的 Composition API 是一种新的 API 风格，通过 createXXX 和 useXXX 等函数来定义和使用组合逻辑；而 React Hooks 则是一种更底层的 API，可以直接在函数组件中使用。另外，Vue 3.0 的 Composition API 还提供了一些便捷的函数和对象，如 ref、reactive 等，可以方便地管理组件状态。

Q:Vue Composition API 基本使用

Vue 3.0 中的 Composition API 是一种新的 API 风格，它允许我们更好地组织逻辑，提高代码的可复用性和可维护性。下面是 Vue Composition API 的基本使用方法：

1.  安装 Vue 3.0

Composition API 只在 Vue 3.0 中提供。因此，在使用 Composition API 之前，需要先安装 Vue 3.0。

2.  创建组合式函数

使用 createXXX 函数来创建组合式函数，其中 XXX 可以是 ref、computed、watch 等。例如，可以使用 createRef 函数来创建一个 ref：

```
import { createRef } from 'vue';

export default {
  setup() {
    const inputValue = createRef('');

    // ...
  }
};

```

3.  创建响应式状态

使用 reactive 或 ref 函数来创建响应式状态。例如，可以使用 reactive 函数来创建一个包含多个属性的响应式对象：

```
import { reactive } from 'vue';

export default {
  setup() {
    const state = reactive({
      count: 0,
      message: 'Hello, Vue!'
    });

    // ...
  }
};

```

4.  创建计算属性

使用 computed 函数来创建计算属性。例如，可以使用 computed 函数来计算 count 的平方值：

```
import { reactive, computed } from 'vue';

export default {
  setup() {
    const state = reactive({
      count: 0,
      message: 'Hello, Vue!'
    });

    const squaredCount = computed(() => state.count * state.count);

    // ...
  }
};

```

5.  监听变化

使用 watch 函数来监听变化。例如，可以使用 watch 函数来监听 count 的变化：

```
import { reactive, watch } from 'vue';

export default {
  setup() {
    const state = reactive({
      count: 0,
      message: 'Hello, Vue!'
    });

    watch(() => state.count, (newValue, oldValue) => {
      console.log(`count changed from ${oldValue} to ${newValue}`);
    });

    // ...
  }
};

```

6.  返回值

setup 函数需要返回一个对象，该对象包含组件中需要使用的数据和方法。例如：

```
import { reactive } from 'vue';

export default {
  setup() {
    const state = reactive({
      count: 0,
      message: 'Hello, Vue!'
    });

    const increment = () => {
      state.count++;
    };

    return {
      state,
      increment
    };
  }
};

```

以上是 Vue Composition API 的基本使用方法，通过这些方法可以更好地组织逻辑，提高代码的可复用性和可维护性。

Q:Vue3.0 是如何变得更快的？（底层，源码）

Vue 3.0 通过多种方式来提升性能，包括底层的优化和源码的优化。

底层优化：

1.  Virtual DOM 的优化：Vue 3.0 使用了更高效的 Virtual DOM 算法，减少了 DOM 更新的时间。
    
2.  响应式系统的优化：Vue 3.0 使用了 Proxy 对象代替了 Object.defineProperty 实现响应式系统，提高了响应式系统的性能。
    
3.  编译器的优化：Vue 3.0 使用了更快的编译器，编译速度比 Vue 2.x 更快。
    

源码优化：

1.  Tree-shaking：Vue 3.0 的代码使用了 ES Module 的形式，可以通过 Tree-shaking 来剔除不必要的代码，从而减小打包体积。
    
2.  Composition API：Vue 3.0 的 Composition API 具有更好的组织逻辑的能力，可以提高代码的可复用性和可维护性。
    
3.  指令优化：Vue 3.0 对指令的内部实现进行了优化，减少了指令的计算时间。
    

总的来说，Vue 3.0 的底层优化和源码优化都提高了框架的性能，使得 Vue 3.0 比 Vue 2.x 更快。同时，Vue 3.0 也增加了一些新的功能，如 Composition API，使得开发更加便捷。

Q:从 hoistStatic 静态提升 方面讲讲？

在 Vue 3.0 中，通过 hoistStatic 静态提升来优化渲染性能。hoistStatic 静态提升是指将静态节点和静态文本片段提升到父节点的作用域中，避免在每次渲染时都进行重复计算。

在 Vue 3.0 中，通过编译器将静态节点和静态文本片段进行标记，然后在渲染时将它们提升到父节点的作用域中。由于静态节点和静态文本片段只需要计算一次，因此可以避免在每次渲染时都进行重复计算，从而提高渲染性能。

具体来说，hoistStatic 静态提升主要有以下几个优化点：

1.  提升静态节点：将静态节点提升到父节点的作用域中，避免在每次渲染时都进行重复计算。
    
2.  提升静态文本片段：将静态文本片段提升到父节点的作用域中，避免在每次渲染时都进行重复计算。
    
3.  消除冗余计算：对于一些静态节点和静态文本片段，在父节点中进行一次计算，然后在子节点中直接使用，避免进行重复计算。
    

总的来说，hoistStatic 静态提升能够避免在每次渲染时都进行重复计算，从而提高渲染性能。在 Vue 3.0 中，编译器会自动进行 hoistStatic 静态提升的优化，无需手动干预。

Q:从 cacheHandlers 事件侦听器缓存 方面讲讲？

在 Vue 3.0 中，通过 cacheHandlers 事件侦听器缓存来优化渲染性能。cacheHandlers 事件侦听器缓存是指缓存常见的事件侦听器，避免在每次渲染时都重新创建。

在 Vue 2.x 中，每次渲染时都会重新创建事件侦听器。由于事件侦听器通常不会改变，因此可以通过缓存事件侦听器来避免在每次渲染时都重新创建。

在 Vue 3.0 中，可以通过将 cacheHandlers 设置为 true 来启用事件侦听器缓存。在使用 cacheHandlers 之后，事件侦听器将被缓存，并在下一次渲染时重用，从而避免在每次渲染时都重新创建。

具体来说，cacheHandlers 事件侦听器缓存主要有以下几个优化点：

1.  缓存事件侦听器：缓存常见的事件侦听器，避免在每次渲染时都重新创建。
    
2.  重用事件侦听器：在下一次渲染时重用已经缓存的事件侦听器，避免创建新的事件侦听器。
    
3.  减少内存占用：由于缓存了事件侦听器，因此可以减少内存占用。
    

总的来说，cacheHandlers 事件侦听器缓存能够避免在每次渲染时都重新创建事件侦听器，从而提高渲染性能。在 Vue 3.0 中，可以通过将 cacheHandlers 设置为 true 来启用事件侦听器缓存。需要注意的是，对于动态事件名称的事件侦听器，仍然需要在每次渲染时重新创建。

Q:vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？

在 Vue 中实现权限管理，可以采用路由级别和组件级别的权限控制方式，以及在需要控制按钮级别权限时，可以通过 v-if 和 v-show 来进行控制。

1.  路由级别的权限控制

可以在路由配置时添加 meta 属性来标记该路由需要的权限，然后在路由导航守卫中进行权限验证。例如，可以在路由配置中添加 meta 属性：

```
{
  path: '/admin',
  name: 'Admin',
  component: Admin,
  meta: {
    requireAuth: true, // 需要登录才能访问
    requirePermission: ['admin'] // 需要管理员权限才能访问
  }
}

```

然后在路由导航守卫中进行权限验证：

```
router.beforeEach((to, from, next) => {
  if (to.meta.requireAuth && !isAuthenticated()) { // 需要登录才能访问
    next({ path: '/login', query: { redirect: to.fullPath } })
  } else if (to.meta.requirePermission && !hasPermission(to.meta.requirePermission)) { // 需要权限才能访问
    next({ path: '/403' })
  } else {
    next()
  }
})

```

2.  组件级别的权限控制

可以在组件内部通过 v-if 和 v-show 来控制组件的显示和隐藏，从而实现组件级别的权限控制。例如：

```
<template>
  <div>
    <div v-if="hasPermission('add')">添加按钮</div>
    <div v-if="hasPermission('edit')">编辑按钮</div>
    <div v-if="hasPermission('delete')">删除按钮</div>
  </div>
</template>

`<script>`
export default {
  methods: {
    hasPermission(permission) {
      return this.$store.state.user.permissions.includes(permission)
    }
  }
}
</script>

```

3.  按钮级别的权限控制

可以在按钮上通过 v-if 和 v-show 来控制按钮的显示和隐藏，从而实现按钮级别的权限控制。例如：

```
<template>
  <div>
    <button v-if="hasPermission('add')">添加</button>
    <button v-if="hasPermission('edit')">编辑</button>
    <button v-if="hasPermission('delete')">删除</button>
  </div>
</template>

`<script>`
export default {
  methods: {
    hasPermission(permission) {
      return this.$store.state.user.permissions.includes(permission)
    }
  }
}
</script>

```

在这里，hasPermission 方法用来判断当前用户是否拥有指定的权限，然后在模板中使用 v-if 和 v-show 来控制按钮的显示和隐藏。

需要注意的是，这种方式只能控制按钮的显示和隐藏，并不能真正禁用按钮。如果需要禁用按钮，可以通过添加 disabled 属性来实现。

Q:vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？

在 Vue 组件的 created 和 mounted 这两个生命周期钩子中请求数据，主要的区别在于组件和 DOM 是否已经创建完成。

1.  created 生命周期

created 生命周期在组件实例被创建后立即调用，此时组件的 DOM 结构还没有被创建，所以在 created 生命周期中不能访问 DOM 元素。created 生命周期主要用于一些数据初始化的操作，比如请求数据、绑定事件等。

在 created 生命周期中请求数据，由于此时组件的 DOM 结构还没有被创建，所以无法对数据进行渲染。因此，通常会使用异步请求的方式获取数据，在数据请求成功后，再通过改变组件的数据来触发视图的更新。

2.  mounted 生命周期

mounted 生命周期在组件的 DOM 结构被创建并插入到页面后调用，此时可以访问到 DOM 元素。在 mounted 生命周期中，可以进行一些需要操作 DOM 元素的操作，比如修改 DOM 元素的样式、添加事件监听器等。

在 mounted 生命周期中请求数据，由于此时组件的 DOM 结构已经被创建，因此可以直接对数据进行渲染，从而避免了数据加载完成后再触发视图更新的延迟。同时，由于 mounted 生命周期是在 DOM 元素创建之后才触发的，因此在 mounted 生命周期中可以获取到元素的尺寸、位置等信息，从而可以进行一些更加复杂的 DOM 操作。

综上所述，如果数据请求不需要操作 DOM 元素，那么可以在 created 生命周期中请求数据；如果数据请求需要操作 DOM 元素，那么可以在 mounted 生命周期中请求数据。不过，需要注意的是，在请求数据的过程中，可能会出现一些网络延迟等问题，因此需要对数据加载状态进行处理，以提供更好的用户体验。

Q:说说你对 vue 中 proxy 的理解

在 Vue 3 中，代理（Proxy）被用于取代 Object.defineProperty，成为了 Vue 的响应式系统的核心实现方式。

Proxy 可以拦截对象的属性访问、赋值、删除等操作，并在这些操作发生时触发回调函数。这使得我们可以监听到对象的变化，并及时更新视图。

与 Object.defineProperty 不同的是，Proxy 是基于底层引擎实现的，因此可以实现更高效、更全面的拦截功能。例如，Proxy 可以拦截数组的 push、pop、shift、unshift 等方法，以及 Symbol 类型的属性访问等。

在 Vue 中，通过 Proxy 实现了 Vue 3 的响应式系统。当我们在组件中定义一个响应式的数据，Vue 会自动为这个数据创建一个对应的 Proxy 对象，并对这个对象进行拦截。当这个数据发生变化时，Vue 会自动触发视图的更新，从而实现了响应式的效果。

在使用 Proxy 进行开发时，我们需要了解 Proxy 的基本用法和一些注意事项，以充分利用它的特性，并避免一些潜在的问题。例如，由于 Proxy 是一个比较新的特性，因此在一些老的浏览器中可能不支持，需要进行兼容性处理；同时，在使用 Proxy 进行开发时，也需要注意一些性能问题，避免因为过度使用 Proxy 导致性能下降等问题。

Q:vue2 和 vue3 中如何使用 JSX

JSX 是一种基于 JavaScript 的语法扩展，可以用于构建 React 应用程序。在 Vue 中，JSX 也可以用来描述组件的渲染输出。

在 Vue 2.x 中，如果想要使用 JSX，需要使用第三方库 vue-jsx，并且需要在 Vue 项目中配置 Babel 插件支持 JSX 语法。使用 JSX 的基本流程如下：

1.  安装 vue-jsx 库。

```
npm install vue-jsx --save

```

2.  配置 Babel 插件支持 JSX 语法。

```
// .babelrc
{
  "plugins": ["transform-vue-jsx"]
}

```

3.  在组件中使用 JSX 语法。

```
<template>
  <div>
    <h1>{title}</h1>
    <ul>
      {list.map((item) => (
        <li key={item.id}>{item.text}</li>
      ))}
    </ul>
  </div>
</template>

`<script>`
export default {
  data() {
    return {
      title: 'Hello, Vue!',
      list: [
        { id: 1, text: 'item 1' },
        { id: 2, text: 'item 2' },
        { id: 3, text: 'item 3' },
      ],
    };
  },
};
</script>

```

在 Vue 3 中，Vue 提供了对 JSX 的原生支持，因此可以直接在组件中使用 JSX，而不需要使用第三方库或者配置额外的 Babel 插件。使用 JSX 的基本流程如下：

1.  安装 Vue 3。

```
npm install vue@next --save

```

2.  在组件中使用 JSX 语法。

```
<template>
  <div>
    <h1>{title}</h1>
    <ul>
      {list.map((item) => (
        <li key={item.id}>{item.text}</li>
      ))}
    </ul>
  </div>
</template>

`<script>`
import { defineComponent } from 'vue';

export default defineComponent({
  data() {
    return {
      title: 'Hello, Vue!',
      list: [
        { id: 1, text: 'item 1' },
        { id: 2, text: 'item 2' },
        { id: 3, text: 'item 3' },
      ],
    };
  },
});
</script>

```

需要注意的是，虽然 Vue 3 原生支持 JSX，但是仍然建议在组件中使用模板语法，因为模板语法的可读性更高，并且可以更方便地使用 Vue 的指令和插值语法等特性。而在一些需要高度定制化的场景下，可以使用 JSX 来进行扩展。

Q:angularJs 和 React 区别

AngularJS 和 React.js 都是目前非常流行的前端框架，它们在很多方面有着不同的设计理念和特点。

1.  架构设计：AngularJS 是一个完整的前端框架，提供了完整的架构设计和工具链，包括模板语法、指令、路由、依赖注入、服务等等。React.js 则更加轻量，只提供了视图层的解决方案，需要搭配其他工具和库使用。
    
2.  数据绑定：AngularJS 使用双向数据绑定，通过脏值检测机制实现数据的自动更新，但是会带来一些性能问题。React.js 则使用单向数据流，通过组件的 props 和 state 实现数据传递和渲染更新。
    
3.  组件化开发：AngularJS 的组件开发是基于指令的，指令可以实现组件化的效果，但是较为复杂。React.js 则直接使用组件的方式，通过 JSX 实现组件的定义和渲染。
    
4.  性能优化：AngularJS 在处理大规模数据和复杂组件时会存在性能问题，需要进行一些优化措施。React.js 则通过虚拟 DOM 和 diff 算法实现高效的渲染更新。
    
5.  学习曲线：由于 AngularJS 提供了完整的架构设计和工具链，因此学习曲线较为陡峭。React.js 则更加容易上手，但是需要结合其他工具和库使用。
    

总的来说，AngularJS 更加适合大型应用程序的开发，提供了完整的解决方案和工具链，但是需要考虑性能问题和学习曲线。React.js 则更加轻量，适合快速开发和迭代，但是需要结合其他工具和库使用，同时也需要注意性能优化的问题。

Q:讲一讲 redux 和 redux 中间件

Redux 是一个 JavaScript 状态管理库，它可以帮助开发者管理复杂的应用程序状态。Redux 提供了一个可预测的状态容器，使用单一的、不可变的状态树来管理应用程序中的所有状态。

在 Redux 中，应用程序状态被存储在一个称为 Store 的对象中，Store 包含了应用程序的状态和一些操作状态的方法，例如 getState()、dispatch(action) 和 subscribe(listener) 等方法。通过使用 Redux，我们可以更好地组织应用程序的状态，并实现更好的状态管理。

Redux 中间件是一个扩展点，它可以在处理 Redux action 和 reducer 之间插入一些自定义的逻辑。中间件可以用来处理异步操作、日志记录、异常处理等功能。

常见的 Redux 中间件包括：

1.  redux-thunk：用来处理异步操作，支持 dispatch 函数的返回值是一个函数，可以在函数中进行异步操作。
    
2.  redux-logger：用来记录应用程序中的 action 和 state，方便开发和调试。
    
3.  redux-saga：用来处理异步操作，支持使用 ES6 的 Generator 函数进行异步流程控制。
    
4.  redux-persist：用来将应用程序状态持久化到本地存储中，以便在刷新页面或关闭浏览器后能够保持状态。
    
5.  redux-form：用来处理表单状态，提供了一些表单相关的操作方法和组件。
    

通过使用 Redux 中间件，我们可以更加灵活地处理应用程序的状态和逻辑，提高开发效率和代码质量。

Q:redux 有什么缺点

Redux 作为一个状态管理库，在使用中也存在一些缺点，包括：

1.  学习成本高：Redux 的概念和使用方式相对于其他状态管理库来说比较复杂，需要花费一定的时间和精力去学习和理解。
    
2.  冗余代码多：使用 Redux 可能需要写更多的冗余代码，如定义 action、reducer、store 等，而且 Redux 对于小型应用来说可能会过于复杂。
    
3.  过度集中化：Redux 的数据流非常集中化，所有的状态都需要经过一个中央 store 进行管理，可能会导致代码的可维护性和扩展性变差。
    
4.  不适用于所有场景：对于简单的应用程序，使用 Redux 可能会显得过于复杂，而对于大型的复杂应用程序，Redux 的优势也可能被其他状态管理库所超越。
    
5.  调试困难：由于 Redux 中所有的状态都经过一个中央 store 进行管理，因此在调试时可能会比较困难，需要额外的工具或技巧来辅助调试。
    

总的来说，Redux 是一种非常强大和灵活的状态管理库，但是在使用时需要权衡利弊，根据具体的应用场景来选择合适的状态管理方案。

Q:React 组件的划分业务组件技术组件？

在 React 中，组件的划分一般可以分为业务组件和技术组件两种类型：

1.  业务组件：主要用于实现具体的业务功能，通常是由多个技术组件组合而成的。这种组件一般是根据业务需求来定义的，可以复用，但是不具有通用性。
    
2.  技术组件：主要用于实现一些通用的功能或者特定的技术要求，比如表单控件、数据可视化组件等。这种组件一般具有通用性和复用性，可以被多个业务组件所使用。
    

在具体实现时，可以按照业务功能的不同将组件进行分类，根据需要将不同的技术组件组合在一起构成业务组件。同时，为了提高组件的复用性，还可以将一些常用的技术组件封装成通用的组件库，方便在多个业务组件中复用。

总的来说，React 组件的划分是根据业务需求和技术要求来定义的，同时需要考虑到组件的复用性和通用性，以便实现高效的开发和维护。

Q:React 生命周期函数

React 组件的生命周期函数包括以下几个阶段：

1.  挂载阶段：组件被创建并插入到 DOM 树中。

*   constructor：组件实例化时调用，可以在此初始化状态、绑定方法等。
*   getDerivedStateFromProps：在组件挂载之前和更新时调用，用于根据 props 的变化来更新 state。
*   render：将组件渲染到 DOM 中。
*   componentDidMount：组件被挂载后调用，可以在此进行异步操作、发起网络请求等。

2.  更新阶段：组件的 props 或 state 发生变化，导致组件重新渲染。

*   getDerivedStateFromProps：在组件更新时调用，用于根据 props 的变化来更新 state。
*   shouldComponentUpdate：组件是否需要更新，返回 true 或 false。
*   render：将组件重新渲染到 DOM 中。
*   componentDidUpdate：组件更新后调用，可以在此进行 DOM 操作、发起网络请求等。

3.  卸载阶段：组件从 DOM 树中移除。

*   componentWillUnmount：组件被卸载前调用，可以在此进行清理操作，比如清除定时器、取消网络请求等。

4.  错误处理阶段：组件在渲染过程中出现错误。

*   static getDerivedStateFromError：在组件渲染出错时调用，返回一个对象来更新 state。
*   componentDidCatch：在组件渲染出错后调用，可以在此进行错误的捕获和处理。

以上生命周期函数的使用可以帮助我们在不同阶段进行一些特定的操作，如在组件挂载后发起网络请求、在组件更新前判断是否需要重新渲染等。同时，生命周期函数也是 React 中一个非常重要的概念，了解和掌握它们的使用方式，可以提高我们的开发效率和代码质量。

Q:React 性能优化是哪个周期函数？

React 性能优化和渲染优化的关键是避免不必要的重新渲染。在 React 中，shouldComponentUpdate 生命周期函数可以用来优化组件的渲染。shouldComponentUpdate 在组件更新前被调用，如果返回值为 false，React 将跳过该组件的渲染，直接进入 componentDidUpdate 生命周期。

shouldComponentUpdate 接收两个参数：nextProps 和 nextState，分别表示组件即将接收的新 props 和新 state。可以通过比较当前的 props 和 state 与即将更新的 props 和 state 是否相等来决定是否需要重新渲染组件。

例如，如果组件的 props 和 state 没有发生变化，那么就可以返回 false，避免不必要的重新渲染：

```
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.props.foo === nextProps.foo && this.state.bar === nextState.bar) {
      return false;
    }
    return true;
  }
  // ...
}

```

需要注意的是，在进行 shouldComponentUpdate 优化时，应该确保比较的数据是不可变的。因为 React 使用的是浅比较，如果进行的是深比较，会导致性能问题和错误。

除了 shouldComponentUpdate，React 还提供了 React.PureComponent，它已经默认实现了 shouldComponentUpdate，并对 props 和 state 进行了浅比较，可以用来优化组件的渲染。如果组件的 props 和 state 都是不可变的，可以将组件改为继承自 React.PureComponent。

除了以上两种方法，还可以使用 React.memo 进行函数组件的优化，它类似于 PureComponent，但是用于函数组件。如果函数组件的输入 props 没有变化，React 将跳过该组件的渲染。

Q:为什么虚拟 dom 会提高性能?

虚拟 DOM 会提高性能，主要是因为它可以避免大量的 DOM 操作。在传统的前端开发中，每次更新界面时，都需要对 DOM 进行操作，例如修改样式、插入、删除、更新元素等。而这些操作都是非常消耗性能的，因为 DOM 操作是相对较慢的。

虚拟 DOM 的作用是在内存中维护一个虚拟的 DOM 树，每次更新时先对虚拟 DOM 进行操作，然后再将虚拟 DOM 和实际 DOM 进行对比，最后只更新需要更新的部分。由于在内存中进行操作，而不是直接操作 DOM，可以大大减少 DOM 操作的次数，从而提高性能。

此外，虚拟 DOM 还可以实现批量操作，即将多个 DOM 操作合并成一个，从而减少了浏览器的重排和重绘次数，进一步提高了性能。

虚拟 DOM 的另一个优点是可以进行跨平台开发，例如使用 React Native 开发移动端应用，可以通过类似于虚拟 DOM 的方式实现对原生组件的操作。这种跨平台的开发方式可以大大减少开发成本和维护成本，提高开发效率。

Q:讲一讲 diff 算法?

在 React 中，虚拟 DOM 的更新是通过 diff 算法来实现的。diff 算法的主要作用是比较两个虚拟 DOM 树的差异，然后只更新发生变化的部分，从而减少了对实际 DOM 的操作，提高了渲染效率。

diff 算法的核心思想是分层比较和同层比较。分层比较是指对于不同类型的元素，直接将其替换；对于相同类型的元素，则只更新变化的属性。同层比较是指对于同一层级的元素，通过唯一的 key 属性来进行比较，从而确定哪些元素需要被移动、添加、删除等操作。

diff 算法的具体实现包括以下步骤：

1.  比较两个根节点的类型，如果不同，则直接替换。
    
2.  如果类型相同，则比较两个节点的属性，只更新变化的部分。
    
3.  对于同一层级的节点，通过 key 属性进行比较，从而确定哪些元素需要被移动、添加、删除等操作。
    
4.  对于子节点，递归执行以上步骤。
    

需要注意的是，diff 算法并不是完美的，它有时候可能会出现一些不必要的更新操作，从而降低性能。因此，在编写 React 组件时，需要尽量避免不必要的更新，减少 diff 算法的执行次数，提高性能。例如，可以通过 shouldComponentUpdate 或者 PureComponent 来避免不必要的更新。同时，也可以通过使用 React.memo 或者使用 useContext、useReducer 等 Hook 来优化组件

Q:React 性能优化方案

React 性能优化可以从多个方面入手，包括组件设计、渲染优化、数据管理等方面。下面列举一些常见的优化方案：

1.  组件设计方面

(1) 拆分组件：将大的组件拆分成多个小组件，避免单个组件的复杂度过高。

(2) 组件懒加载：只在需要时才加载组件，减少页面初始化时的开销。

(3) 避免过深的嵌套：嵌套层次过深会影响渲染性能，可以通过拆分组件或者使用 React.Fragment 等方式来避免。

2.  渲染优化方面

(1) 避免不必要的渲染：使用 shouldComponentUpdate 或者 PureComponent 避免不必要的组件渲染。

(2) 使用 React.memo：类似于 PureComponent，但是只会对 props 进行浅比较，适用于函数组件。

(3) 使用 key：为列表元素指定唯一的 key 属性，避免不必要的重新渲染。

(4) 使用动画库：使用优秀的动画库来避免手写 CSS 动画带来的性能问题。

3.  数据管理方面

(1) 使用 immutable.js：使用 immutable.js 来管理数据，避免不必要的数据变更和渲染。

(2) 使用 redux 或者 mobx：使用 redux 或者 mobx 等数据管理库，避免组件状态的复杂管理。

(3) 使用 Hooks：使用 useContext、useReducer 等 Hook 来管理组件状态，避免类组件的复杂管理。

除了上述优化方案，还有一些其他的优化方案，比如服务器端渲染、Webpack 打包优化等。需要根据具体的场景和问题来综合考虑，选择合适的方案来提高性能。

Q:简述 flux 思想

Flux 是一种前端架构模式，由 Facebook 提出。其主要思想是通过数据单向流动来管理应用程序的状态。Flux 的核心包括四个部分：Action、Dispatcher、Store 和 View。

1.  Action

Action 定义了一个应用中可能发生的事件，可以看作是一个数据包，它包含一个 type 字段来描述事件的类型，还可能包含一些数据。Action 的创建可以通过 Action Creator 来实现，Action Creator 是一个工厂函数，用于创建 Action 对象。

2.  Dispatcher

Dispatcher 是一个全局的事件分发器，它负责将 Action 分发给注册的 Store，让 Store 可以更新自己的状态。Dispatcher 可以看作是一个中央控制器，用于协调整个应用的状态变化。

3.  Store

Store 是应用程序的状态管理器，负责存储应用程序的状态和数据，并且监听 Dispatcher 发出的 Action。当接收到 Action 后，Store 会根据 Action 的类型来更新自己的状态和数据，然后通过事件通知 View 进行更新。

4.  View

View 是应用程序的用户界面，负责显示数据和接收用户输入，并且监听 Store 的变化来自动更新界面。View 可以通过 Store 注册自己感兴趣的事件，当事件触发时，View 就会自动更新自己的状态。

在 Flux 的架构中，数据流是单向的，从 Action 到 Dispatcher，再到 Store，最后到 View。这样可以保证整个应用程序的状态变化是可预测的，方便开发和维护。同时，由于数据流是单向的，所以可以避免循环依赖和不必要的状态更新，提高应用程序的性能。

Q:React 项目用过什么脚手架？

在 React 项目开发中，可以使用多种脚手架来快速搭建项目结构和开发环境，常见的脚手架包括 create-react-app、Next.js、Gatsby 等。

其中，create-react-app 是 React 官方推荐的脚手架，可以快速创建一个基于 React 的项目，包括开发环境和构建工具等。create-react-app 会自动配置 Webpack、Babel 等工具，让开发者可以专注于编写代码。

Next.js 是一个基于 React 的服务器端渲染框架，可以帮助开发者快速构建高性能的 React 应用程序，同时支持自定义路由、静态页面生成等功能。

Gatsby 是一个基于 React 的静态站点生成器，可以将 React 组件编译成静态 HTML 文件，从而实现更快的页面加载速度和更好的 SEO 效果。

选择哪种脚手架取决于项目的具体需求和开发者的个人偏好，通常需要综合考虑项目的规模、开发人员的技能水平、需求的复杂度和性能等方面进行评估和选择。

Q:你了解 React 吗？

是的，我了解 React。

React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并开源。它采用组件化的思想，将 UI 分解成独立的、可复用的组件，通过组合这些组件来构建复杂的用户界面。React 采用虚拟 DOM 技术，能够高效地渲染页面，同时提供了丰富的生命周期函数和钩子函数，方便开发者在不同的生命周期阶段进行数据处理和业务逻辑的处理。

React 还提供了一些其他的特性，比如 JSX 语法、单向数据流、事件机制等，让开发者能够更加高效地构建复杂的用户界面。同时，React 社区也非常活跃，有大量的第三方库和组件可供使用，方便开发者快速构建应用程序。

总的来说，React 是一种非常流行的前端开发技术，适用于各种规模的应用程序和各种类型的应用场景。

Q:React 解决了什么问题？

React 解决了构建复杂用户界面的一些问题，主要包括以下几个方面：

1.  提高了应用的性能：React 的虚拟 DOM 技术能够高效地渲染页面，减少了 DOM 操作带来的性能消耗，从而提高了应用的性能。
    
2.  提高了代码的可维护性：React 采用组件化的思想，将页面分解成独立的、可复用的组件，使得代码的结构更加清晰，易于维护和修改。
    
3.  提高了开发效率：React 提供了丰富的生命周期函数和钩子函数，方便开发者在不同的生命周期阶段进行数据处理和业务逻辑的处理，同时还提供了一些其他的特性，比如 JSX 语法、单向数据流、事件机制等，让开发者能够更加高效地构建复杂的用户界面。
    
4.  解决了跨浏览器兼容性问题：React 采用了虚拟 DOM 技术，使得应用的渲染结果与浏览器无关，从而解决了跨浏览器兼容性问题。
    

总的来说，React 是一种高效、可维护、易用的前端开发技术，能够帮助开发者更加高效地构建复杂的用户界面，同时还解决了一些传统 Web 开发中的一些问题，成为了非常流行的前端框架之一。

Q:React 的协议？

React 并没有特定的协议，它是一种开源的前端开发技术，使用 React 开发的应用程序可以选择不同的协议进行发布和分发。一般来说，React 应用程序的部署方式和协议，取决于应用程序的需求和实际情况。常见的部署方式包括静态网站托管、云服务部署、自主服务器部署等，而协议方面则可以选择 HTTP、HTTPS、FTP 等不同的协议进行发布和分发。总之，React 并不限制应用程序的部署方式和协议，开发者可以根据实际情况进行选择。

Q:了解 shouldComponentUpdate 吗？

`shouldComponentUpdate` 是 React 组件生命周期中的一个方法，用于控制组件是否需要更新，返回值为布尔类型。

当组件的状态或属性发生变化时，React 会检查该组件是否需要重新渲染。如果组件需要重新渲染，React 会执行一系列操作来更新组件的视图。而 `shouldComponentUpdate` 就是在这个过程中被调用的，用于帮助 React 判断是否需要更新组件。

如果 `shouldComponentUpdate` 返回 `true`，则组件会继续更新，否则则会跳过更新。在一些性能要求较高的场景下，可以使用 `shouldComponentUpdate` 来优化组件的渲染，避免不必要的重复渲染。

需要注意的是，使用 `shouldComponentUpdate` 可能会对代码的可读性和维护性造成一定的影响，因此需要在实际情况下进行权衡。在一些简单的组件中，可能不需要使用 `shouldComponentUpdate` 来进行性能优化，而在一些复杂的组件中，使用 `shouldComponentUpdate` 可能是必要的。

Q:React 的工作原理？

React 的工作原理可以简单地概括为：通过虚拟 DOM（Virtual DOM）和 diff 算法，实现了高效的更新和渲染。

当 React 应用程序运行时，它会将应用程序的状态转换为虚拟 DOM，并将其渲染到浏览器中。虚拟 DOM 是一个轻量级的 JavaScript 对象树，它对应着真实 DOM 的结构和属性，但不包含任何真实的内容。

当应用程序状态发生

Q:使用 React 有何优点？

React 作为一种流行的前端框架，具有以下优点：

1.  组件化：React 的组件化能力很强，组件可以嵌套组件，提高了代码的可重用性和可维护性。
    
2.  虚拟 DOM：React 利用虚拟 DOM 技术，将页面渲染成一个虚拟 DOM 树，当组件状态发生变化时，React 会比对新旧虚拟 DOM 树，找出变化的部分进行重新渲染，提高了页面的性能。
    
3.  单向数据流：React 数据流是单向的，自上而下传递，使得数据变化更可控，便于开发和调试。
    
4.  高效的性能：React 可以提供高效的性能，如组件的局部更新、虚拟 DOM 等技术，可以避免整个页面的刷新，提高了页面的响应速度。
    
5.  社区活跃：React 有着庞大的社区，拥有大量的插件和组件库，可以方便地实现各种功能。
    
6.  JSX：React 支持 JSX 语法，可以将 HTML 和 JavaScript 写在同一个文件中，提高了代码的可读性和可维护性。
    

总的来说，React 具有良好的组件化能力、高效的性能、便捷的开发体验以及强大的生态圈等优点，因此被广泛应用于 Web 开发领域。

Q:展示组件(Presentational component)和容器组件(Container component)之间有何不同？

展示组件 (Presentational component) 和容器组件 (Container component) 是 React 中常用的两种组件类型，它们有以下不同：

1.  展示组件主要负责 UI 的呈现，通常由 HTML 和 CSS 组成，具有可复用性、独立性，是应用程序的纯组件。
2.  容器组件主要负责业务逻辑，负责与数据打交道，使用 Redux 或其他 Flux 实现来管理应用程序的状态，并将状态和属性传递给展示组件。
3.  展示组件和容器组件之间的通信是通过 props 来实现的。
4.  展示组件没有状态，容器组件拥有状态，所以可以将容器组件理解为展示组件的控制器。

通常，在 React 应用程序中，我们可以将 UI 与业务逻辑分离到不同的组件中，这种分离方式可以提高应用程序的可重用性、可测试性和可维护性。展示组件通常是无状态组件，容器组件则负责管理应用程序的状态。通过将 UI 和业务逻辑分离到不同的组件中，我们可以更好地管理应用程序的状态，并使应用程序更易于开发、测试和维护。

Q:类组件(Class component)和函数式组件(Functional component)之间有何不同？

类组件 (Class component) 和函数式组件 (Functional component) 是 React 中常用的两种组件类型，它们有以下不同：

1.  类组件是通过继承 React.Component 类来定义的，而函数式组件是通过函数来定义的。
2.  类组件中可以定义 state 和生命周期方法，而函数式组件没有状态和生命周期方法。React 16.8 版本引入了 hooks，使得函数式组件可以使用 state 和生命周期方法，使得函数式组件可以取代类组件的使用。
3.  在处理 props 时，类组件需要使用 this.props 来访问 props，而函数式组件可以直接使用函数的参数来访问 props。
4.  在类组件中，this 指向当前组件实例，而在函数式组件中，this 不存在。

通常情况下，我们可以根据组件的需要来选择使用类组件或函数式组件，如果组件需要使用状态或生命周期方法，那么我们可以使用类组件，否则我们可以使用函数式组件来编写代码，因为函数式组件通常更加简单，易于编写、测试和维护，同时还可以提供更好的性能。随着 hooks 的引入，函数式组件的能力不断提升，已经成为了 React 中的重要组件类型。

Q:(组件的)状态(state)和属性(props)之间有何不同？

在 React 中，组件的状态（state）和属性（props）是两个不同的概念，它们之间有以下不同：

1.  状态（state）是组件内部的状态，可以通过 this.state 属性来访问。状态是可变的，可以在组件内部被修改，修改状态后，React 会重新渲染组件并更新组件的显示。
2.  属性（props）是由父组件传递给子组件的数据，子组件通过 this.props 属性来访问。属性是不可变的，只能从父组件中接收数据，不能在组件内部修改。如果需要修改属性中的数据，需要由父组件更新传递给子组件的属性。

因此，状态和属性在作用上是有很大不同的。状态通常用于保存组件的内部数据，而属性则用于从父组件传递数据到子组件。在 React 应用程序中，组件的状态和属性通常被用来管理和显示数据，以及响应用户的操作和事件。由于状态和属性是 React 中非常重要的概念，因此开发者在编写 React 组件时，需要深入了解它们的特点和用法。

Q:应该在 React 组件的何处发起 Ajax 请求？

在 React 组件中发起 Ajax 请求应该在生命周期函数中进行。一般情况下，建议在组件挂载后调用 `componentDidMount` 函数发起 Ajax 请求。因为在该生命周期函数中，组件已经被渲染到页面上，可以确保该函数中的代码只会在客户端执行一次，避免了因多次发送请求导致的性能问题。

如果数据需要在组件更新时刷新，则可以在 `componentDidUpdate` 函数中发起 Ajax 请求。在该函数中，需要判断当前组件的状态和属性是否发生变化，以避免无限循环请求数据。

需要注意的是，在组件销毁时，需要清理掉无效的 Ajax 请求。可以在 `componentWillUnmount` 函数中取消未完成的请求或者清理定时器等资源。

Q:在 React 中，refs 的作用是什么？

在 React 中，refs（reference）是用来引用组件或 DOM 元素的对象，通常用于以下情况：

1.  访问 DOM 元素或组件实例：通过 `ref` 可以获取到组件实例或 DOM 元素，从而可以访问它们的属性和方法。
    
2.  聚焦元素：可以通过 `ref` 来获取某个输入框的 DOM 对象，并在需要时聚焦到该元素。
    
3.  调用子组件的方法：可以通过 `ref` 来获取子组件的实例，并调用其暴露的方法。
    

在使用 `ref` 时，可以使用字符串、函数或者 `createRef` 方法来创建一个引用。使用字符串的方式已经被弃用，推荐使用函数或者 `createRef` 方法。

使用函数的方式可以在组件挂载时将组件的实例传递给函数，从而保存到外部变量中，以便在需要时访问组件实例。例如：

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = null;
    this.setMyRef = element => {
      this.myRef = element;
    };
  }

  componentDidMount() {
    // 访问 DOM 元素
    if (this.myRef) {
      this.myRef.focus();
    }
  }

  render() {
    return <input ref={this.setMyRef} />;
  }
}

```

使用 `createRef` 方法可以在构造函数中创建一个 `Ref` 对象，然后将其传递给 `ref` 属性。例如：

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }

  componentDidMount() {
    // 访问 DOM 元素
    if (this.myRef.current) {
      this.myRef.current.focus();
    }
  }

  render() {
    return <input ref={this.myRef} />;
  }
}

```

总之，使用 `ref` 可以方便地访问组件实例和 DOM 元素，但是过度使用 `ref` 也可能导致代码复杂性和可读性降低。因此，在使用 `ref` 时，需要根据具体情况权衡利弊。

Q:何为高阶组件(higher order component)？

高阶组件（Higher Order Component，HOC）是指接受一个组件并返回一个新组件的函数。它本质上是一个函数，其参数是一个组件，返回值也是一个组件。在 React 中，高阶组件可以用于代码复用、逻辑抽象、状态管理等方面。

使用高阶组件可以实现以下功能：

*   属性代理：可以通过属性代理方式将 props 传递给包裹组件，从而可以修改或增强组件的 props；
*   反向继承：可以通过反向继承方式，修改或增强组件的渲染行为；
*   渲染劫持：可以拦截和修改组件的渲染结果，从而对组件的渲染进行自定义。

高阶组件在 React 中广泛应用，如 React-Redux 中的 `connect` 方法就是一个高阶组件，用于将 Redux 中的状态与组件连接起来。另外，`withRouter`、`withStyles`、`withTheme` 等方法也是常见的高阶组件。

Q:使用箭头函数(arrow functions)的优点是什么？

使用箭头函数有以下优点：

1.  简洁：相比于传统的函数定义方式，箭头函数的语法更加简洁，可以在保证代码可读性的前提下减少代码量。
    
2.  不改变 this 的指向：在传统函数定义中，函数内部的 this 指向可能会因为调用方式的不同而发生改变，但是箭头函数的 this 指向是固定的，指向定义时的 this。
    
3.  不需要显式绑定 this：使用箭头函数不需要再使用 `bind`、`call`、`apply` 等方式来显式绑定 this。
    
4.  可以更好的与其他函数式编程的概念配合使用：箭头函数在其他函数式编程概念，如纯函数、柯里化等方面具有更好的配合性。
    

需要注意的是，箭头函数也有一些缺点，例如在某些情况下可读性可能不如传统函数定义。

Q:为什么建议传递给 setState 的参数是一个 callback 而不是一个对 象？

在 React 中，`setState()` 是异步执行的，因此如果你想在更新状态后执行某些操作，例如获取更新后的状态值，那么你应该使用回调函数而不是传递一个对象作为 `setState()` 的参数。

这是因为当你传递一个对象时，React 可能会将多次状态更新合并为一个批处理更新以提高性能。如果你依赖于先前的状态值来更新状态，那么通过回调函数传递函数参数会确保你获得正确的值，因为回调函数会在更新被应用后立即执行。

Q:除了在构造函数中绑定 this，还有其它方式吗？

除了在构造函数中使用 `bind()` 方法绑定 `this`，还可以使用箭头函数或者使用 ES6 的类属性语法来避免 `this` 绑定问题。

使用箭头函数：

```
class Example extends React.Component {
  handleClick = () => {
    console.log(this); // `this` 绑定到了组件实例
  }
  
  render() {
    return <button onClick={this.handleClick}>Click Me</button>;
  }
}

```

使用类属性语法：

```
class Example extends React.Component {
  handleClick() {
    console.log(this); // `this` 绑定到了组件实例
  }
  
  render() {
    return <button onClick={this.handleClick}>Click Me</button>;
  }
}

Example.prototype.handleClick = Example.prototype.handleClick.bind(Example);

```

这些方法都可以避免 `this` 绑定问题，使得组件代码更加简洁易懂。

Q:怎么阻止组件的渲染？

在 React 中，你可以使用以下方法来阻止组件的渲染：

1.  shouldComponentUpdate: 如果 `shouldComponentUpdate` 方法返回 false，则组件将不会重新渲染。
    
2.  PureComponent: PureComponent 是 React 提供的一种优化手段，它会自动判断是否需要重新渲染组件，从而减少不必要的渲染操作。
    
3.  React.memo: React.memo 可以用来包装一个函数组件，使其只在 props 发生变化时才会重新渲染。
    
4.  shouldUpdate: 对于函数组件，你可以使用 shouldUpdate 钩子来阻止组件的重新渲染。
    
5.  使用 key: 当你在渲染列表时，使用 key 可以帮助 React 判断哪些元素需要重新渲染，从而避免不必要的渲染操作。
    

需要注意的是，这些方法只是帮助你优化组件性能的手段，如果你频繁地使用这些方法来阻止组件渲染，可能会影响到应用的可维护性和开发效率，因此在使用时需要谨慎权衡。

Q:当渲染一个列表时，何为 key？设置 key 的目的是什么？

在 React 渲染列表时，每个渲染的元素都需要有一个唯一的标识。这个标识可以是列表项的某个属性值或者是通过 `key` 属性显式指定的值。

设置 `key` 的目的是帮助 React 识别哪些元素发生了变化，从而尽可能地避免不必要的重新渲染，提高性能。

当有一个元素从列表中移除时，React 会根据 `key` 来决定该元素是否需要重新创建。如果没有 `key` 或者 `key` 值相同，那么 React 会认为这是同一个元素，不会重新创建；如果 `key` 值不同，则 React 会重新创建该元素。

另外，使用 `key` 还可以帮助 React 在开发者工具中正确地显示组件层次结构。

Q:(在构造函数中)调用 super(props) 的目的是什么

在 React 中，如果在构造函数中定义了子类的构造函数，则需要在子类的构造函数中调用 `super(props)`，以便能够正确地设置 `this.props` 属性。`super(props)` 的作用是调用父类的构造函数，将传递的 props 参数传递给父类构造函数，以便能够正确地初始化组件。如果不调用 `super(props)`，则在子类的构造函数中无法使用 `this.props` 属性。

Q:何为 JSX ？

JSX是一种类XML语法的扩展，用于在React中描述UI组件的结构和样式。它允许我们在JavaScript中编写类似于HTML的标记，从而使代码更加简洁和易读。JSX最终会被转换为React元素，因此可以在应用程序中渲染为真实的DOM元素。同时，JSX还支持JavaScript表达式的嵌入，使得我们可以更加方便地动态地生成UI组件。

Q:Angular 中组件之间通信的方式

在 Angular 中，组件之间有多种通信方式，包括：

1.  通过 `@Input()` 和 `@Output()` 装饰器来进行父子组件之间的通信。`@Input()` 用于从父组件传递数据到子组件，`@Output()` 则用于从子组件向父组件发送事件。
    
2.  使用 `ViewChild` 或 `ContentChild` 来访问子组件或子组件的内容。`ViewChild` 用于访问组件视图中的一个子组件或元素，`ContentChild` 则用于访问组件内容中的一个子组件或元素。
    
3.  使用服务来实现组件之间的通信。服务是一个单例对象，可以在组件之间共享数据。
    
4.  使用路由来实现组件之间的通信。通过路由参数或查询参数，可以将数据从一个组件传递到另一个组件。
    
5.  使用状态管理库，如 NgRx 或 Redux，来管理应用程序的状态。这种方式可以实现跨组件和跨页面的数据共享。
    

Q:Angualr 的八大组成部分并简单描述

Angular 的八大组成部分如下：

1.  组件(Component)：是 Angular 的基础构建块，用于定义应用程序中的可重用视图。
    
2.  模板(Template)：是一个 HTML 文件，其中包含 Angular 模板语法和绑定，用于定义组件的视图。
    
3.  模块(Module)：用于将一些相关的组件、指令、管道等打包成一个功能完整的单元，以便于管理和重用。
    
4.  服务(Service)：提供了在组件之间共享数据和逻辑的方式，可以用于实现组件之间的通信，或者向服务器请求数据等。
    
5.  路由(Router)：用于管理应用程序中的导航和视图展示，提供了在不同视图之间进行导航的功能。
    
6.  指令(Directive)：用于扩展 HTML 元素的功能，例如 ngIf 和 ngFor 等。
    
7.  管道(Pipe)：用于格式化和转换数据，例如将数据转换为货币格式或日期格式。
    
8.  依赖注入(Dependency Injection)：是一种设计模式，用于在组件和服务之间进行通信，实现了松耦合和可重用性的目标。
    

Q:Angular 中常见的生命周期的钩子函数?

Angular 中常见的生命周期钩子函数包括：

1.  ngOnChanges：当输入属性的值发生变化时调用。
2.  ngOnInit：在组件初始化时调用，通常用来进行初始化操作。
3.  ngDoCheck：检测并处理变化时调用，可以自定义检测逻辑。
4.  ngAfterContentInit：在组件内容投影到视图后调用。
5.  ngAfterContentChecked：在组件内容投影到视图并进行变更检测之后调用。
6.  ngAfterViewInit：在组件视图初始化之后调用。
7.  ngAfterViewChecked：在组件视图初始化并进行变更检测之后调用。
8.  ngOnDestroy：在组件销毁之前调用，通常用来进行资源清理操作。

这些生命周期钩子函数可以帮助开发者在组件不同的生命周期阶段进行相应的操作，以便更好地控制组件的行为。

Q:Angular 中路由的工作原理

Angular 的路由机制是通过 Angular 自带的 `RouterModule` 模块来实现的。它提供了多种方式来配置路由，使得开发者可以方便地实现页面间的跳转、懒加载等功能。

在 Angular 中，路由的工作原理可以简单概括为以下几个步骤：

1.  在 `app.module.ts` 中引入 `RouterModule` 模块，并在 `imports` 中进行配置。
    
2.  在组件中定义路由：
    
    ```
    typescriptCopy code`const routes: Routes = [
      { path: '', component: HomeComponent },
      { path: 'about', component: AboutComponent },
      { path: 'contact', component: ContactComponent }
    ];` 
    ```
    
3.  在组件中使用 `routerLink` 属性来定义路由链接，比如：
    
    ```
    htmlCopy code`<a routerLink="/">Home</a>
    <a routerLink="/about">About</a>
    <a routerLink="/contact">Contact</a>` 
    ```
    
4.  在组件中使用 `router-outlet` 元素来显示路由组件：
    
    ```
    htmlCopy code`<router-outlet></router-outlet>` 
    ```
    
    这个元素是路由器动态加载组件的位置标记。
    
5.  在 `app.component.ts` 中使用 `router.navigate` 方法来进行编程式导航：
    
    ```
    typescriptCopy code`import { Router } from '@angular/router';
    
    constructor(private router: Router) {}
    
    goToAbout() {
      this.router.navigate(['/about']);
    }` 
    ```
    
    `router.navigate` 方法接收一个包含路由信息的数组参数，比如 `['/about']`，用于跳转到指定路由。
    

通过以上步骤，Angular 就可以完成路由的配置和实现。需要注意的是，路由还支持一些高级功能，比如路由守卫、动态路由等，开发者可以根据需要进行配置和使用。

Q:解释 rjx 在 Angular 中的使用场景

我认为你指的是 RxJS（Reactive Extensions for JavaScript），它是一个用于处理异步数据流的库，常用于 Angular 中进行事件处理、数据流处理和状态管理等方面。

RxJS 基于观察者模式和迭代器模式，提供了丰富的操作符和工具函数，可以轻松地实现各种异步数据流处理的需求。在 Angular 中，RxJS 通常用于以下场景：

1.  处理 HTTP 请求：通过使用 RxJS 的 Observable 对象和各种操作符，可以轻松地对 HTTP 请求进行处理和转换，实现各种复杂的数据流处理逻辑。
    
2.  处理用户事件：Angular 中的事件机制基于 RxJS 的 Observable 对象，可以对各种用户事件进行处理，包括点击事件、键盘事件、鼠标事件等。
    
3.  状态管理：RxJS 可以帮助开发者轻松地管理 Angular 应用的状态，通过使用 BehaviorSubject、Subject 和各种操作符，可以实现状态的变更、订阅、发布等操作。
    
4.  数据流处理：Angular 中的数据流处理通常基于 RxJS 的 Observable 对象和各种操作符，可以实现各种复杂的数据处理逻辑，包括数据过滤、数据映射、数据合并等。
    

总之，RxJS 是 Angular 中非常重要的一部分，它提供了强大的异步数据流处理能力，可以帮助开发者更加轻松地处理各种异步数据操作，提高代码的可读性和可维护性。